{
  "timestamp": "2025-11-10T17:02:01.130496",
  "repository": "test-repo",
  "examples": [
    {
      "example_id": "01-abi-methods-with-default-arguments",
      "title": "ABI Methods with Default Arguments",
      "summary": "Demonstrates how to call ABI methods that have default argument values, allowing for simplified method calls when optional parameters are not needed",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call an ABI method with a default argument value defined as a constant",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ABI methods with default arguments",
        "default value from constant"
      ],
      "feature_tags": [
        "abi",
        "default-arguments",
        "method-calls",
        "optional-parameters"
      ],
      "folder": "01-abi-methods-with-default-arguments",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "TEST_ACCOUNT",
            "required": true,
            "example": "Your test account mnemonic or private key"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy your smart contract with an ABI method that has default arguments"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Result when calling method with explicit argument: 'defined value'",
        "Result when calling method without argument: 'default value' (the default)",
        "Explanation of how default arguments work in ABI methods"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "from const"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "TestApp.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract with a method that has default argument: default_value(string)string with default='default value'"
        }
      ],
      "notes": "Default arguments in ABI methods provide a cleaner API for smart contract interactions, allowing developers to omit commonly-used values and reducing transaction complexity.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { TestAppClient } from './artifacts/TestApp/client' // Adjust import based on your app\n\n/**\n * Example: ABI Methods with Default Arguments\n * \n * This example demonstrates how to call ABI methods that have default argument values.\n * When a method has default arguments, you can omit those arguments and the default\n * value will be used automatically.\n */\nasync function abiDefaultArguments() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n  \n  // Get a test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('\\n--- ABI Methods with Default Arguments Example ---\\n')\n  \n  // Assume we have a deployed app client\n  const client = new TestAppClient(\n    {\n      sender: testAccount,\n      resolveBy: 'id',\n      id: 0, // Your app ID\n    },\n    algorand.client.algod\n  )\n  \n  // ========================================\n  // Calling method WITH an explicit argument\n  // ========================================\n  console.log('1. Calling method with explicit argument:')\n  console.log('   Input: \"defined value\"')\n  \n  const resultWithArg = await client.send.call({\n    method: 'default_value',\n    args: ['defined value'],\n  })\n  \n  console.log(`   Output: ${resultWithArg.return?.returnValue}\\n`)\n  \n  // ========================================\n  // Calling method WITHOUT an explicit argument (using default)\n  // ========================================\n  console.log('2. Calling method without explicit argument (using default):')\n  console.log('   Input: <none - using default>')\n  \n  const resultWithDefault = await client.send.call({\n    method: 'default_value',\n    args: [], // No argument provided, will use default\n  })\n  \n  console.log(`   Output: ${resultWithDefault.return?.returnValue}\\n`)\n  \n  // ========================================\n  // Explanation\n  // ========================================\n  console.log('\\nHow it works:')\n  console.log('  - The ABI method \"default_value\" has a default argument value')\n  console.log('  - When called with an argument, it returns that argument')\n  console.log('  - When called without an argument, it returns the default value')\n  console.log('  - Default values can be constants defined in the smart contract')\n  \n  console.log('\\n\u2705 Successfully demonstrated ABI methods with default arguments!')\n}\n\n// Run the example\nabiDefaultArguments().catch(console.error)"
    },
    {
      "example_id": "02-asa-transfer-error-handling",
      "title": "ASA Transfer Error Handling",
      "summary": "Comprehensive example showing how to properly handle common errors when transferring ASAs, including opt-in requirements for both sender and receiver, and handling non-existent assets.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Handle errors when transferring ASAs: receiver not opted in, sender not opted in, and non-existent assets",
      "target_users": [
        "SDK developers",
        "Asset application developers",
        "DeFi developers"
      ],
      "features_tested": [
        "algorand.send.assetTransfer",
        "algorand.send.assetOptIn",
        "algorand.send.assetCreate",
        "asset opt-in validation",
        "asset existence validation",
        "error handling"
      ],
      "feature_tags": [
        "asa",
        "asset-transfer",
        "error-handling",
        "opt-in",
        "validation",
        "typescript"
      ],
      "folder": "02-asa-transfer-error-handling",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created with ID: <asset_id>",
        "Error caught when transferring to non-opted-in receiver: URLTokenBaseHTTPError",
        "Error message contains: receiver error: must optin",
        "Receiver account opted in successfully",
        "Error caught when sender not opted in: URLTokenBaseHTTPError",
        "Error message contains: sender error: must optin",
        "Error caught when transferring non-existent asset: URLTokenBaseHTTPError",
        "Error message contains: asset 1 missing from",
        "All error handling examples completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, receiver is not opted in"
        },
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, sender is not opted in"
        },
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, asset doesnt exist"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration for the example"
        },
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining the example and how to run it"
        }
      ],
      "notes": "This example combines three related test cases to provide a comprehensive guide to ASA transfer error handling. It's essential for developers building robust asset applications.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Account } from 'algosdk'\n\n/**\n * This example demonstrates common error scenarios when transferring Algorand Standard Assets (ASAs).\n * It covers three important error cases:\n * 1. Transferring to a receiver that hasn't opted into the asset\n * 2. Transferring from a sender that hasn't opted into the asset\n * 3. Attempting to transfer a non-existent asset\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get test accounts from LocalNet dispenser\n  const dispenser = await algorand.account.dispenser()\n  const creator = await algorand.account.fromEnvironment('CREATOR')\n  \n  console.log('=== ASA Transfer Error Handling Examples ===')\n  console.log()\n\n  // Create a test asset\n  console.log('Creating test asset...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: creator.addr,\n    total: 100n,\n    decimals: 0,\n    assetName: 'Test Asset',\n    unitName: 'TEST',\n  })\n  const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n  console.log(`\u2713 Asset created with ID: ${assetId}`)\n  console.log()\n\n  // ========================================\n  // Example 1: Transfer to non-opted-in receiver\n  // ========================================\n  console.log('--- Example 1: Transfer to Non-Opted-In Receiver ---')\n  \n  // Create a new receiver account that hasn't opted in\n  const receiver1 = algorand.account.random()\n  \n  // Fund the receiver with initial ALGO\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: receiver1.addr,\n    amount: (1).algo(),\n  })\n  console.log(`Receiver account created: ${receiver1.addr}`)\n\n  try {\n    // Attempt to transfer asset to non-opted-in receiver\n    // This will fail because the receiver must opt-in first\n    await algorand.send.assetTransfer({\n      sender: creator.addr,\n      receiver: receiver1.addr,\n      assetId: assetId,\n      amount: 1n,\n    })\n    \n    console.log('\u274c Transfer should have failed but succeeded')\n  } catch (e: unknown) {\n    // This error is expected - receiver must opt-in before receiving assets\n    const error = e as Error\n    console.log(`\u2713 Error caught as expected: ${error.name}`)\n    console.log(`\u2713 Error message: ${error.message.substring(0, 100)}...`)\n    \n    if (error.message.includes('receiver error: must optin')) {\n      console.log('\u2713 Confirmed: Receiver must opt-in before receiving assets')\n    }\n  }\n  console.log()\n\n  // ========================================\n  // Example 2: Transfer from non-opted-in sender\n  // ========================================\n  console.log('--- Example 2: Transfer from Non-Opted-In Sender ---')\n  \n  // Create a new sender account that hasn't opted in\n  const sender2 = algorand.account.random()\n  \n  // Fund the sender with initial ALGO\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: sender2.addr,\n    amount: (1).algo(),\n  })\n  console.log(`Sender account created: ${sender2.addr}`)\n\n  // Create a receiver that HAS opted in\n  const receiver2 = algorand.account.random()\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: receiver2.addr,\n    amount: (1).algo(),\n  })\n  \n  // Receiver opts into the asset\n  await algorand.send.assetOptIn({\n    sender: receiver2.addr,\n    assetId: assetId,\n  })\n  console.log(`\u2713 Receiver ${receiver2.addr} opted into asset ${assetId}`)\n\n  try {\n    // Attempt to transfer from non-opted-in sender\n    // This will fail because the sender must also be opted in\n    await algorand.send.assetTransfer({\n      sender: sender2.addr,\n      receiver: receiver2.addr,\n      assetId: assetId,\n      amount: 1n,\n    })\n    \n    console.log('\u274c Transfer should have failed but succeeded')\n  } catch (e: unknown) {\n    // This error is expected - sender must own/be opted into the asset\n    const error = e as Error\n    console.log(`\u2713 Error caught as expected: ${error.name}`)\n    console.log(`\u2713 Error message: ${error.message.substring(0, 100)}...`)\n    \n    if (error.message.includes('sender error: must optin')) {\n      console.log('\u2713 Confirmed: Sender must opt-in to the asset they are transferring')\n    }\n  }\n  console.log()\n\n  // ========================================\n  // Example 3: Transfer non-existent asset\n  // ========================================\n  console.log('--- Example 3: Transfer Non-Existent Asset ---')\n  \n  // Create sender and receiver accounts\n  const sender3 = algorand.account.random()\n  const receiver3 = algorand.account.random()\n  \n  // Fund both accounts\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: sender3.addr,\n    amount: (1).algo(),\n  })\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: receiver3.addr,\n    amount: (1).algo(),\n  })\n  console.log('Sender and receiver accounts created and funded')\n\n  try {\n    // Attempt to transfer an asset that doesn't exist (asset ID 1)\n    // This will fail because the asset ID is invalid\n    await algorand.send.assetTransfer({\n      sender: sender3.addr,\n      receiver: receiver3.addr,\n      assetId: 1n,\n      amount: 5n,\n    })\n    \n    console.log('\u274c Transfer should have failed but succeeded')\n  } catch (e: unknown) {\n    // This error is expected - asset doesn't exist\n    const error = e as Error\n    console.log(`\u2713 Error caught as expected: ${error.name}`)\n    console.log(`\u2713 Error message: ${error.message.substring(0, 100)}...`)\n    \n    if (error.message.includes('asset 1 missing from')) {\n      console.log('\u2713 Confirmed: Cannot transfer non-existent assets')\n    }\n  }\n  console.log()\n\n  // ========================================\n  // Summary\n  // ========================================\n  console.log('=== Summary ===')\n  console.log('This example demonstrated three common ASA transfer errors:')\n  console.log('1. Receiver must opt-in before receiving assets')\n  console.log('2. Sender must opt-in to assets they want to transfer')\n  console.log('3. Asset ID must reference an existing asset')\n  console.log()\n  console.log('Key Takeaways:')\n  console.log('- Always ensure both sender and receiver are opted into the asset')\n  console.log('- Validate asset IDs before attempting transfers')\n  console.log('- Implement proper error handling in production code')\n  console.log('- Use try-catch blocks to gracefully handle transfer failures')\n}\n\nmain()\n  .then(() => {\n    console.log('\\n\u2713 All error handling examples completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Unexpected error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "03-application-call-argument-validation",
      "title": "Application Call Argument Validation",
      "summary": "Shows how the SDK validates argument counts and provides helpful error messages when calling application methods with incorrect number of arguments.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Validate that calling a method with too many arguments throws an error",
      "target_users": [
        "SDK developers"
      ],
      "features_tested": [
        "appClient.send.call",
        "argument validation",
        "error handling"
      ],
      "feature_tags": [
        "error-handling",
        "argument-validation",
        "type-safety",
        "app-client",
        "method-calls"
      ],
      "folder": "03-application-call-argument-validation",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded account configured"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "Error caught with message: 'Unexpected arg at position 1. call_abi only expects 1 args'",
        "Argument validation confirmed working"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Call app too many args"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Standard TypeScript project configuration"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript compiler configuration"
        },
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Application specification with call_abi method"
        }
      ],
      "notes": "This example requires a smart contract with a call_abi method that accepts 1 argument. You'll need to replace the app factory initialization with your actual app spec.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { consoleLogger } from '@algorandfoundation/algokit-utils/types/logging'\n\n/**\n * This example demonstrates how the AlgoKit TypeScript SDK validates\n * argument counts when calling application methods.\n * \n * The SDK will throw a helpful error if you provide too many or too few\n * arguments to a method, helping catch bugs at runtime.\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get a funded test account\n  const sender = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Using account:', sender.addr)\n\n  // Create an app factory (assuming you have an app spec)\n  // Replace this with your actual app factory initialization\n  const factory = algorand.client.getTypedAppFactory(/* Your app spec here */)\n\n  // Deploy the application with deployment parameters\n  console.log('\\nDeploying application...')\n  const { appClient } = await factory.send.bare.create({\n    deployTimeParams: {\n      UPDATABLE: 0,\n      DELETABLE: 0,\n      VALUE: 1,\n    },\n  })\n  console.log('Application deployed with ID:', appClient.appId)\n\n  // Attempt to call a method with too many arguments\n  // This demonstrates the SDK's argument validation\n  console.log('\\nAttempting to call method with incorrect number of arguments...')\n  \n  try {\n    // call_abi expects only 1 argument, but we're providing 2\n    await appClient.send.call({\n      method: 'call_abi',\n      args: ['test', 'extra'], // Extra argument here!\n    })\n    console.log('ERROR: Should have thrown an error!')\n  } catch (error) {\n    // The SDK validates arguments and provides a helpful error message\n    console.log('\u2713 Caught expected error:')\n    console.log('  ', (error as Error).message)\n    // Expected: \"Unexpected arg at position 1. call_abi only expects 1 args\"\n  }\n\n  console.log('\\n\u2713 Argument validation works correctly!')\n  console.log('The SDK helps prevent bugs by validating argument counts.')\n}\n\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "04-application-deployment-validation-and-error-handling",
      "title": "Application Deployment Validation and Error Handling",
      "summary": "Demonstrates the validation errors that occur during app deployment when required template variables (TMPL_UPDATABLE and TMPL_DELETABLE) are missing from TEAL code, showing proper error handling for deploy-time controls.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Handle deployment errors when template variables are missing from smart contract code",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "deployment validation",
        "template variables",
        "error handling"
      ],
      "feature_tags": [
        "error-handling",
        "template-variables",
        "deploy-time-controls",
        "updatability",
        "deletability",
        "validation",
        "smart-contracts"
      ],
      "folder": "04-application-deployment-validation-and-error-handling",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Testing deployment validation...",
        "\u274c Expected error for missing TMPL_UPDATABLE: Deploy-time updatability control requested...",
        "\u274c Expected error for missing TMPL_DELETABLE: Deploy-time deletability control requested...",
        "\u2705 All validation errors caught correctly"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Fail to deploy immutable app without TMPL_UPDATABLE"
        },
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Fail to deploy permanent app without TMPL_DELETABLE"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval-with-templates.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "TEAL program with TMPL_UPDATABLE and TMPL_DELETABLE template variables"
        },
        {
          "target_file": "approval-without-templates.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "TEAL program without template variables to trigger errors"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample TEAL clear state program"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "NPM package configuration with required dependencies"
        }
      ],
      "notes": "This example shows the importance of including TMPL_UPDATABLE and TMPL_DELETABLE template variables when using deploy-time controls. The SDK validates that these template variables exist in the TEAL code before deployment.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\n/**\n * This example demonstrates the validation that occurs during app deployment\n * when deploy-time controls (updatability/deletability) are requested but the\n * required template variables are missing from the TEAL code.\n * \n * TMPL_UPDATABLE: Required when metadata.updatable is set\n * TMPL_DELETABLE: Required when metadata.deletable is set\n * \n * These template variables allow the deployer to set updatability and deletability\n * at deploy-time rather than hardcoding them in the TEAL contract.\n */\nasync function demonstrateValidationErrors() {\n  console.log('Application Deployment Validation Example')\n  console.log('==========================================')\n\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a test account with funds from the LocalNet dispenser\n  const deployer = await algorand.account.localNet.dispenser()\n  console.log('\\nDeployer account:', deployer.addr)\n\n  // Read the clear state program (used for both examples)\n  const clearProgram = fs.readFileSync(\n    path.join(__dirname, 'clear.teal'),\n    'utf8'\n  )\n  const clearCompiled = await algorand.client.algod.compile(clearProgram).do()\n\n  // Example 1: Missing TMPL_UPDATABLE\n  console.log('\\n--- Example 1: Missing TMPL_UPDATABLE ---')\n  try {\n    // This approval program does NOT contain TMPL_UPDATABLE\n    const approvalWithoutUpdatable = `#pragma version 8\n// This contract is missing TMPL_UPDATABLE template variable\nint 1\nreturn`\n\n    const approvalCompiled = await algorand.client.algod.compile(approvalWithoutUpdatable).do()\n\n    const deploymentWithoutUpdatable = {\n      sender: deployer.addr,\n      metadata: {\n        name: 'AppWithoutUpdatable',\n        version: '1.0.0',\n        updatable: true,  // \u274c Requesting updatability but TMPL_UPDATABLE is missing!\n        deletable: false,\n      },\n      createParams: {\n        approvalProgram: new Uint8Array(Buffer.from(approvalCompiled.result, 'base64')),\n        clearStateProgram: new Uint8Array(Buffer.from(clearCompiled.result, 'base64')),\n        globalNumUint: 1,\n        globalNumByteSlice: 1,\n        localNumUint: 0,\n        localNumByteSlice: 0,\n      },\n      deployTimeParams: {\n        TMPL_UPDATABLE: 1,\n      },\n    }\n\n    console.log('Attempting to deploy with updatable=true but no TMPL_UPDATABLE in code...')\n    await algorand.appDeployer.deploy(deploymentWithoutUpdatable)\n    \n    console.log('\u274c ERROR: Should have thrown an error!')\n  } catch (error) {\n    if (error instanceof Error) {\n      console.log('\u2705 Caught expected error:')\n      console.log('   Message:', error.message)\n      if (error.message.includes('TMPL_UPDATABLE')) {\n        console.log('   \u2713 Error correctly identifies missing TMPL_UPDATABLE')\n      }\n    }\n  }\n\n  // Example 2: Missing TMPL_DELETABLE\n  console.log('\\n--- Example 2: Missing TMPL_DELETABLE ---')\n  try {\n    // This approval program does NOT contain TMPL_DELETABLE\n    const approvalWithoutDeletable = `#pragma version 8\n// This contract is missing TMPL_DELETABLE template variable\nint 1\nreturn`\n\n    const approvalCompiled = await algorand.client.algod.compile(approvalWithoutDeletable).do()\n\n    const deploymentWithoutDeletable = {\n      sender: deployer.addr,\n      metadata: {\n        name: 'AppWithoutDeletable',\n        version: '1.0.0',\n        updatable: false,\n        deletable: true,  // \u274c Requesting deletability but TMPL_DELETABLE is missing!\n      },\n      createParams: {\n        approvalProgram: new Uint8Array(Buffer.from(approvalCompiled.result, 'base64')),\n        clearStateProgram: new Uint8Array(Buffer.from(clearCompiled.result, 'base64')),\n        globalNumUint: 1,\n        globalNumByteSlice: 1,\n        localNumUint: 0,\n        localNumByteSlice: 0,\n      },\n      deployTimeParams: {\n        TMPL_DELETABLE: 1,\n      },\n    }\n\n    console.log('Attempting to deploy with deletable=true but no TMPL_DELETABLE in code...')\n    await algorand.appDeployer.deploy(deploymentWithoutDeletable)\n    \n    console.log('\u274c ERROR: Should have thrown an error!')\n  } catch (error) {\n    if (error instanceof Error) {\n      console.log('\u2705 Caught expected error:')\n      console.log('   Message:', error.message)\n      if (error.message.includes('TMPL_DELETABLE')) {\n        console.log('   \u2713 Error correctly identifies missing TMPL_DELETABLE')\n      }\n    }\n  }\n\n  // Example 3: Correct usage with template variables\n  console.log('\\n--- Example 3: Correct Usage with Template Variables ---')\n  try {\n    // This approval program INCLUDES both template variables\n    const approvalWithTemplates = `#pragma version 8\n// This contract includes both template variables\ntxn ApplicationID\nint 0\n==\nbnz create\n\ntxn OnCompletion\nint UpdateApplication\n==\nbnz update\n\ntxn OnCompletion\nint DeleteApplication\n==\nbnz delete\n\nint 1\nreturn\n\ncreate:\nint 1\nreturn\n\nupdate:\nint TMPL_UPDATABLE  // Template variable for updatability\nreturn\n\ndelete:\nint TMPL_DELETABLE  // Template variable for deletability\nreturn`\n\n    const approvalCompiled = await algorand.client.algod.compile(approvalWithTemplates).do()\n\n    const correctDeployment = {\n      sender: deployer.addr,\n      metadata: {\n        name: 'CorrectApp',\n        version: '1.0.0',\n        updatable: true,\n        deletable: true,\n      },\n      createParams: {\n        approvalProgram: new Uint8Array(Buffer.from(approvalCompiled.result, 'base64')),\n        clearStateProgram: new Uint8Array(Buffer.from(clearCompiled.result, 'base64')),\n        globalNumUint: 1,\n        globalNumByteSlice: 1,\n        localNumUint: 0,\n        localNumByteSlice: 0,\n      },\n      deployTimeParams: {\n        TMPL_UPDATABLE: 1,\n        TMPL_DELETABLE: 1,\n      },\n    }\n\n    console.log('Deploying with proper template variables...')\n    const result = await algorand.appDeployer.deploy(correctDeployment)\n    console.log('\u2705 Deployment successful!')\n    console.log('   App ID:', result.appId.toString())\n    console.log('   Updatable:', result.updatable)\n    console.log('   Deletable:', result.deletable)\n  } catch (error) {\n    console.error('\u274c Unexpected error:', error)\n  }\n\n  console.log('\\n==========================================')\n  console.log('Key Takeaways:')\n  console.log('1. Include TMPL_UPDATABLE when metadata.updatable is true')\n  console.log('2. Include TMPL_DELETABLE when metadata.deletable is true')\n  console.log('3. The SDK validates template variables before deployment')\n  console.log('4. Template variables enable deploy-time control configuration')\n}\n\n// Run the example\ndemonstrateValidationErrors()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Example failed:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "05-asset-opt-in---creating-and-opting-into-an-asa",
      "title": "Asset Opt-In - Creating and Opting Into an ASA",
      "summary": "Demonstrates how to create an Algorand Standard Asset (ASA) and opt an account into holding that asset. Asset opt-in is required before an account can receive or hold any ASA.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Create an asset and opt an account into holding that asset",
      "target_users": [
        "SDK developers",
        "dApp developers",
        "Token creators"
      ],
      "features_tested": [
        "algorand.send.assetCreate",
        "algorand.send.assetOptIn",
        "algod.accountAssetInformation"
      ],
      "feature_tags": [
        "asset-opt-in",
        "asset-creation",
        "asa-management",
        "algorand-standard-assets",
        "token-creation"
      ],
      "folder": "05-asset-opt-in---creating-and-opting-into-an-asa",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALICE_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created with ID",
        "Account successfully opted into asset",
        "Asset Information displaying asset ID, balance, and frozen status"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "assetOptIn"
        }
      ],
      "artifacts_plan": [],
      "notes": "In this example, alice is both the creator and the account opting in. In real-world scenarios, you would typically have different accounts where the creator distributes the asset to other accounts after they opt in.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to create an Algorand Standard Asset (ASA)\n * and opt an account into holding that asset.\n * \n * Asset opt-in is a required step before an account can receive or hold any ASA.\n * This is a security feature to prevent unwanted assets from being sent to accounts.\n */\nasync function assetOptInExample() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a funded account (in LocalNet, this gets a pre-funded test account)\n  const alice = await algorand.account.fromEnvironment('ALICE')\n  \n  console.log('Creating a new Algorand Standard Asset (ASA)...')\n  \n  // Step 1: Create a new asset\n  // The creator account (alice) automatically opts in during creation\n  const assetCreateResult = await algorand.send.assetCreate({\n    sender: alice,\n    total: 1n, // Total supply of 1 unit\n  })\n  \n  const assetId = assetCreateResult.assetId\n  console.log(`\u2713 Asset created with ID: ${assetId}`)\n  \n  // Step 2: Opt the account into the asset\n  // Note: In this example, alice is both the creator and the opt-in account\n  // The creator is automatically opted in, but this demonstrates the explicit opt-in process\n  console.log('\\nOpting account into the asset...')\n  \n  await algorand.send.assetOptIn({\n    sender: alice,\n    assetId: assetId,\n  })\n  \n  console.log(`\u2713 Account ${alice.addr} successfully opted into asset ${assetId}`)\n  \n  // Step 3: Verify the opt-in by checking account asset information\n  const algod = algorand.client.algod\n  const assetInfo = await algod.accountAssetInformation(alice.addr, Number(assetId)).do()\n  \n  console.log('\\nAsset Information:')\n  console.log(`  Asset ID: ${assetInfo['asset-id']}`)\n  console.log(`  Balance: ${assetInfo['amount']}`)\n  console.log(`  Is Frozen: ${assetInfo['is-frozen']}`)\n  \n  console.log('\\n\u2713 Asset opt-in completed successfully!')\n}\n\n// Run the example\nassetOptInExample().catch(console.error)"
    },
    {
      "example_id": "06-asset-opt-in-single-asset",
      "title": "Asset Opt-In Single Asset",
      "summary": "Shows how to opt an account into an asset, which is required before an account can hold that asset. Verifies the account state before and after opt-in.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Opt-in a single asset to an account using bulk opt-in method",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.asset.bulkOptIn",
        "algorand.account.getInformation",
        "asset creation"
      ],
      "feature_tags": [
        "asset-opt-in",
        "asset-management",
        "account-state",
        "bulk-operations"
      ],
      "folder": "06-asset-opt-in-single-asset",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created with ID: [asset_id]",
        "Account assets opted in before: 0",
        "Successfully opted into asset [asset_id]",
        "Account assets opted in after: 1"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptIn an asset to an account succeed"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the fundamental asset opt-in operation. On Algorand, accounts must explicitly opt into assets before they can receive them.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to opt an account into an asset.\n * On Algorand, accounts must opt-in to assets before they can hold them.\n */\nasync function optInToAsset() {\n  // Initialize Algorand client for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get default accounts from LocalNet\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  const creator = await algorand.account.fromEnvironment('DISPENSER')\n\n  // Create a new account that will opt into the asset\n  const account = algorand.account.random()\n  \n  // Fund the new account (minimum balance required for transactions)\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: account.addr,\n    amount: algosdk.algos(1),\n  })\n\n  // Step 1: Create a test asset\n  console.log('Creating test asset...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: creator.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Test Asset',\n  })\n  const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n  console.log(`Asset created with ID: ${assetId}`)\n\n  // Step 2: Check account info before opt-in\n  const accountInfoBefore = await algorand.account.getInformation(account.addr)\n  console.log(`Account assets opted in before: ${accountInfoBefore.totalAssetsOptedIn}`)\n\n  // Step 3: Opt the account into the asset\n  console.log(`\\nOpting account into asset ${assetId}...`)\n  await algorand.asset.bulkOptIn(account, [assetId], { validityWindow: 100 })\n  console.log(`Successfully opted into asset ${assetId}`)\n\n  // Step 4: Verify the opt-in was successful\n  const accountInfoAfter = await algorand.account.getInformation(account.addr)\n  console.log(`Account assets opted in after: ${accountInfoAfter.totalAssetsOptedIn}`)\n\n  if (accountInfoAfter.totalAssetsOptedIn === 1) {\n    console.log('\\n\u2705 Asset opt-in successful!')\n  } else {\n    console.log('\\n\u274c Asset opt-in failed')\n  }\n}\n\n// Run the example\noptInToAsset().catch(console.error)\n"
    },
    {
      "example_id": "07-automated-account-funding-using-environment-dispenser",
      "title": "Automated Account Funding Using Environment Dispenser",
      "summary": "Demonstrates how to use the environment-configured dispenser account to automatically fund accounts, useful for testing and development workflows",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Use the environment-configured dispenser account to automatically fund accounts",
      "target_users": [
        "SDK developers",
        "Application developers",
        "DevOps engineers",
        "Testing engineers"
      ],
      "features_tested": [
        "algorand.account.ensureFundedFromEnvironment",
        "algorand.account.dispenserFromEnvironment"
      ],
      "feature_tags": [
        "account-funding",
        "dispenser-account",
        "environment-configuration",
        "automated-funding",
        "testing",
        "development-workflow"
      ],
      "folder": "07-automated-account-funding-using-environment-dispenser",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "tsx"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "DISPENSER_MNEMONIC",
            "required": false,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "The dispenser account is automatically configured in LocalNet"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils typescript tsx"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Dispenser account address displayed",
        "New random account created and funded",
        "Transaction confirmed with transaction ID",
        "Account balance shows 1 ALGO",
        "Confirmation that funds came from the dispenser account"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "ensureFunded uses dispenser account by default"
        }
      ],
      "artifacts_plan": [],
      "notes": "This pattern is extremely useful for testing and CI/CD pipelines where you need automated account funding without manual intervention. The dispenser pattern abstracts away the funding source configuration.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgo, algo } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use the dispenser pattern for automated\n * account funding in development and testing environments.\n * \n * The dispenser account is configured through environment variables,\n * making it easy to fund accounts without manually specifying the funding source.\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  console.log('=== Automated Account Funding with Dispenser ====')\n\n  /**\n   * Get the dispenser account from environment\n   * \n   * By default in LocalNet, this uses the default dispenser account\n   * configured in the environment (typically the default LocalNet account)\n   */\n  console.log('\\n1. Getting dispenser account from environment...')\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  console.log(`Dispenser address: ${dispenser.addr}`)\n\n  /**\n   * Create a new random account to fund\n   */\n  console.log('\\n2. Creating a new random account...')\n  const newAccount = algorand.account.random()\n  console.log(`New account address: ${newAccount.addr}`)\n\n  /**\n   * Fund the account using ensureFundedFromEnvironment\n   * \n   * This method automatically uses the dispenser account from the environment,\n   * so you don't need to explicitly specify the funding source.\n   * \n   * Parameters:\n   * - Account to fund\n   * - Minimum balance required (1 microAlgo)\n   * - Options: minFundingIncrement set to 1 ALGO\n   */\n  console.log('\\n3. Funding account using environment dispenser...')\n  console.log('   Minimum balance: 1 microAlgo')\n  console.log('   Minimum funding increment: 1 ALGO')\n  \n  const result = await algorand.account.ensureFundedFromEnvironment(\n    newAccount.addr,\n    microAlgo(1),\n    {\n      minFundingIncrement: algo(1),\n    }\n  )\n\n  if (result) {\n    console.log('\\n\u2705 Funding successful!')\n    console.log(`   Transaction ID: ${result.confirmation.txId}`)\n    console.log(`   Amount funded: ${result.amountFunded.algo} ALGO`)\n    \n    // Verify the sender was the dispenser account\n    const sender = result.confirmation.txn.txn.sender\n    console.log(`   Funded from: ${sender.toString()}`)\n    console.log(`   Dispenser confirmed: ${sender.toString() === dispenser.addr}`)\n  }\n\n  /**\n   * Check the final balance of the newly funded account\n   */\n  console.log('\\n4. Verifying account balance...')\n  const accountInfo = await algorand.account.getInformation(newAccount.addr)\n  console.log(`   Final balance: ${accountInfo.balance.algo} ALGO (${accountInfo.balance.microAlgo} microAlgos)`)\n\n  console.log('\\n\ud83d\udcdd Key Takeaways:')\n  console.log('   \u2022 ensureFundedFromEnvironment automatically uses the configured dispenser')\n  console.log('   \u2022 No need to manually manage funding source accounts')\n  console.log('   \u2022 Perfect for automated testing and development workflows')\n  console.log('   \u2022 Works seamlessly with LocalNet, TestNet, and custom configurations')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "08-automatically-fund-new-accounts",
      "title": "Automatically Fund New Accounts",
      "summary": "Demonstrates how to automatically fund a new account with the proper minimum balance, essential for application onboarding and account management.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Automatically fund a new account with the minimum balance required",
      "target_users": [
        "SDK developers",
        "Application developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.account.ensureFunded",
        "algorand.account.getInformation",
        "algorand.account.random"
      ],
      "feature_tags": [
        "account-funding",
        "minimum-balance",
        "account-creation",
        "account-management",
        "onboarding"
      ],
      "folder": "08-automatically-fund-new-accounts",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Funding source (dispenser) ready",
        "New account created: <account_address>",
        "Account does not yet exist on the blockchain",
        "Funding new account...",
        "Funding completed!",
        "Transaction ID: <transaction_id>",
        "Amount funded: 100001 microAlgos",
        "Note: Amount funded includes minimum balance requirement (100,000 microAlgos)",
        "Account information:",
        "  Address: <account_address>",
        "  Balance: 100001 microAlgos",
        "  Balance: 0.100001 ALGO",
        "  Minimum balance: 100000 microAlgos",
        "  Amount: 100001 microAlgos (raw)",
        "\u2705 Account funded successfully!",
        "   - Requested: 1 microAlgo",
        "   - Minimum balance: 100,000 microAlgos",
        "   - Total funded: 100001 microAlgos",
        "Attempting to fund again with same amount...",
        "\u2705 No additional funding needed - account already has sufficient balance",
        "Funding account with additional 1 ALGO...",
        "Additional funding sent: <amount> ALGO",
        "New balance: <updated_balance> ALGO"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "ensureFunded is sent and waited for with correct amount for new account"
        }
      ],
      "artifacts_plan": [],
      "notes": "The ensureFunded method is intelligent and will only send funds if the account needs them. It automatically accounts for the minimum balance requirement (100,000 microAlgos) on Algorand. This is essential for smooth user onboarding in applications.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Example: Automatically Fund New Accounts\n * \n * This example demonstrates:\n * 1. Creating a new random account\n * 2. Using ensureFunded to automatically fund the account\n * 3. Understanding minimum balance requirements\n * 4. Retrieving and verifying account information\n * \n * The ensureFunded method intelligently handles:\n * - Checking if an account exists\n * - Calculating required funding including minimum balance\n * - Only sending funds if needed\n */\n\nasync function ensureFundedExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a dispenser account with funds (funding source)\n  const dispenser = await algorand.account.localNetDispenser()\n  console.log('Funding source (dispenser) ready')\n  \n  // Create a new random account (not yet funded)\n  const newAccount = algorand.account.random()\n  console.log(`\\nNew account created: ${newAccount.addr}`)\n  console.log('Account does not yet exist on the blockchain')\n  \n  // Use ensureFunded to automatically fund the account\n  // This will:\n  // 1. Check if the account exists\n  // 2. Determine how much funding is needed\n  // 3. Send the appropriate amount (including minimum balance)\n  console.log('\\nFunding new account...')\n  const fundingResult = await algorand.account.ensureFunded(\n    newAccount,           // Account to fund\n    dispenser,            // Funding source\n    algosdk.microAlgos(1) // Requested amount: 1 microAlgo\n  )\n  \n  // Display funding details\n  if (fundingResult) {\n    console.log('\\nFunding completed!')\n    console.log(`Transaction ID: ${fundingResult.transactionId}`)\n    console.log(`Amount funded: ${fundingResult.amountFunded.microAlgo} microAlgos`)\n    console.log(`\\nNote: Amount funded includes minimum balance requirement (100,000 microAlgos)`)\n  }\n  \n  // Retrieve and display account information\n  const accountInfo = await algorand.account.getInformation(newAccount)\n  console.log('\\nAccount information:')\n  console.log(`  Address: ${accountInfo.address}`)\n  console.log(`  Balance: ${accountInfo.balance.microAlgo} microAlgos`)\n  console.log(`  Balance: ${accountInfo.balance.algo} ALGO`)\n  console.log(`  Minimum balance: ${accountInfo.minBalance.microAlgo} microAlgos`)\n  console.log(`  Amount: ${accountInfo.amount} microAlgos (raw)`)\n  \n  // Verify the funding was successful\n  const expectedAmount = 100_001n // 1 microAlgo + 100,000 minimum balance\n  if (accountInfo.balance.microAlgo === expectedAmount) {\n    console.log('\\n\u2705 Account funded successfully!')\n    console.log(`   - Requested: 1 microAlgo`)\n    console.log(`   - Minimum balance: 100,000 microAlgos`)\n    console.log(`   - Total funded: ${expectedAmount} microAlgos`)\n  }\n  \n  // Try funding again - ensureFunded will detect account already has sufficient funds\n  console.log('\\nAttempting to fund again with same amount...')\n  const secondFundingResult = await algorand.account.ensureFunded(\n    newAccount,\n    dispenser,\n    algosdk.microAlgos(1)\n  )\n  \n  if (!secondFundingResult) {\n    console.log('\u2705 No additional funding needed - account already has sufficient balance')\n  }\n  \n  // Example: Fund with a larger amount\n  console.log('\\nFunding account with additional 1 ALGO...')\n  const additionalFunding = await algorand.account.ensureFunded(\n    newAccount,\n    dispenser,\n    algosdk.algos(1.1) // Request 1.1 ALGO total\n  )\n  \n  if (additionalFunding) {\n    console.log(`Additional funding sent: ${additionalFunding.amountFunded.algo} ALGO`)\n    const updatedInfo = await algorand.account.getInformation(newAccount)\n    console.log(`New balance: ${updatedInfo.balance.algo} ALGO`)\n  }\n}\n\n// Run the example\nensureFundedExample().catch(console.error)"
    },
    {
      "example_id": "09-calculate-transaction-fees",
      "title": "Calculate Transaction Fees",
      "summary": "Learn how to calculate standard Algorand transaction fees for single and multiple transactions using the transactionFees() helper function.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Calculate transaction fees for budgeting and fee estimation in atomic transaction groups",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "transactionFees",
        "AlgoAmount.microAlgo"
      ],
      "feature_tags": [
        "transaction-fees",
        "fee-calculation",
        "algo-amount",
        "atomic-transfers",
        "transaction-management"
      ],
      "folder": "09-calculate-transaction-fees",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Create a new TypeScript project or use an existing one"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk",
          "npm install -D typescript ts-node @types/node"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Single transaction fee: 1000n microAlgos",
        "Single transaction fee: 0.001 Algos",
        "Fee for 10 transactions: 10000n microAlgos",
        "Fee for 10 transactions: 0.01 Algos",
        "Total fees for atomic group of 3 transactions: 3000n microAlgos",
        "Estimated cost for 5 transactions: 0.005 Algos"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "single transaction fee"
        },
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "multiple transaction fees"
        }
      ],
      "artifacts_plan": [],
      "notes": "The transactionFees() function applies the standard Algorand fee rate of 1000 microAlgos per transaction. This is particularly useful for atomic transaction groups where you need to budget for multiple transaction fees.",
      "generated_code": "import { transactionFees } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to calculate transaction fees on Algorand.\n * \n * Algorand uses a flat fee structure where each transaction costs 1000 microAlgos (0.001 Algo).\n * When working with atomic transaction groups, you need to budget for multiple transaction fees.\n */\n\n// Calculate the fee for a single transaction\n// The standard Algorand fee is 1000 microAlgos per transaction\nconst singleTxFee = transactionFees(1)\nconsole.log('Single transaction fee:', singleTxFee.microAlgo, 'microAlgos')\nconsole.log('Single transaction fee:', singleTxFee.algo, 'Algos')\n\n// Calculate fees for multiple transactions\n// This is useful when creating atomic transaction groups\nconst tenTxFees = transactionFees(10)\nconsole.log('\\nFee for 10 transactions:', tenTxFees.microAlgo, 'microAlgos')\nconsole.log('Fee for 10 transactions:', tenTxFees.algo, 'Algos')\n\n// Example: Budgeting for an atomic transfer with 3 transactions\nconst atomicGroupSize = 3\nconst totalFees = transactionFees(atomicGroupSize)\nconsole.log(`\\nTotal fees for atomic group of ${atomicGroupSize} transactions:`, totalFees.microAlgo, 'microAlgos')\n\n// You can use this for fee estimation before submitting transactions\nconst estimatedTransactions = 5\nconst estimatedCost = transactionFees(estimatedTransactions)\nconsole.log(`\\nEstimated cost for ${estimatedTransactions} transactions:`, estimatedCost.algo, 'Algos')"
    },
    {
      "example_id": "10-call-abi-methods-with-default-arguments",
      "title": "Call ABI Methods with Default Arguments",
      "summary": "Demonstrates how to call ABI methods that have default arguments. Shows two scenarios: default values from constants and default values computed from other ABI methods. When arguments are omitted, the smart contract uses the predefined default values.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "ABI method calls",
      "specific_use_case": "Call ABI methods with default argument values from constants or other methods",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ABI default arguments",
        "default value from constant",
        "default value from ABI method"
      ],
      "feature_tags": [
        "abi",
        "default-arguments",
        "method-calls",
        "app-client",
        "typed-client",
        "smart-contracts"
      ],
      "folder": "10-call-abi-methods-with-default-arguments",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have a deployed smart contract with ABI methods that have default arguments"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Method called with explicit argument returns the provided value",
        "Method called without argument returns the default value",
        "Demonstrates both constant defaults and method-computed defaults"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "from const"
        },
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "from abi method"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "default_args_contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample smart contract with ABI methods that have default arguments"
        }
      ],
      "notes": "This example demonstrates ARC-4 ABI default arguments feature. The smart contract must implement methods with default argument specifications in the ABI.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to call ABI methods that have default arguments.\n * \n * Default arguments allow smart contract methods to provide fallback values when\n * arguments are not explicitly provided by the caller. This feature is part of ARC-4.\n * \n * Two scenarios are shown:\n * 1. Default value from a constant (defined in the contract)\n * 2. Default value from another ABI method (computed dynamically)\n * \n * Prerequisites:\n * - AlgoKit installed and LocalNet running\n * - A deployed smart contract with ABI methods that have default arguments\n */\n\nasync function demonstrateAbiDefaultArguments() {\n  // Initialize AlgorandClient to connect to LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n\n  // Get a test account with funds\n  const testAccount = await algorand.account.localNetDispenser()\n\n  console.log('Deploying smart contract with ABI default arguments...')\n  // Note: Replace this with your actual contract deployment\n  // const { client } = await deploy(testAccount, algod, indexer)\n  // For this example, assume 'client' is your typed application client\n\n  // ==========================================\n  // SCENARIO 1: Default Value from Constant\n  // ==========================================\n  console.log('\\n=== Default Value from Constant ===')\n  console.log('Method signature: default_value(string)string')\n  \n  // Call the method WITH an explicit argument\n  const result1 = await client.call({\n    method: 'default_value',\n    methodArgs: ['defined value'],\n  })\n  console.log('Called with explicit argument \"defined value\"')\n  console.log('Result:', result1.return) // Expected: 'defined value'\n  \n  // Call the method WITHOUT an argument (uses default)\n  const result2 = await client.call({\n    method: 'default_value',\n    methodArgs: [], // Omit the argument to use default\n  })\n  console.log('\\nCalled without argument (using default)')\n  console.log('Result:', result2.return) // Expected: 'default value'\n  console.log('The contract used its predefined constant default value')\n\n  // ==========================================\n  // SCENARIO 2: Default Value from ABI Method\n  // ==========================================\n  console.log('\\n=== Default Value from ABI Method ===')\n  console.log('Method signature: default_value_from_abi(string)string')\n  console.log('The default value is computed by calling another ABI method')\n  \n  // Call the method WITH an explicit argument\n  const result3 = await client.call({\n    method: 'default_value_from_abi',\n    methodArgs: ['defined value'],\n  })\n  console.log('\\nCalled with explicit argument \"defined value\"')\n  console.log('Result:', result3.return) // Expected: 'ABI, defined value'\n  \n  // Call the method WITHOUT an argument (uses default from ABI method)\n  const result4 = await client.call({\n    method: 'default_value_from_abi',\n    methodArgs: [], // Omit the argument to use default\n  })\n  console.log('\\nCalled without argument (using default from ABI method)')\n  console.log('Result:', result4.return) // Expected: 'ABI, default value'\n  console.log('The contract computed the default by calling another method')\n\n  // ==========================================\n  // SUMMARY\n  // ==========================================\n  console.log('\\n=== Summary ===')\n  console.log('\u2705 Constant default: Method uses a hardcoded default value')\n  console.log('\u2705 Method default: Method computes default by calling another method')\n  console.log('\u2705 This reduces transaction complexity and improves UX')\n  console.log('\\nBenefits of default arguments:')\n  console.log('- Simpler API for common use cases')\n  console.log('- Backward compatibility when adding new parameters')\n  console.log('- Reduced transaction data when defaults are acceptable')\n}\n\n// Run the example\ndemonstrateAbiDefaultArguments().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})\n"
    },
    {
      "example_id": "11-clone-app-client-with-custom-name",
      "title": "Clone App Client with Custom Name",
      "summary": "Demonstrates how to clone an app client with a different app name while maintaining the same app ID. Useful for managing multiple references to the same application with different configurations.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "client management",
      "specific_use_case": "Clone an app client with a different app name",
      "target_users": [
        "SDK developers"
      ],
      "features_tested": [
        "appClient.clone",
        "appName override"
      ],
      "feature_tags": [
        "app-client",
        "clone",
        "client-management",
        "configuration"
      ],
      "folder": "11-clone-app-client-with-custom-name",
      "prerequisites": {
        "tools": [
          "algokit",
          "node"
        ],
        "libraries": [
          "@algorand/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorand/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App deployed with ID",
        "Original app name: original",
        "Cloned app name: cloned",
        "App IDs match: true",
        "Names are different: true"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "clone overriding appName"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the basic pattern for cloning app clients. In real-world scenarios, you might want to clone clients to use different signers, different default parameters, or different naming conventions for the same underlying application.",
      "generated_code": "import { AlgorandClient } from '@algorand/algokit-utils';\nimport { algorandFixture } from '@algorand/algokit-utils/testing';\n\n/**\n * This example demonstrates how to clone an app client with a different name.\n * Cloning is useful when you want multiple references to the same app with different configurations.\n */\n\nasync function main() {\n  // Setup: Initialize Algorand client and get test account\n  const localnet = algorandFixture();\n  await localnet.beforeEach();\n  const { testAccount } = localnet.context;\n  const algorand = localnet.context.algorand;\n\n  console.log('=== Clone App Client Example ===\\n');\n\n  // Step 1: Deploy an app (you would replace this with your actual app deployment)\n  // For this example, we'll use a simple deployment\n  console.log('Step 1: Deploying application...');\n  const appClient = algorand.client.getAppClient({\n    appSpec: {\n      // Your app spec here - this is a placeholder\n      hints: {},\n      source: { approval: '', clear: '' },\n      state: { global: { num_byte_slices: 0, num_uints: 0 }, local: { num_byte_slices: 0, num_uints: 0 } },\n      schema: { global: { declared: {}, reserved: {} }, local: { declared: {}, reserved: {} } },\n      contract: { name: 'OriginalApp', methods: [] }\n    },\n    sender: testAccount,\n    appName: 'original'\n  });\n  \n  // Deploy the app\n  await appClient.deploy();\n  console.log(`App deployed with ID: ${appClient.appId}`);\n  console.log(`Original app name: ${appClient.appName}\\n`);\n\n  // Step 2: Clone the app client with a different name\n  console.log('Step 2: Cloning app client with new name...');\n  const clonedAppClient = appClient.clone({\n    appName: 'cloned',\n  });\n\n  // Step 3: Verify the clone maintains the same app ID but has a different name\n  console.log('\\n=== Results ===');\n  console.log(`Original App ID: ${appClient.appId}`);\n  console.log(`Cloned App ID: ${clonedAppClient.appId}`);\n  console.log(`App IDs match: ${clonedAppClient.appId === appClient.appId}`);\n  console.log(`\\nOriginal app name: ${appClient.appName}`);\n  console.log(`Cloned app name: ${clonedAppClient.appName}`);\n  console.log(`Names are different: ${clonedAppClient.appName !== appClient.appName}`);\n\n  console.log('\\n\u2705 Clone successful! Both clients reference the same app with different names.');\n\n  // Cleanup\n  await localnet.afterEach();\n}\n\nmain().catch(console.error);"
    },
    {
      "example_id": "12-clone-app-client-with-different-configuration",
      "title": "Clone App Client with Different Configuration",
      "summary": "Demonstrates how to clone an existing app client with different configuration settings, such as a different default sender, while inheriting properties like the app ID and app name. This is useful in multi-user scenarios where multiple accounts need to interact with the same application.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "client management",
      "specific_use_case": "Clone an app client with a different default sender while inheriting the app name",
      "target_users": [
        "SDK developers"
      ],
      "features_tested": [
        "appClient.clone",
        "defaultSender override",
        "appName inheritance",
        "multi-user scenarios"
      ],
      "feature_tags": [
        "app-client",
        "clone",
        "multi-user",
        "configuration",
        "sender",
        "client-management"
      ],
      "folder": "12-clone-app-client-with-different-configuration",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "App deployed successfully with custom name",
        "Second account created and funded",
        "Cloned client has same appId and appName as original",
        "Cloned client has different default sender",
        "Use case explanation for multi-user scenarios"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "clone overriding the defaultSender and inheriting appName"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "artifacts/TestingApp/",
          "type": "contract",
          "action": "copy",
          "source_path": "tests/example-contracts/testing-app/",
          "note": "TestingApp contract artifacts including client and approval/clear programs"
        }
      ],
      "notes": "This example showcases a practical pattern for managing multiple app client instances with different configurations. It's particularly valuable for developers building multi-user applications or comprehensive testing suites.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport * as algosdk from 'algosdk'\nimport { TestingAppClient } from './artifacts/TestingApp/client'\n\n/**\n * This example demonstrates how to clone an app client with different configuration.\n * \n * Cloning is useful when you need multiple app client instances for the same application\n * but with different settings (e.g., different default senders for multi-user scenarios).\n * The cloned client inherits properties like appId and appName from the original.\n */\n\nasync function main() {\n  // Setup: Initialize test environment\n  const localnet = await algorandFixture()\n  const { algod, indexer, testAccount } = localnet.context\n  \n  const algorand = AlgorandClient.fromClients({ algod, indexer })\n  algorand.setDefaultSigner(testAccount.signer)\n\n  console.log('--- Deploying Application ---')\n  \n  // Deploy the application with a custom app name\n  const appClient = algorand.client.getTypedAppClientById(TestingAppClient, {\n    id: 0,\n    defaultSender: testAccount.addr,\n    name: 'overridden', // Custom app name\n  })\n\n  await appClient.create({ method: 'create', methodArgs: [] })\n  \n  console.log(`\u2705 App deployed successfully!`)\n  console.log(`   App ID: ${appClient.appId}`)\n  console.log(`   App Name: ${appClient.appName}`)\n  console.log(`   Default Sender: ${testAccount.addr}\\n`)\n\n  // ===================================================================\n  // Create a second account that will interact with the same app\n  // ===================================================================\n  console.log('--- Creating Second Account ---')\n  \n  const testAccount2 = await localnet.context.generateAccount({\n    initialFunds: algokit.algo(0.1)\n  })\n  \n  console.log(`\u2705 Second account created: ${testAccount2.addr}\\n`)\n\n  // ===================================================================\n  // Clone the app client with a different default sender\n  // ===================================================================\n  console.log('--- Cloning App Client ---')\n  \n  const clonedAppClient = appClient.clone({\n    defaultSender: testAccount2.addr,\n  })\n  \n  console.log('\u2705 App client cloned successfully!\\n')\n\n  // ===================================================================\n  // Verify inherited and overridden properties\n  // ===================================================================\n  console.log('--- Verifying Client Properties ---\\n')\n  \n  // The cloned client should have the same appId\n  console.log('App IDs:')\n  console.log(`   Original: ${appClient.appId}`)\n  console.log(`   Cloned:   ${clonedAppClient.appId}`)\n  console.log(`   Match: ${appClient.appId === clonedAppClient.appId ? '\u2705' : '\u274c'}\\n`)\n\n  // The cloned client should inherit the app name\n  console.log('App Names:')\n  console.log(`   Original: ${appClient.appName}`)\n  console.log(`   Cloned:   ${clonedAppClient.appName}`)\n  console.log(`   Match: ${appClient.appName === clonedAppClient.appName ? '\u2705' : '\u274c'}\\n`)\n\n  // The cloned client should have a different default sender\n  console.log('Default Senders:')\n  \n  // Create a transaction using the original client\n  const originalTxn = await appClient.createTransaction.bare.call()\n  const originalSender = algosdk.encodeAddress(originalTxn.sender.publicKey)\n  console.log(`   Original: ${originalSender}`)\n  \n  // Create a transaction using the cloned client\n  algorand.setDefaultSigner(testAccount2.signer)\n  const clonedTxn = await clonedAppClient.createTransaction.bare.call()\n  const clonedSender = algosdk.encodeAddress(clonedTxn.sender.publicKey)\n  console.log(`   Cloned:   ${clonedSender}`)\n  console.log(`   Different: ${originalSender !== clonedSender ? '\u2705' : '\u274c'}\\n`)\n\n  // ===================================================================\n  // Use Case: Multi-User Interaction\n  // ===================================================================\n  console.log('--- Use Case: Multiple Users Interacting with Same App ---\\n')\n  \n  console.log('This pattern is useful when:')\n  console.log('  \u2022 Multiple users need to interact with the same application')\n  console.log('  \u2022 You want to reuse the same app configuration (name, appId, etc.)')\n  console.log('  \u2022 Each user has their own signing account')\n  console.log('  \u2022 You want to avoid redeploying or looking up the app multiple times\\n')\n\n  console.log('Example scenarios:')\n  console.log('  \u2022 Multiplayer games where each player needs their own client')\n  console.log('  \u2022 Marketplace apps where buyers and sellers interact differently')\n  console.log('  \u2022 DAO voting where each member votes with their own account')\n  console.log('  \u2022 Testing scenarios with multiple simulated users\\n')\n\n  console.log('\u2705 All examples completed successfully!')\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "13-configure-accounts-using-environment-variables-with-priority",
      "title": "Configure Accounts Using Environment Variables with Priority",
      "summary": "Demonstrates how to configure accounts using environment variables with mnemonics and shows that environment variables take priority over KMD for account resolution.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Configure an account via environment variable mnemonic and verify that fromEnvironment prioritizes environment variables over KMD",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.account.fromEnvironment",
        "algosdk.secretKeyToMnemonic"
      ],
      "feature_tags": [
        "account-management",
        "environment-variables",
        "mnemonic",
        "configuration",
        "account-priority"
      ],
      "folder": "13-configure-accounts-using-environment-variables-with-priority",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "Account created via KMD with name: <random-uuid>",
        "Account address: <address>",
        "Setting environment variable TEST_MNEMONIC with mnemonic",
        "Account retrieved from environment variable TEST_MNEMONIC",
        "Account address from environment: <same-address>",
        "Verification: Both accounts have the same address and private key",
        "Environment variable takes priority over KMD!"
      ],
      "source_tests": [
        {
          "file": "src/types/account-manager.spec.ts",
          "test_name": "Environment is used in preference to kmd"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the priority order of account resolution, showing that environment variables are prioritized over KMD. This is crucial for production deployments where accounts need to be configured securely.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport { v4 as uuid } from 'uuid'\n\n/**\n * This example demonstrates how to configure accounts using environment variables\n * and shows that environment variables take priority over KMD for account resolution.\n * \n * Key concepts:\n * - Using fromEnvironment() to retrieve accounts from environment variables or KMD\n * - Setting account mnemonics in environment variables\n * - Understanding account resolution priority (environment > KMD)\n */\n\nasync function main() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n\n  // Step 1: Create an account via KMD with a random name\n  const accountName = uuid()\n  console.log(`Creating account via KMD with name: ${accountName}`)\n  const account = await algorand.account.fromEnvironment(accountName)\n  console.log(`Account address: ${account.addr}\\n`)\n\n  // Step 2: Set the account's mnemonic in an environment variable\n  const envVarName = 'TEST'\n  const mnemonic = algosdk.secretKeyToMnemonic(account.account.sk)\n  process.env[`${envVarName}_MNEMONIC`] = mnemonic\n  console.log(`Setting environment variable ${envVarName}_MNEMONIC with mnemonic`)\n  console.log(`Mnemonic: ${mnemonic}\\n`)\n\n  // Step 3: Retrieve account using the environment variable\n  // This should return the same account but from the environment variable, not KMD\n  console.log(`Retrieving account from environment variable ${envVarName}_MNEMONIC`)\n  const accountFromEnv = await algorand.account.fromEnvironment(envVarName)\n  console.log(`Account address from environment: ${accountFromEnv.addr}\\n`)\n\n  // Step 4: Verify that both accounts have the same address and keys\n  console.log('Verification:')\n  console.log(`- Addresses match: ${account.addr === accountFromEnv.addr}`)\n  console.log(`- Private keys match: ${Buffer.from(account.account.sk).equals(Buffer.from(accountFromEnv.account.sk))}`)\n  console.log(`- Different object instances: ${account !== accountFromEnv}\\n`)\n\n  console.log('\u2713 Environment variable takes priority over KMD!')\n  console.log('\\nThis is important for production deployments where accounts should be')\n  console.log('configured via environment variables for better security practices.')\n}\n\nmain().catch(console.error)\n"
    },
    {
      "example_id": "14-configure-algod-client-from-environment-variables",
      "title": "Configure Algod Client from Environment Variables",
      "summary": "Demonstrates how to configure an Algod client using environment variables, including proper error handling when configuration is missing.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Configure algod client using environment variables for server, port, and token",
      "target_users": [
        "SDK developers",
        "Backend developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "ClientManager.getAlgodConfigFromEnvironment",
        "error handling for missing configuration"
      ],
      "feature_tags": [
        "configuration",
        "environment-variables",
        "algod",
        "client-setup",
        "error-handling"
      ],
      "folder": "14-configure-algod-client-from-environment-variables",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Ensure you have Node.js installed",
          "Set up environment variables in a .env file or export them directly"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "ts-node main.ts",
          "# Or compile and run: tsc main.ts && node main.js"
        ]
      },
      "expected_output": [
        "Configuration successfully retrieved with server, port, and token values",
        "Error message when environment variables are missing: 'Attempt to get default algod configuration without specifying ALGOD_SERVER in the environment variables'"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets algod config from environment"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Throws error when getting algod config when no environment defined"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines both successful configuration and error handling to provide a complete picture of environment-based configuration. It's particularly useful for CI/CD pipelines and multi-environment deployments.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to configure an Algod client using environment variables.\n * This is the recommended approach for managing configuration across different environments\n * (development, staging, production).\n */\n\nasync function main() {\n  console.log('=== Algod Client Configuration Example ===\\n')\n\n  // Example 1: Successfully getting algod config from environment variables\n  console.log('1. Configuring Algod client with environment variables:')\n  \n  // Set the required environment variables\n  process.env.ALGOD_SERVER = 'http://localhost'\n  process.env.ALGOD_PORT = '4001'\n  process.env.ALGOD_TOKEN = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n\n  try {\n    // Get the algod configuration from environment variables\n    const config = ClientManager.getAlgodConfigFromEnvironment()\n    \n    console.log('  \u2713 Configuration retrieved successfully:')\n    console.log(`    - Server: ${config.server}`)\n    console.log(`    - Port: ${config.port}`)\n    console.log(`    - Token: ${config.token.substring(0, 10)}...`)\n    console.log()\n  } catch (error) {\n    console.error('  \u2717 Failed to get configuration:', error)\n  }\n\n  // Example 2: Demonstrating error handling when environment variables are missing\n  console.log('2. Handling missing environment variables:')\n  \n  // Clear the environment variables to simulate missing configuration\n  delete process.env.ALGOD_SERVER\n  delete process.env.ALGOD_PORT\n  delete process.env.ALGOD_TOKEN\n\n  try {\n    // This will throw an error because ALGOD_SERVER is not defined\n    ClientManager.getAlgodConfigFromEnvironment()\n  } catch (error) {\n    console.log('  \u2713 Error caught as expected:')\n    console.log(`    - ${(error as Error).message}`)\n    console.log()\n  }\n\n  console.log('=== Key Takeaways ===')\n  console.log('\u2022 Set ALGOD_SERVER, ALGOD_PORT, and ALGOD_TOKEN environment variables')\n  console.log('\u2022 Use getAlgodConfigFromEnvironment() to retrieve the configuration')\n  console.log('\u2022 Always handle potential errors when configuration is missing')\n  console.log('\u2022 This pattern works great for different deployment environments')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "15-configure-debug-mode-and-emit-async-events",
      "title": "Configure Debug Mode and Emit Async Events",
      "summary": "Demonstrates how to configure debug mode, register event handlers, and emit async events using the AlgoKit Utils event system.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "event handling",
      "specific_use_case": "Configure debug mode and emit async events with registered event handlers",
      "target_users": [
        "SDK developers",
        "Developers implementing debug handlers",
        "Developers working with async event systems"
      ],
      "features_tested": [
        "Config.configure",
        "Config.events.on",
        "Config.events.emitAsync"
      ],
      "feature_tags": [
        "events",
        "async",
        "debug",
        "configuration",
        "event-handlers",
        "monitoring"
      ],
      "folder": "15-configure-debug-mode-and-emit-async-events",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Debug mode configured successfully",
        "Event listener registered",
        "Event emitted: event_a",
        "Event received with data: { hello: 'world' }"
      ],
      "source_tests": [
        {
          "file": "src/types/async-event-emitter.spec.ts",
          "test_name": "users code would looks like this"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the basic pattern for working with AlgoKit's async event system, which is useful for implementing debug handlers, monitoring, and event-driven architectures.",
      "generated_code": "import { Config } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to configure debug mode and work with async events\n * in AlgoKit Utils. The event system allows you to emit and listen for events\n * asynchronously, which is useful for debugging, monitoring, and event-driven architectures.\n */\n\nasync function main() {\n  // Step 1: Configure AlgoKit Utils with debug mode enabled\n  console.log('Configuring debug mode...')\n  Config.configure({\n    debug: true,\n  })\n  console.log('Debug mode configured successfully')\n\n  // Step 2: Register an event handler\n  // This simulates what algokit-utils-ts-debug or similar packages would do\n  console.log('Registering event listener...')\n  Config.events.on('event_a', (data) => {\n    console.log('Event received with data:', data)\n  })\n  console.log('Event listener registered')\n\n  // Step 3: Emit an async event\n  console.log('Emitting event: event_a')\n  await Config.events.emitAsync('event_a', {\n    hello: 'world',\n  })\n\n  // Wait a moment for async event processing to complete\n  await new Promise((resolve) => setTimeout(resolve, 100))\n\n  console.log('Event processing complete')\n}\n\n// Run the example\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})\n"
    },
    {
      "example_id": "16-configure-indexer-client-from-environment-variables",
      "title": "Configure Indexer Client from Environment Variables",
      "summary": "Demonstrates how to configure an Indexer client using environment variables for querying blockchain data across different environments.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Configure indexer client using environment variables for server, port, and token",
      "target_users": [
        "SDK developers",
        "Backend developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "ClientManager.getIndexerConfigFromEnvironment"
      ],
      "feature_tags": [
        "configuration",
        "environment-variables",
        "indexer",
        "client-setup",
        "blockchain-data"
      ],
      "folder": "16-configure-indexer-client-from-environment-variables",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "INDEXER_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "INDEXER_PORT",
            "required": true,
            "example": "8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Ensure you have Node.js installed",
          "Set up environment variables for your target network (LocalNet, TestNet, or MainNet)",
          "For LocalNet: Start AlgoKit LocalNet with 'algokit localnet start'"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "ts-node main.ts",
          "# Or compile and run: tsc main.ts && node main.js"
        ]
      },
      "expected_output": [
        "Configuration successfully retrieved with indexer server, port, and token values",
        "Helpful tips for configuring different networks (LocalNet, TestNet, MainNet)"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets indexer config from environment"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example focuses on Indexer configuration, which is essential for querying blockchain data. The example includes helpful network-specific configuration examples for LocalNet, TestNet, and MainNet.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to configure an Indexer client using environment variables.\n * The Indexer is used to query historical blockchain data, transactions, accounts, and assets.\n * Using environment variables allows you to easily switch between different networks and environments.\n */\n\nasync function main() {\n  console.log('=== Indexer Client Configuration Example ===\\n')\n\n  console.log('Configuring Indexer client with environment variables:')\n  \n  // Set the required environment variables for Indexer\n  // These would typically be set in your .env file or deployment configuration\n  process.env.INDEXER_SERVER = 'http://localhost'\n  process.env.INDEXER_PORT = '8980'\n  process.env.INDEXER_TOKEN = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n\n  try {\n    // Get the indexer configuration from environment variables\n    const config = ClientManager.getIndexerConfigFromEnvironment()\n    \n    console.log('\u2713 Indexer configuration retrieved successfully:\\n')\n    console.log(`  Server: ${config.server}`)\n    console.log(`  Port: ${config.port}`)\n    console.log(`  Token: ${config.token.substring(0, 10)}...\\n`)\n    \n    console.log('=== Configuration Details ===')\n    console.log('This configuration can now be used to:')\n    console.log('  \u2022 Query account information and balances')\n    console.log('  \u2022 Search for transactions by various criteria')\n    console.log('  \u2022 Look up asset information')\n    console.log('  \u2022 Retrieve application state and history')\n    console.log('  \u2022 Access block information\\n')\n    \n    console.log('=== Environment Setup Tips ===')\n    console.log('For LocalNet (development):')\n    console.log('  INDEXER_SERVER=http://localhost')\n    console.log('  INDEXER_PORT=8980')\n    console.log('  INDEXER_TOKEN=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\n')\n    \n    console.log('For TestNet:')\n    console.log('  INDEXER_SERVER=https://testnet-idx.algonode.cloud')\n    console.log('  INDEXER_PORT=443')\n    console.log('  INDEXER_TOKEN= (leave empty for public nodes)\\n')\n    \n    console.log('For MainNet:')\n    console.log('  INDEXER_SERVER=https://mainnet-idx.algonode.cloud')\n    console.log('  INDEXER_PORT=443')\n    console.log('  INDEXER_TOKEN= (leave empty for public nodes)\\n')\n    \n  } catch (error) {\n    console.error('\u2717 Failed to get indexer configuration:', error)\n    console.log('\\nMake sure the following environment variables are set:')\n    console.log('  - INDEXER_SERVER')\n    console.log('  - INDEXER_PORT')\n    console.log('  - INDEXER_TOKEN')\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "17-connect-to-algorand-networks-using-algonode",
      "title": "Connect to Algorand Networks Using AlgoNode",
      "summary": "Demonstrates how to use ClientManager to get pre-configured AlgoNode settings for connecting to Algorand MainNet and TestNet, for both algod (node API) and indexer services.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Get pre-configured AlgoNode settings for connecting to different Algorand networks and services without manual configuration",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getAlgoNodeConfig"
      ],
      "feature_tags": [
        "algonode",
        "configuration",
        "mainnet",
        "testnet",
        "algod",
        "indexer",
        "client-setup",
        "network-connection"
      ],
      "folder": "17-connect-to-algorand-networks-using-algonode",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Create a new directory for the example",
          "Initialize a TypeScript project if needed"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils",
          "npm install typescript @types/node --save-dev"
        ],
        "execute": [
          "npx ts-node main.ts",
          "or compile and run: tsc main.ts && node main.js"
        ]
      },
      "expected_output": [
        "MainNet Algod Configuration:",
        "  Server: https://mainnet-api.algonode.cloud/",
        "  Port: 443",
        "",
        "TestNet Algod Configuration:",
        "  Server: https://testnet-api.algonode.cloud/",
        "  Port: 443",
        "",
        "MainNet Indexer Configuration:",
        "  Server: https://mainnet-idx.algonode.cloud/",
        "  Port: 443",
        "",
        "TestNet Indexer Configuration:",
        "  Server: https://testnet-idx.algonode.cloud/",
        "  Port: 443"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets AlgoNode config for MainNet algod"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets AlgoNode config for TestNet algod"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets AlgoNode config for MainNet indexer"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows how to retrieve pre-configured AlgoNode settings, which eliminates the need to manually specify server URLs and ports. AlgoNode provides free, public API access to Algorand networks, making it ideal for development, testing, and production applications. The configurations can be used directly with algosdk to create client instances.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to get pre-configured AlgoNode settings\n * for connecting to Algorand networks without manual configuration.\n * \n * AlgoNode provides free, public infrastructure for Algorand networks,\n * making it easy to connect to MainNet and TestNet for development and production.\n */\n\n// Get AlgoNode configuration for MainNet algod (node API)\nconst mainnetAlgodConfig = ClientManager.getAlgoNodeConfig('mainnet', 'algod')\nconsole.log('MainNet Algod Configuration:')\nconsole.log(`  Server: ${mainnetAlgodConfig.server}`)\nconsole.log(`  Port: ${mainnetAlgodConfig.port}`)\nconsole.log()\n\n// Get AlgoNode configuration for TestNet algod (node API)\nconst testnetAlgodConfig = ClientManager.getAlgoNodeConfig('testnet', 'algod')\nconsole.log('TestNet Algod Configuration:')\nconsole.log(`  Server: ${testnetAlgodConfig.server}`)\nconsole.log(`  Port: ${testnetAlgodConfig.port}`)\nconsole.log()\n\n// Get AlgoNode configuration for MainNet indexer (query API)\nconst mainnetIndexerConfig = ClientManager.getAlgoNodeConfig('mainnet', 'indexer')\nconsole.log('MainNet Indexer Configuration:')\nconsole.log(`  Server: ${mainnetIndexerConfig.server}`)\nconsole.log(`  Port: ${mainnetIndexerConfig.port}`)\nconsole.log()\n\n// Get AlgoNode configuration for TestNet indexer (query API)\nconst testnetIndexerConfig = ClientManager.getAlgoNodeConfig('testnet', 'indexer')\nconsole.log('TestNet Indexer Configuration:')\nconsole.log(`  Server: ${testnetIndexerConfig.server}`)\nconsole.log(`  Port: ${testnetIndexerConfig.port}`)\nconsole.log()\n\n// You can use these configurations to create actual clients:\n// Example:\n// import algosdk from 'algosdk'\n// const algodClient = new algosdk.Algodv2('', mainnetAlgodConfig.server, mainnetAlgodConfig.port)\n// const indexerClient = new algosdk.Indexer('', mainnetIndexerConfig.server, mainnetIndexerConfig.port)"
    },
    {
      "example_id": "18-connect-to-localnet-clients-algod-indexer-kmd",
      "title": "Connect to LocalNet Clients (Algod, Indexer, KMD)",
      "summary": "Demonstrates how to create and verify connections to LocalNet algod, indexer, and KMD clients for local development and testing",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Create and verify working client connections to LocalNet services (algod, indexer, KMD) for local development",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Backend developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getIndexerClient",
        "ClientManager.getKmdClient",
        "ClientManager.getDefaultLocalNetConfig",
        "indexer.makeHealthCheck",
        "kmd.listWallets"
      ],
      "feature_tags": [
        "client-configuration",
        "localnet",
        "indexer",
        "kmd",
        "algod",
        "health-check",
        "wallet-management",
        "development-setup"
      ],
      "folder": "18-connect-to-localnet-clients-algod-indexer-kmd",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with indexer and KMD enabled: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Successfully connected to LocalNet algod client",
        "Successfully connected to LocalNet indexer client",
        "Successfully connected to LocalNet KMD client",
        "KMD wallets listed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Get working LocalNet indexer client"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Get working LocalNet kmd client"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires LocalNet to be running with indexer and KMD services enabled. Use 'algokit localnet start' to ensure all services are available.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to connect to LocalNet clients (algod, indexer, KMD)\n * for local development and testing with Algorand.\n * \n * Prerequisites:\n * - LocalNet running (use: algokit localnet start)\n * - Indexer and KMD services enabled\n */\n\nasync function main() {\n  try {\n    // 1. Connect to LocalNet Algod Client\n    // Algod is the main API for interacting with the Algorand blockchain\n    console.log('\\n1. Connecting to LocalNet algod client...')\n    const algod = ClientManager.getAlgodClient(ClientManager.getDefaultLocalNetConfig('algod'))\n    \n    // Verify the connection by checking node status\n    const status = await algod.status().do()\n    console.log('\u2713 Successfully connected to LocalNet algod client')\n    console.log(`  - Last round: ${status['last-round']}`)\n    console.log(`  - Time since last round: ${status['time-since-last-round']}ms`)\n\n    // 2. Connect to LocalNet Indexer Client\n    // Indexer provides a searchable database for blockchain data\n    console.log('\\n2. Connecting to LocalNet indexer client...')\n    const indexer = ClientManager.getIndexerClient(ClientManager.getDefaultLocalNetConfig('indexer'))\n    \n    // Verify the connection with a health check\n    await indexer.makeHealthCheck().do()\n    console.log('\u2713 Successfully connected to LocalNet indexer client')\n    console.log('  - Indexer is healthy and ready for queries')\n\n    // 3. Connect to LocalNet KMD Client\n    // KMD (Key Management Daemon) manages wallets and private keys\n    console.log('\\n3. Connecting to LocalNet KMD client...')\n    const kmd = ClientManager.getKmdClient(ClientManager.getDefaultLocalNetConfig('kmd'))\n    \n    // Verify the connection by listing available wallets\n    const wallets = await kmd.listWallets()\n    console.log('\u2713 Successfully connected to LocalNet KMD client')\n    console.log(`  - Found ${wallets.wallets.length} wallet(s):`)\n    wallets.wallets.forEach((wallet: any) => {\n      console.log(`    - ${wallet.name} (ID: ${wallet.id})`)\n    })\n\n    console.log('\\n\u2705 All LocalNet clients connected successfully!')\n    console.log('\\nYou can now use these clients for:')\n    console.log('  - algod: Submit transactions, query blockchain state')\n    console.log('  - indexer: Search and query historical blockchain data')\n    console.log('  - kmd: Manage wallets and sign transactions')\n\n  } catch (error) {\n    console.error('\\n\u274c Error connecting to LocalNet clients:')\n    console.error(error)\n    console.error('\\nMake sure LocalNet is running with: algokit localnet start')\n    process.exit(1)\n  }\n}\n\nmain()"
    },
    {
      "example_id": "19-connect-to-localnet-for-development",
      "title": "Connect to LocalNet for Development",
      "summary": "Demonstrates how to create and verify a working algod client connection to LocalNet. This is essential for local development and testing of Algorand applications.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Create and verify a working algod client connection to LocalNet",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getDefaultLocalNetConfig",
        "algod.status"
      ],
      "feature_tags": [
        "localnet",
        "algod",
        "configuration",
        "development",
        "client-setup",
        "health-check"
      ],
      "folder": "19-connect-to-localnet-for-development",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "ts-node"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "LocalNet algod configuration details (server, port, token)",
        "Successful algod client creation message",
        "Network status information including last round, consensus version",
        "Network parameters including genesis ID and minimum fee",
        "Success confirmation message"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Get working LocalNet algod client"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires LocalNet to be running. Users can start LocalNet using 'algokit localnet start' command. The example includes proper error handling to guide users if LocalNet is not running.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to connect to a local Algorand network (LocalNet)\n * for development and testing purposes.\n * \n * LocalNet is a local Algorand network that runs on your machine, typically using Docker.\n * It's perfect for development because it's fast, free, and you have complete control.\n * \n * Prerequisites:\n * - LocalNet must be running (use `algokit localnet start` to start it)\n */\n\nasync function main() {\n  console.log('Connecting to LocalNet...')\n  \n  // Step 1: Get the default LocalNet configuration for algod\n  // This returns server URL, port, and token for connecting to LocalNet\n  const localNetConfig = ClientManager.getDefaultLocalNetConfig('algod')\n  \n  console.log('LocalNet Algod Configuration:')\n  console.log(`  Server: ${localNetConfig.server}`)\n  console.log(`  Port: ${localNetConfig.port}`)\n  console.log(`  Token: ${localNetConfig.token}`)\n  \n  // Step 2: Create an algod client using the configuration\n  const algod = ClientManager.getAlgodClient(localNetConfig)\n  console.log('\\nAlgod client created successfully!')\n  \n  // Step 3: Verify the connection by checking the node status\n  // This is a good way to ensure LocalNet is running and accessible\n  try {\n    const status = await algod.status().do()\n    \n    console.log('\\nLocalNet Status:')\n    console.log(`  Last Round: ${status['last-round']}`)\n    console.log(`  Last Consensus Version: ${status['last-version']}`)\n    console.log(`  Next Consensus Version: ${status['next-version']}`)\n    console.log(`  Next Version Round: ${status['next-version-round']}`)\n    console.log(`  Next Version Supported: ${status['next-version-supported']}`)\n    console.log(`  Time Since Last Round: ${status['time-since-last-round']} ns`)\n    console.log(`  Catchup Time: ${status['catchup-time']} ns`)\n    console.log(`  Stopped on Unsupported Protocol: ${status['stopped-at-unsupported-round']}`)\n    \n    console.log('\\n\u2705 Successfully connected to LocalNet!')\n    \n    // You can also get other useful information\n    const params = await algod.getTransactionParams().do()\n    console.log('\\nNetwork Parameters:')\n    console.log(`  Genesis ID: ${params.genesisID}`)\n    console.log(`  Genesis Hash: ${params.genesisHash}`)\n    console.log(`  Min Fee: ${params.minFee} microAlgos`)\n    \n  } catch (error) {\n    console.error('\\n\u274c Failed to connect to LocalNet:')\n    console.error('Make sure LocalNet is running with: algokit localnet start')\n    console.error('Error details:', error)\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "20-connect-to-mainnet-indexer-using-algonode",
      "title": "Connect to MainNet Indexer Using AlgoNode",
      "summary": "Demonstrates how to create an indexer client for Algorand MainNet using AlgoNode and verify the connection with a health check.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Create and verify a working indexer client connection to MainNet using AlgoNode",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getIndexerClient",
        "ClientManager.getAlgoNodeConfig",
        "indexer.makeHealthCheck"
      ],
      "feature_tags": [
        "client-configuration",
        "mainnet",
        "indexer",
        "algonode",
        "health-check",
        "network-connection"
      ],
      "folder": "20-connect-to-mainnet-indexer-using-algonode",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Connection to MainNet indexer URL displayed",
        "Health check response showing indexer status",
        "Success message confirming connection"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Get working MainNet indexer client"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example uses AlgoNode's free public infrastructure, which is suitable for development and production use. No API keys or authentication required.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to connect to Algorand MainNet indexer\n * using AlgoNode's public infrastructure and verify the connection.\n * \n * The indexer allows you to query historical blockchain data, search for\n * transactions, accounts, assets, and applications.\n */\n\nasync function main() {\n  // Get the AlgoNode configuration for MainNet indexer\n  // This provides the URL and connection details for AlgoNode's free public indexer\n  const config = ClientManager.getAlgoNodeConfig('mainnet', 'indexer')\n  console.log('Connecting to MainNet indexer at:', config.server)\n\n  // Create an indexer client using the AlgoNode configuration\n  const indexer = ClientManager.getIndexerClient(config)\n\n  try {\n    // Perform a health check to verify the connection is working\n    const health = await indexer.makeHealthCheck().do()\n    console.log('\u2713 Successfully connected to MainNet indexer!')\n    console.log('Indexer health:', health)\n    console.log('Connection verified - ready to query blockchain data')\n  } catch (error) {\n    console.error('\u2717 Failed to connect to MainNet indexer:', error)\n    throw error\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "21-connect-to-mainnet-using-algonode",
      "title": "Connect to MainNet using AlgoNode",
      "summary": "Demonstrates how to create and verify a connection to Algorand MainNet using AlgoNode public API endpoints",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Create and verify a working algod client connection to MainNet using AlgoNode for production applications",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getAlgoNodeConfig",
        "algod.status"
      ],
      "feature_tags": [
        "client-configuration",
        "mainnet",
        "algod",
        "algonode",
        "production",
        "health-check",
        "public-api"
      ],
      "folder": "21-connect-to-mainnet-using-algonode",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Successfully connected to Algorand MainNet",
        "Current round number displayed",
        "Network information shown",
        "Genesis ID and hash displayed"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Get working MainNet algod client"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example uses AlgoNode's free public API endpoints for MainNet. No authentication or setup required. For production applications with high traffic, consider using a dedicated node or rate-limited API service.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to connect to Algorand MainNet using AlgoNode.\n * AlgoNode provides free, public API endpoints for MainNet and TestNet.\n * \n * Prerequisites:\n * - Internet connection (no local node required)\n * - No API keys needed for basic usage\n */\n\nasync function main() {\n  try {\n    console.log('\\n\ud83c\udf10 Connecting to Algorand MainNet via AlgoNode...')\n\n    // Create an algod client configured for MainNet using AlgoNode\n    // AlgoNode provides free, reliable public API endpoints\n    const algod = ClientManager.getAlgodClient(ClientManager.getAlgoNodeConfig('mainnet', 'algod'))\n\n    // Verify the connection by fetching the current network status\n    console.log('\\n\ud83d\udce1 Fetching network status...')\n    const status = await algod.status().do()\n\n    console.log('\\n\u2705 Successfully connected to Algorand MainNet!')\n    console.log('\\nNetwork Information:')\n    console.log(`  - Last round: ${status['last-round']}`)\n    console.log(`  - Time since last round: ${status['time-since-last-round']}ms`)\n    console.log(`  - Catchup time: ${status['catchup-time']}ms`)\n    console.log(`  - Last consensus version: ${status['last-consensus-version']}`)\n\n    // Fetch additional network parameters\n    const params = await algod.getTransactionParams().do()\n    console.log('\\nTransaction Parameters:')\n    console.log(`  - Genesis ID: ${params.genesisID}`)\n    console.log(`  - Genesis hash: ${params.genesisHash}`)\n    console.log(`  - Min fee: ${params.minFee} microAlgos`)\n    console.log(`  - Consensus version: ${params.consensusVersion}`)\n\n    console.log('\\n\ud83d\udca1 You can now use this client to:')\n    console.log('  - Query account balances and information')\n    console.log('  - Submit transactions to MainNet')\n    console.log('  - Read application and asset data')\n    console.log('  - Monitor blockchain activity')\n\n    console.log('\\n\u26a0\ufe0f  Note: For production applications with high request volumes,')\n    console.log('   consider running your own node or using a rate-limited API service.')\n\n  } catch (error) {\n    console.error('\\n\u274c Error connecting to MainNet:')\n    console.error(error)\n    console.error('\\nPlease check your internet connection and try again.')\n    process.exit(1)\n  }\n}\n\nmain()"
    },
    {
      "example_id": "22-connect-to-testnet-using-algonode-configuration",
      "title": "Connect to TestNet Using AlgoNode Configuration",
      "summary": "Demonstrates how to retrieve pre-configured AlgoNode settings for connecting to Algorand TestNet indexer",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Get pre-configured AlgoNode settings for connecting to TestNet indexer",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getAlgoNodeConfig"
      ],
      "feature_tags": [
        "algonode",
        "testnet",
        "indexer",
        "configuration",
        "client-setup"
      ],
      "folder": "22-connect-to-testnet-using-algonode-configuration",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "ts-node"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "AlgoNode TestNet Indexer Configuration with server URL (https://testnet-idx.algonode.cloud/), port (443), and token",
        "AlgoNode MainNet Algod Configuration details",
        "Successful indexer client creation",
        "Health check response from the TestNet indexer"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Gets AlgoNode config for TestNet indexer"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the simplest way to connect to Algorand public networks using AlgoNode infrastructure. No API keys or manual configuration required.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to get pre-configured AlgoNode settings\n * for connecting to Algorand TestNet indexer.\n * \n * AlgoNode provides free, public infrastructure for accessing Algorand networks.\n * The ClientManager provides convenient methods to get these configurations.\n */\n\nasync function main() {\n  console.log('Getting AlgoNode configuration for TestNet indexer...')\n  \n  // Get pre-configured AlgoNode settings for TestNet indexer\n  // This returns an object with server URL, port, and token\n  const config = ClientManager.getAlgoNodeConfig('testnet', 'indexer')\n  \n  console.log('AlgoNode TestNet Indexer Configuration:')\n  console.log(`  Server: ${config.server}`)\n  console.log(`  Port: ${config.port}`)\n  console.log(`  Token: ${config.token || '(empty)'}`)  \n  \n  // You can also get configuration for MainNet or algod client\n  const mainnetAlgodConfig = ClientManager.getAlgoNodeConfig('mainnet', 'algod')\n  console.log('\\nAlgoNode MainNet Algod Configuration:')\n  console.log(`  Server: ${mainnetAlgodConfig.server}`)\n  console.log(`  Port: ${mainnetAlgodConfig.port}`)\n  \n  // Use the config to create an indexer client\n  const indexer = ClientManager.getIndexerClient(config)\n  console.log('\\nIndexer client created successfully!')\n  \n  // Example: Fetch network health information\n  try {\n    const health = await indexer.makeHealthCheck().do()\n    console.log('\\nIndexer Health Check:')\n    console.log(`  Status: Healthy`)\n    console.log(`  Response:`, health)\n  } catch (error) {\n    console.error('Health check failed:', error)\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "23-construct-application-call-transaction-with-box-references",
      "title": "Construct Application Call Transaction with Box References",
      "summary": "Demonstrates how to construct an application call transaction that includes box storage references, essential for smart contracts that use box storage.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "box storage",
      "specific_use_case": "Construct a transaction with box references for box storage access",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.call",
        "boxes parameter",
        "sendParams.skipSending",
        "box references"
      ],
      "feature_tags": [
        "box-storage",
        "transaction-construction",
        "box-references",
        "abi-method",
        "app-call"
      ],
      "folder": "23-construct-application-call-transaction-with-box-references",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost:4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID: <app_id>",
        "Constructing transaction with box references...",
        "Transaction constructed successfully",
        "Box reference: appIndex=0, name=1"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Construct transaction with boxes"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample ARC-32 app spec with call_abi method"
        }
      ],
      "notes": "This example shows how to add box references when calling an application. Box references are necessary when the contract accesses box storage during execution. The skipSending parameter allows you to construct and inspect the transaction without sending it.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to construct an application call transaction\n * that includes box storage references. Box references are required when\n * your smart contract needs to access box storage during execution.\n */\n\n// Sample app spec with call_abi method that uses box storage\nconst appSpec = {\n  hints: {\n    call_abi: {\n      call_config: {\n        no_op: 'CALL',\n      },\n    },\n  },\n  contract: {\n    name: 'BoxStorageApp',\n    methods: [\n      {\n        name: 'call_abi',\n        args: [{ type: 'string', name: 'input' }],\n        returns: { type: 'string' },\n      },\n    ],\n  },\n  state: {\n    global: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n    local: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n  },\n  schema: {\n    global: {\n      declared: {},\n      reserved: {},\n    },\n    local: {\n      declared: {},\n      reserved: {},\n    },\n  },\n  source: {\n    approval: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n    clear: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n  },\n  bare_call_config: {\n    no_op: 'CREATE',\n    opt_in: 'NEVER',\n    close_out: 'NEVER',\n    update_application: 'NEVER',\n    delete_application: 'NEVER',\n  },\n  template_variables: {\n    UPDATABLE: { type: 'uint64' },\n    DELETABLE: { type: 'uint64' },\n    VALUE: { type: 'uint64' },\n  },\n}\n\nasync function constructTransactionWithBoxes() {\n  // Initialize AlgorandClient for LocalNet\n  const algod = new algosdk.Algodv2('a' + 'a'.repeat(63), 'http://localhost', 4001)\n  const algorand = AlgorandClient.fromClients({ algod })\n\n  // Get a test account from the LocalNet dispenser\n  const testAccount = await algorand.account.fromEnvironment('LOCALNET')\n  console.log(`Using account: ${testAccount.addr}`)\n\n  // Step 1: Create and deploy the app\n  console.log('Creating app...')\n  const appClient = algorand.client.getAppClient({\n    resolveBy: 'id',\n    app: appSpec,\n    sender: testAccount,\n    id: 0,\n  })\n\n  const createResult = await appClient.create({\n    deployTimeParams: {\n      UPDATABLE: 1,\n      DELETABLE: 1,\n      VALUE: 1,\n    },\n  })\n\n  console.log(`App created with ID: ${createResult.appId}`)\n\n  // Step 2: Construct a transaction with box references\n  console.log('\\nConstructing transaction with box references...')\n  \n  /**\n   * Box references tell the application which boxes it can access during execution.\n   * - appId: 0 refers to the current application (the one being called)\n   * - name: The name of the box to reference (string or Uint8Array)\n   */\n  const call = await appClient.call({\n    method: 'call_abi',\n    methodArgs: ['test'],\n    boxes: [\n      { \n        appId: 0,      // 0 means the current app\n        name: '1'      // Box name\n      }\n    ],\n    sendParams: { \n      skipSending: true  // Don't actually send the transaction, just construct it\n    },\n  })\n\n  // Step 3: Inspect the constructed transaction\n  console.log('Transaction constructed successfully')\n  \n  const boxes = call.transaction.applicationCall?.boxes\n  if (boxes) {\n    console.log(`\\nBox references included in transaction:`)\n    boxes.forEach((box, index) => {\n      const encoder = new TextEncoder()\n      const boxName = new TextDecoder().decode(box.name)\n      console.log(`  Box ${index + 1}:`)\n      console.log(`    appIndex: ${box.appIndex}`)\n      console.log(`    name: ${boxName}`)\n    })\n  }\n\n  // Step 4: Actually send a call with box references\n  console.log('\\nSending actual call with box references...')\n  const actualCall = await appClient.call({\n    method: 'call_abi',\n    methodArgs: ['test'],\n    boxes: [\n      { appId: 0, name: '1' },\n      { appId: 0, name: '2' },  // You can reference multiple boxes\n    ],\n  })\n\n  console.log(`Transaction ID: ${actualCall.txIds[0]}`)\n  console.log('Call completed successfully!')\n}\n\n// Run the example\nconstructTransactionWithBoxes().catch(console.error)\n"
    },
    {
      "example_id": "24-construct-transaction-with-box-references",
      "title": "Construct Transaction with Box References",
      "summary": "Demonstrates how to construct application call transactions that reference box storage, supporting both explicit and shorthand box reference formats",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Construct a transaction with box references for methods that access box storage",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.createTransaction.call",
        "boxReferences parameter",
        "box storage access",
        "transaction construction"
      ],
      "feature_tags": [
        "box-storage",
        "transaction-construction",
        "box-references",
        "abi-method",
        "storage-access"
      ],
      "folder": "24-construct-transaction-with-box-references",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Constructing transaction with box references...",
        "--- Method 1: Explicit Box Reference Format ---",
        "Box references in transaction:",
        "  - App Index: 0",
        "  - Box Name (encoded): [Uint8Array]",
        "  - Box Name (decoded): 1",
        "--- Method 2: Shorthand Box Reference Format ---",
        "Box references in transaction (shorthand):",
        "  - App Index: 0",
        "  - Box Name (encoded): [Uint8Array]",
        "  - Box Name (decoded): 1",
        "Both formats produce equivalent transactions!",
        "\ud83d\udca1 Tips:",
        "  - Use appId: 0n for boxes in the current app",
        "  - Use specific appId for boxes in other apps",
        "  - Use shorthand format (just string) for current app boxes",
        "  - Box names are automatically encoded to Uint8Array",
        "\u2705 Example completed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Construct transaction with boxes"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Example smart contract with call_abi method that accesses box storage"
        }
      ],
      "notes": "This example requires a smart contract that uses box storage. The contract should have a 'call_abi' method that reads from or writes to boxes. Box storage must be properly initialized in the contract.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AppClient } from '@algorandfoundation/algokit-utils/types/app-client'\n\n/**\n * This example demonstrates how to construct transactions with box references.\n * Box storage allows smart contracts to store arbitrary amounts of data.\n * When calling methods that access boxes, you must specify which boxes will be accessed.\n * \n * Key concepts:\n * - Box storage references in transactions\n * - Two formats for specifying box references (explicit and shorthand)\n * - Transaction construction without immediate execution\n */\n\nasync function constructTransactionWithBoxes() {\n  // Setup: Create an Algorand test fixture\n  const localnet = await algorandFixture()\n  const { algorand, testAccount } = localnet.context\n\n  // Note: You'll need to deploy your app and create an AppClient\n  // const client = new AppClient({\n  //   app: yourAppSpec,\n  //   sender: testAccount,\n  //   algorand,\n  // })\n  \n  console.log('Constructing transaction with box references...')\n  console.log('\\n--- Method 1: Explicit Box Reference Format ---')\n  \n  // Method 1: Explicit format with appId and name\n  // appId: 0n means the current application (the one being called)\n  // name: '1' is the box name to reference\n  const transactionWithExplicitBoxRef = await client.createTransaction.call({\n    method: 'call_abi',\n    args: ['test'],\n    boxReferences: [\n      { \n        appId: 0n,  // 0 = current app, or specify another app's ID\n        name: '1'    // Box name as a string\n      }\n    ],\n  })\n\n  // Inspect the constructed transaction\n  const encoder = new TextEncoder()\n  const boxes1 = transactionWithExplicitBoxRef.transactions[0].applicationCall?.boxes\n  \n  console.log('Box references in transaction:')\n  console.log(`  - App Index: ${boxes1?.[0].appIndex}`)\n  console.log(`  - Box Name (encoded): ${boxes1?.[0].name}`)\n  console.log(`  - Box Name (decoded): ${new TextDecoder().decode(boxes1?.[0].name as Uint8Array)}`)\n  \n  console.log('\\n--- Method 2: Shorthand Box Reference Format ---')\n  \n  // Method 2: Shorthand format - just provide the box name as a string\n  // This automatically assumes appId: 0 (current application)\n  const transactionWithShorthandBoxRef = await client.createTransaction.call({\n    method: 'call_abi',\n    args: ['test'],\n    boxReferences: ['1'],  // Shorthand: just the box name\n  })\n\n  const boxes2 = transactionWithShorthandBoxRef.transactions[0].applicationCall?.boxes\n  \n  console.log('Box references in transaction (shorthand):')\n  console.log(`  - App Index: ${boxes2?.[0].appIndex}`)\n  console.log(`  - Box Name (encoded): ${boxes2?.[0].name}`)\n  console.log(`  - Box Name (decoded): ${new TextDecoder().decode(boxes2?.[0].name as Uint8Array)}`)\n  \n  console.log('\\nBoth formats produce equivalent transactions!')\n  console.log('\\n\ud83d\udca1 Tips:')\n  console.log('  - Use appId: 0n for boxes in the current app')\n  console.log('  - Use specific appId for boxes in other apps')\n  console.log('  - Use shorthand format (just string) for current app boxes')\n  console.log('  - Box names are automatically encoded to Uint8Array')\n  \n  // Note: These are just constructed transactions, not yet sent\n  // To execute them, you would use client.send.call() instead of createTransaction.call()\n  \n  return {\n    explicitFormat: transactionWithExplicitBoxRef,\n    shorthandFormat: transactionWithShorthandBoxRef,\n  }\n}\n\n// Run the example\nconstructTransactionWithBoxes()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "25-control-funding-increments-for-account-top-ups",
      "title": "Control Funding Increments for Account Top-ups",
      "summary": "Demonstrates how to use minFundingIncrement to control the minimum amount when topping up an existing account, optimizing for transaction fees and efficiency",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Control the minimum amount to fund when topping up an existing account",
      "target_users": [
        "SDK developers",
        "Application developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.account.ensureFunded",
        "minFundingIncrement option",
        "algorand.account.getInformation"
      ],
      "feature_tags": [
        "account-funding",
        "funding-increment",
        "account-management",
        "funding-optimization",
        "transaction-optimization"
      ],
      "folder": "25-control-funding-increments-for-account-top-ups",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "tsx"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils typescript tsx"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial account balance shown",
        "Account funded with 1 ALGO (even though minimum was only 1 microAlgo)",
        "Final balance shows 1.1 ALGO (1,100,000 microAlgos)",
        "Transaction confirmation with transaction ID"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "ensureFunded respects minimum funding increment"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the practical use of minFundingIncrement to avoid many small funding transactions. This is especially useful in automated systems that frequently ensure accounts have sufficient funds.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgo, algo } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use the minFundingIncrement option\n * when funding accounts to optimize for transaction fees.\n * \n * The minFundingIncrement ensures that when topping up an account,\n * at least a specified amount is added, avoiding many small transactions.\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get the default dispenser account (for funding)\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n\n  // Create two accounts for demonstration\n  console.log('Creating test accounts...')\n  const fundingAccount = await algorand.account.fromEnvironment('DISPENSER')\n  const targetAccount = await algorand.account.random()\n\n  // Give the target account some initial funds (100,000 microAlgos = 0.1 ALGO)\n  console.log('\\nFunding target account with initial amount (0.1 ALGO)...')\n  await algorand.send.payment({\n    sender: fundingAccount.addr,\n    receiver: targetAccount.addr,\n    amount: microAlgo(100_000)\n  })\n\n  // Check initial balance\n  let accountInfo = await algorand.account.getInformation(targetAccount.addr)\n  console.log(`Initial balance: ${accountInfo.balance.microAlgo} microAlgos (${accountInfo.balance.algo} ALGO)`)\n\n  /**\n   * Now use ensureFunded with minFundingIncrement.\n   * \n   * We specify:\n   * - minSpending: 1 microAlgo (the minimum balance we want)\n   * - minFundingIncrement: 1 ALGO (the minimum amount to add if funding is needed)\n   * \n   * Since the account already has 100,000 microAlgos, it needs more funds.\n   * Instead of adding just 1 microAlgo, it will add at least 1 ALGO (1,000,000 microAlgos)\n   */\n  console.log('\\nEnsuring account has at least 1 microAlgo with 1 ALGO minimum increment...')\n  const result = await algorand.account.ensureFunded(\n    targetAccount.addr,\n    fundingAccount.addr,\n    microAlgo(1),\n    {\n      minFundingIncrement: algo(1),\n    }\n  )\n\n  if (result) {\n    console.log(`\\n\u2705 Account funded!`)\n    console.log(`Amount added: ${result.amountFunded.algo} ALGO (${result.amountFunded.microAlgo} microAlgos)`)\n    console.log(`Transaction ID: ${result.confirmation.txId}`)\n  } else {\n    console.log('\\nAccount already had sufficient funds, no transaction needed')\n  }\n\n  // Check final balance\n  accountInfo = await algorand.account.getInformation(targetAccount.addr)\n  console.log(`\\nFinal balance: ${accountInfo.balance.microAlgo} microAlgos (${accountInfo.balance.algo} ALGO)`)\n\n  console.log('\\n\ud83d\udcdd Key Takeaway:')\n  console.log('Using minFundingIncrement helps optimize funding by ensuring meaningful amounts')\n  console.log('are added each time, reducing the total number of funding transactions needed.')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "26-converting-abi-byte-arrays-to-uint8array",
      "title": "Converting ABI Byte Arrays to Uint8Array",
      "summary": "Demonstrates how to convert ABI byte arrays (both static and dynamic) to JavaScript Uint8Array format for use with Algorand smart contracts",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "ABI type conversion",
      "specific_use_case": "Convert ABI byte arrays (static byte[4] and dynamic byte[]) to Uint8Array for smart contract interaction",
      "target_users": [
        "Smart contract developers",
        "SDK developers"
      ],
      "features_tested": [
        "convertAbiByteArrays",
        "ABIArrayStaticType",
        "ABIArrayDynamicType",
        "ABIByteType"
      ],
      "feature_tags": [
        "abi",
        "type-conversion",
        "byte-arrays",
        "uint8array",
        "smart-contracts",
        "encoding"
      ],
      "folder": "26-converting-abi-byte-arrays-to-uint8array",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Static byte array conversion:",
        "Original: [1, 2, 3, 4]",
        "Converted: Uint8Array(4) [1, 2, 3, 4]",
        "",
        "Dynamic byte array conversion:",
        "Original: [10, 20, 30, 40, 50]",
        "Converted: Uint8Array(5) [10, 20, 30, 40, 50]",
        "",
        "Uint8Array passthrough (idempotent):",
        "Original: Uint8Array(3) [5, 6, 7]",
        "Is same instance: true"
      ],
      "source_tests": [
        {
          "file": "src/util.spec.ts",
          "test_name": "should convert a simple byte array to Uint8Array"
        },
        {
          "file": "src/util.spec.ts",
          "test_name": "should handle dynamic byte arrays"
        },
        {
          "file": "src/util.spec.ts",
          "test_name": "should return existing Uint8Array as is"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates three common scenarios when working with ABI byte arrays: converting static arrays, dynamic arrays, and handling already-converted Uint8Arrays",
      "generated_code": "import { convertAbiByteArrays } from '@algorandfoundation/algokit-utils'\nimport { ABIByteType, ABIArrayStaticType, ABIArrayDynamicType } from 'algosdk'\n\n/**\n * This example demonstrates how to convert ABI byte arrays to Uint8Array format.\n * This is useful when working with Algorand smart contracts that use ABI encoding.\n */\n\n// Example 1: Convert a static byte array (byte[4]) to Uint8Array\nfunction convertStaticByteArray() {\n  console.log('\\nStatic byte array conversion:')\n  \n  // Create a static array type of bytes with length 4: byte[4]\n  const byteType = new ABIByteType()\n  const arrayType = new ABIArrayStaticType(byteType, 4)\n\n  // Define a simple byte array\n  const value = [1, 2, 3, 4]\n  console.log('Original:', value)\n\n  // Convert to Uint8Array\n  const result = convertAbiByteArrays(value, arrayType)\n  console.log('Converted:', result)\n  console.log('Is Uint8Array:', result instanceof Uint8Array)\n}\n\n// Example 2: Convert a dynamic byte array (byte[]) to Uint8Array\nfunction convertDynamicByteArray() {\n  console.log('\\nDynamic byte array conversion:')\n  \n  // Create a dynamic array type of bytes: byte[]\n  const byteType = new ABIByteType()\n  const arrayType = new ABIArrayDynamicType(byteType)\n\n  // Define a dynamic-length byte array\n  const value = [10, 20, 30, 40, 50]\n  console.log('Original:', value)\n\n  // Convert to Uint8Array\n  const result = convertAbiByteArrays(value, arrayType)\n  console.log('Converted:', result)\n  console.log('Is Uint8Array:', result instanceof Uint8Array)\n}\n\n// Example 3: Demonstrate idempotent behavior with existing Uint8Array\nfunction handleExistingUint8Array() {\n  console.log('\\nUint8Array passthrough (idempotent):')\n  \n  // Create a static array type\n  const byteType = new ABIByteType()\n  const arrayType = new ABIArrayStaticType(byteType, 3)\n\n  // Start with a Uint8Array\n  const value = new Uint8Array([5, 6, 7])\n  console.log('Original:', value)\n\n  // Convert - should return the same instance\n  const result = convertAbiByteArrays(value, arrayType)\n  console.log('Converted:', result)\n  console.log('Is same instance:', result === value)\n}\n\n// Run all examples\nconvertStaticByteArray()\nconvertDynamicByteArray()\nhandleExistingUint8Array()\n\nconsole.log('\\n\u2713 All conversions completed successfully!')"
    },
    {
      "example_id": "27-create-algo-amounts-with-fluent-syntax",
      "title": "Create Algo Amounts with Fluent Syntax",
      "summary": "Explore different ways to create AlgoAmount instances, including the fluent Number.prototype.algo() extension method for more readable code.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "amount creation and conversion",
      "specific_use_case": "Create AlgoAmount instances using intuitive syntax for better code readability",
      "target_users": [
        "SDK developers",
        "Application developers"
      ],
      "features_tested": [
        "Number.prototype.algo",
        "AlgoAmount"
      ],
      "feature_tags": [
        "algo-amount",
        "fluent-api",
        "amount-creation",
        "syntactic-sugar",
        "type-safety"
      ],
      "folder": "27-create-algo-amounts-with-fluent-syntax",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Create a new TypeScript project or use an existing one"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk",
          "npm install -D typescript ts-node @types/node"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Created amount using fluent syntax:",
        "Type: AlgoAmount",
        "Value in Algos: 100",
        "Value in microAlgos: 100000000n",
        "Small amount (0.5 Algos):",
        "Value in Algos: 0.5",
        "Value in microAlgos: 500000n",
        "Large amount (1,000,000 Algos):",
        "Value in Algos: 1000000",
        "Value in microAlgos: 1000000000000n",
        "Practical usage:",
        "Payment amount: 50 Algos",
        "Minimum balance: 0.1 Algos",
        "Convenient access to both units:",
        "50 Algos = 50000000n microAlgos"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "algos via Number.prototype"
        }
      ],
      "artifacts_plan": [],
      "notes": "The .algo() extension method is syntactic sugar that makes code more readable. It's particularly useful when defining amounts inline in function calls or variable assignments. The AlgoAmount class handles conversions between Algos and microAlgos automatically.",
      "generated_code": "import { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport '@algorandfoundation/algokit-utils/types/amount'\n\n/**\n * This example demonstrates the fluent syntax for creating AlgoAmount instances.\n * \n * AlgoKit Utils extends the Number prototype with an .algo() method that provides\n * a more intuitive and readable way to create amount instances.\n */\n\n// Using the fluent Number.prototype.algo() extension method\n// This reads naturally as \"100 algos\"\nconst amount1 = (100).algo()\n\nconsole.log('Created amount using fluent syntax:')\nconsole.log('Type:', amount1.constructor.name)\nconsole.log('Value in Algos:', amount1.algo)\nconsole.log('Value in microAlgos:', amount1.microAlgo)\n\n// You can use this with any numeric value\nconst smallAmount = (0.5).algo()\nconsole.log('\\nSmall amount (0.5 Algos):')\nconsole.log('Value in Algos:', smallAmount.algo)\nconsole.log('Value in microAlgos:', smallAmount.microAlgo)\n\n// Works with larger amounts too\nconst largeAmount = (1000000).algo()\nconsole.log('\\nLarge amount (1,000,000 Algos):')\nconsole.log('Value in Algos:', largeAmount.algo)\nconsole.log('Value in microAlgos:', largeAmount.microAlgo)\n\n// The fluent syntax makes code more readable in practice\nconst paymentAmount = (50).algo()\nconst minimumBalance = (0.1).algo()\n\nconsole.log('\\nPractical usage:')\nconsole.log(`Payment amount: ${paymentAmount.algo} Algos`)\nconsole.log(`Minimum balance: ${minimumBalance.algo} Algos`)\n\n// All AlgoAmount instances provide both .algo and .microAlgo properties\nconsole.log('\\nConvenient access to both units:')\nconsole.log(`${paymentAmount.algo} Algos = ${paymentAmount.microAlgo} microAlgos`)"
    },
    {
      "example_id": "28-create-algoamount-using-number-prototype-extension",
      "title": "Create AlgoAmount Using Number Prototype Extension",
      "summary": "Demonstrates how to create AlgoAmount instances using the fluent Number.prototype.microAlgo() extension method for a more natural API syntax",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "amount creation and conversion",
      "specific_use_case": "Create an AlgoAmount using the Number.prototype.microAlgo() extension method for a more fluent syntax",
      "target_users": [
        "SDK developers",
        "Application developers"
      ],
      "features_tested": [
        "Number.prototype.microAlgo",
        "AlgoAmount"
      ],
      "feature_tags": [
        "amount",
        "microAlgos",
        "prototype-extension",
        "fluent-api",
        "type-conversion"
      ],
      "folder": "28-create-algoamount-using-number-prototype-extension",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils typescript ts-node"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Created AlgoAmount using (100).microAlgo():",
        "- Type: AlgoAmount",
        "- Value in microAlgos: 100",
        "- Value in Algos: 0.0001",
        "Large amount (1,000,000 microAlgos = 1 Algo):",
        "- microAlgos: 1000000",
        "- Algos: 1",
        "Small amount (50 microAlgos):",
        "- microAlgos: 50",
        "- Algos: 0.00005"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "microAlgos via Number.prototype"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example showcases the fluent API syntax for creating AlgoAmount instances. The Number.prototype.microAlgo() extension provides a more natural and readable way to express amounts compared to using constructor functions.",
      "generated_code": "import { AlgoAmount } from '@algorandfoundation/algokit-utils'\n\n/**\n * Demonstrates creating AlgoAmount instances using the Number prototype extension.\n * \n * The .microAlgo() method provides a fluent, chainable syntax for creating\n * AlgoAmount instances from numeric values.\n */\n\n// Create an AlgoAmount of 100 microAlgos using the prototype extension\nconst amount = (100).microAlgo()\n\nconsole.log('Created AlgoAmount using (100).microAlgo():')\nconsole.log('- Type:', amount.constructor.name)\nconsole.log('- Value in microAlgos:', amount.microAlgo.toString())\nconsole.log('- Value in Algos:', amount.algo.toString())\n\n// You can use any numeric value\nconst largeAmount = (1_000_000).microAlgo()\nconsole.log('\\nLarge amount (1,000,000 microAlgos = 1 Algo):')\nconsole.log('- microAlgos:', largeAmount.microAlgo.toString())\nconsole.log('- Algos:', largeAmount.algo.toString())\n\n// Works with decimals too (will be converted to microAlgos)\nconst smallAmount = (50).microAlgo()\nconsole.log('\\nSmall amount (50 microAlgos):')\nconsole.log('- microAlgos:', smallAmount.microAlgo.toString())\nconsole.log('- Algos:', smallAmount.algo.toString())"
    },
    {
      "example_id": "29-create-app-factory-with-constructor-deploy-time-parameters",
      "title": "Create App Factory with Constructor Deploy-Time Parameters",
      "summary": "Shows how to pre-configure deploy-time parameters in the factory constructor for cleaner deployment calls, useful when deploying multiple instances with the same configuration.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create an app factory with deploy-time parameters set in constructor",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.client.getAppFactory",
        "factory.send.bare.create",
        "deployTimeParams in constructor",
        "appClient access"
      ],
      "feature_tags": [
        "app-factory",
        "constructor-config",
        "deploy-time-params",
        "app-client",
        "app-deployment"
      ],
      "folder": "29-create-app-factory-with-constructor-deploy-time-parameters",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ACCOUNT_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded test account"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Setting up app factory with deploy-time parameters...",
        "Factory created with pre-configured parameters",
        "Deploying application...",
        "Application deployed successfully!",
        "App ID: <app-id>",
        "App Address: <app-address>",
        "Transaction ID: <txn-id>",
        "App Client details:",
        "App Client ID: <app-id>",
        "App Client matches result: true",
        "Ready to interact with the application using app.appClient",
        "Deploying multiple applications with same configuration...",
        "App 1 ID: <app-id-1>",
        "App 2 ID: <app-id-2>",
        "App 3 ID: <app-id-3> (with VALUE=42)",
        "All examples completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Create app with constructor deployTimeParams"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining the benefits of constructor-level configuration"
        }
      ],
      "notes": "This approach is particularly useful for deploying multiple instances with consistent configuration. Individual deployments can still override specific parameters as needed.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n// This example demonstrates how to configure deploy-time parameters\n// in the factory constructor for cleaner, reusable deployments\n\nasync function createFactoryWithConstructorParams() {\n  // Initialize the Algorand client for localnet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a test account with funds\n  const testAccount = await algorand.account.fromEnvironment('ACCOUNT')\n\n  console.log('Setting up app factory with deploy-time parameters...')\n\n  // Create an app factory with deploy-time parameters pre-configured\n  // This is useful when you want to deploy multiple instances with\n  // the same configuration\n  const factory = algorand.client.getAppFactory({\n    appSpec: './path/to/your/app-spec.json', // Replace with your actual app spec\n    defaultSender: testAccount.addr,\n    // Deploy-time parameters configured at factory creation\n    // These will be applied to all deployments unless overridden\n    deployTimeParams: {\n      UPDATABLE: 0,  // Makes all deployed apps non-updatable\n      DELETABLE: 0,  // Makes all deployed apps non-deletable\n      VALUE: 1,      // Custom parameter for your contract\n    },\n  })\n\n  console.log('Factory created with pre-configured parameters')\n  console.log('\\nDeploying application...')\n\n  // Create the application using the pre-configured factory\n  // Notice we don't need to specify deployTimeParams again\n  const app = await factory.send.bare.create()\n\n  // Log the application details\n  console.log('\\nApplication deployed successfully!')\n  console.log('App ID:', app.result.appId.toString())\n  console.log('App Address:', app.result.appAddress)\n  console.log('Transaction ID:', app.result.txIds[0])\n\n  // The factory automatically creates an app client for interaction\n  console.log('\\nApp Client details:')\n  console.log('App Client ID:', app.appClient.appId.toString())\n  console.log('App Client matches result:', app.appClient.appId === app.result.appId)\n\n  // You can use the app client for subsequent interactions\n  console.log('\\nReady to interact with the application using app.appClient')\n\n  return { factory, app }\n}\n\n// Example: Deploy multiple apps with the same configuration\nasync function deployMultipleApps() {\n  const algorand = AlgorandClient.defaultLocalNet()\n  const testAccount = await algorand.account.fromEnvironment('ACCOUNT')\n\n  // Create a factory with shared configuration\n  const factory = algorand.client.getAppFactory({\n    appSpec: './path/to/your/app-spec.json',\n    defaultSender: testAccount.addr,\n    deployTimeParams: {\n      UPDATABLE: 0,\n      DELETABLE: 0,\n      VALUE: 1,\n    },\n  })\n\n  console.log('\\nDeploying multiple applications with same configuration...')\n\n  // Deploy first app\n  const app1 = await factory.send.bare.create()\n  console.log('App 1 ID:', app1.result.appId.toString())\n\n  // Deploy second app with same configuration\n  const app2 = await factory.send.bare.create()\n  console.log('App 2 ID:', app2.result.appId.toString())\n\n  // Deploy third app, but override the VALUE parameter\n  const app3 = await factory.send.bare.create({\n    deployTimeParams: {\n      VALUE: 42, // Override just this parameter\n    },\n  })\n  console.log('App 3 ID:', app3.result.appId.toString(), '(with VALUE=42)')\n\n  return [app1, app2, app3]\n}\n\n// Run the examples\nasync function main() {\n  await createFactoryWithConstructorParams()\n  await deployMultipleApps()\n}\n\nmain()\n  .then(() => {\n    console.log('\\nAll examples completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "30-create-application-with-abi-method",
      "title": "Create Application with ABI Method",
      "summary": "Shows how to create an app with custom initialization logic via ABI methods, including passing arguments and receiving return values during deployment.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create an application using an ABI method directly from factory",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.send.create",
        "ABI create method",
        "return value handling",
        "deployment parameters"
      ],
      "feature_tags": [
        "app-deployment",
        "abi-method",
        "return-values",
        "app-factory",
        "initialization"
      ],
      "folder": "30-create-application-with-abi-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded deployer account"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application created successfully with app ID",
        "Return value from create_abi method displayed",
        "Transaction confirmation details shown",
        "Return value matches the input argument"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Create app with abi"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Standard TypeScript project configuration"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript compiler configuration"
        },
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Application specification with create_abi method that accepts a string and returns it"
        },
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining ABI creation methods and deployment parameters"
        }
      ],
      "notes": "This example demonstrates the preferred way to create apps with initialization logic. The create_abi method in the smart contract can perform setup operations, validate inputs, and return values. Deployment parameters (UPDATABLE, DELETABLE, VALUE) are template variables replaced during compilation.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { consoleLogger } from '@algorandfoundation/algokit-utils/types/logging'\n\n/**\n * This example demonstrates how to create an Algorand application\n * using an ABI method for initialization.\n * \n * Benefits of using ABI methods for app creation:\n * - Custom initialization logic in the smart contract\n * - Pass parameters during creation\n * - Receive return values from the creation method\n * - Type-safe method calls with the ABI\n * \n * This approach is more flexible than bare application creation\n * when you need to set up state or perform logic during deployment.\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get a funded deployer account\n  const deployer = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Deployer account:', deployer.addr)\n\n  // Create an app factory from your application specification\n  // Replace this with your actual app spec\n  const factory = algorand.client.getTypedAppFactory(/* Your app spec here */)\n\n  console.log('\\nCreating application with ABI method...')\n  \n  // Create the application using an ABI method\n  // This calls the 'create_abi' method defined in your smart contract\n  const { result: call, appClient } = await factory.send.create({\n    // Deployment-time template parameters\n    // These are replaced in the TEAL code during compilation\n    deployTimeParams: {\n      UPDATABLE: 0,  // App cannot be updated after creation\n      DELETABLE: 0,  // App cannot be deleted\n      VALUE: 1,      // Custom initial value\n    },\n    \n    // Specify which ABI method to call for creation\n    method: 'create_abi',\n    \n    // Arguments to pass to the create method\n    args: ['string_io'],\n  })\n\n  console.log('\u2713 Application created successfully!')\n  console.log('  App ID:', appClient.appId)\n  console.log('  App Address:', appClient.appAddress)\n\n  // Access the return value from the ABI method\n  if (call.return) {\n    console.log('\\n\ud83d\udce4 Method Return Value:')\n    console.log('  Type:', typeof call.return)\n    console.log('  Value:', call.return)\n    \n    // Verify the return value matches what we sent\n    if (call.return === 'string_io') {\n      console.log('  \u2713 Return value matches input!')\n    }\n  }\n\n  // Display transaction details\n  console.log('\\n\ud83d\udccb Transaction Details:')\n  console.log('  Transaction ID:', call.transaction.txID())\n  console.log('  Confirmed Round:', call.confirmation?.confirmedRound)\n  console.log('  Sender:', call.transaction.from?.toString())\n\n  console.log('\\n\u2713 App created with custom initialization logic!')\n  console.log('The create_abi method ran during deployment, allowing for')\n  console.log('custom setup logic and return value handling.')\n}\n\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "31-create-application-with-custom-oncomplete-action",
      "title": "Create Application with Custom OnComplete Action",
      "summary": "Demonstrates how to create an Algorand application with a custom onComplete action (opt-in) during creation, allowing the creator to opt into the app in the same transaction.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create an application with a custom onComplete action (opt-in)",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algokit.getAppClient",
        "client.create",
        "onCompleteAction parameter",
        "OnApplicationComplete.OptInOC",
        "deployTimeParams",
        "updatable and deletable flags"
      ],
      "feature_tags": [
        "app-client",
        "app-creation",
        "oncomplete-action",
        "opt-in",
        "deployment",
        "typescript"
      ],
      "folder": "31-create-application-with-custom-oncomplete-action",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have an app specification file (appSpec)"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application created successfully",
        "App ID: <positive number>",
        "App Address: <algorand address>",
        "OnComplete action: OptIn",
        "Application is updatable and deletable"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Create app with oncomplete overload"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "A simple app specification file for demonstration"
        }
      ],
      "notes": "This example shows how to use the onCompleteAction parameter to opt into an application during its creation. This is useful when you want to combine creation and opt-in in a single transaction.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport { OnApplicationComplete, getApplicationAddress } from 'algosdk'\n\n// Import the app specification\nimport appSpec from './app-spec.json'\n\nasync function createAppWithOptIn() {\n  // Get AlgoKit configuration for LocalNet\n  const algod = algokit.getAlgoClient({\n    server: 'http://localhost',\n    port: 4001,\n    token: 'a'.repeat(64),\n  })\n\n  const indexer = algokit.getAlgoIndexerClient({\n    server: 'http://localhost',\n    port: 8980,\n    token: 'a'.repeat(64),\n  })\n\n  // Get a test account from LocalNet\n  const testAccount = await algokit.getLocalNetDispenserAccount(algod)\n\n  console.log('Creating app client...')\n  // Create an app client that resolves by creator address and app name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: testAccount,\n      creatorAddress: testAccount.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  console.log('Creating application with opt-in action...')\n  // Create the application with a custom onComplete action\n  // Using 'opt_in' means the creator will opt into the app during creation\n  const app = await client.create({\n    // Set onComplete action to opt-in instead of the default NoOp\n    onCompleteAction: 'opt_in',\n    // Allow the app to be updated later\n    updatable: true,\n    // Allow the app to be deleted later\n    deletable: true,\n    // Set deploy-time parameters\n    deployTimeParams: {\n      VALUE: 1,\n    },\n  })\n\n  // Display the results\n  console.log('\\n=== Application Created Successfully ===')\n  console.log(`App ID: ${app.appId}`)\n  console.log(`App Address: ${app.appAddress}`)\n  console.log(`OnComplete Action: ${app.transaction.applicationCall?.onComplete === OnApplicationComplete.OptInOC ? 'OptIn' : 'Unknown'}`)\n  console.log(`Application Index: ${app.confirmation?.applicationIndex}`)\n  console.log(`Updatable: true`)\n  console.log(`Deletable: true`)\n\n  // Verify the app address matches the expected address for the app ID\n  const expectedAddress = getApplicationAddress(app.appId).toString()\n  console.log(`\\nAddress verification: ${app.appAddress === expectedAddress ? 'PASSED' : 'FAILED'}`)\n\n  return app\n}\n\n// Run the example\ncreateAppWithOptIn()\n  .then(() => {\n    console.log('\\nExample completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "32-create-application-with-custom-oncomplete-action-optin",
      "title": "Create Application with Custom OnComplete Action (OptIn)",
      "summary": "Demonstrates how to create an Algorand application with a custom onComplete action, specifically OptIn, which is useful for apps requiring local state and user opt-in on creation.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create an application with a custom onComplete action (OptIn)",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.send.bare.create",
        "OnApplicationComplete.OptInOC",
        "onComplete parameter",
        "updatable flag",
        "deletable flag"
      ],
      "feature_tags": [
        "app-creation",
        "optin",
        "oncomplete",
        "local-state",
        "updatable-app",
        "deletable-app"
      ],
      "folder": "32-create-application-with-custom-oncomplete-action-optin",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ACCOUNT_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded test account"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating application with OptIn onComplete action...",
        "Creator account: <account-address>",
        "Application created successfully with OptIn!",
        "App ID: <app-id>",
        "App Address: <app-address>",
        "Transaction ID: <txn-id>",
        "Transaction details:",
        "OnComplete action: 1",
        "Is OptIn: true",
        "OptIn value: 1",
        "Verifying app address...",
        "App Address: <app-address>",
        "Derived Address: <app-address>",
        "Addresses match: true",
        "Confirmation details:",
        "Application Index: <app-id>",
        "Confirmed Round: <round-number>",
        "The creator account is now opted-in to the application!",
        "The app is updatable and deletable by the creator.",
        "--- Demonstrating different OnComplete actions ---",
        "1. Creating app with NoOp (default)...",
        "   App ID: <app-id-1>",
        "   OnComplete: undefined (defaults to NoOp)",
        "2. Creating app with OptIn...",
        "   App ID: <app-id-2>",
        "   OnComplete: 1",
        "   Creator is now opted-in!",
        "Key difference:",
        "- NoOp: App is created, but creator is NOT opted-in",
        "- OptIn: App is created AND creator IS opted-in (can store local state)",
        "All examples completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Create app with oncomplete overload"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining OnComplete actions and when to use OptIn vs NoOp"
        }
      ],
      "notes": "Using OptIn on creation is particularly useful for applications that require local state. The creator is automatically opted-in, eliminating the need for a separate opt-in transaction. The updatable and deletable flags provide flexibility during development and testing.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { OnApplicationComplete, getApplicationAddress } from 'algosdk'\n\n// This example demonstrates how to create an application with a custom\n// onComplete action. Using OptIn on creation is useful for apps that\n// require local state and want the creator to automatically opt-in.\n\nasync function createAppWithOptInOnComplete() {\n  // Initialize the Algorand client for localnet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a test account with funds\n  const account = await algorand.account.fromEnvironment('ACCOUNT')\n\n  // Create an app factory instance\n  const factory = algorand.client.getAppFactory({\n    appSpec: './path/to/your/app-spec.json', // Replace with your actual app spec\n    defaultSender: account.addr,\n  })\n\n  console.log('Creating application with OptIn onComplete action...')\n  console.log('Creator account:', account.addr)\n\n  // Create the application with OptIn as the onComplete action\n  // This means the creator will automatically opt-in to the app during creation\n  const { result: app } = await factory.send.bare.create({\n    // Set the onComplete action to OptIn\n    // This is particularly useful for apps with local state where the\n    // creator needs to be opted-in immediately\n    onComplete: OnApplicationComplete.OptInOC,\n\n    // Allow the app to be updated by its creator\n    updatable: true,\n\n    // Allow the app to be deleted by its creator\n    deletable: true,\n\n    // Deploy-time parameters for the contract\n    deployTimeParams: {\n      VALUE: 1,\n    },\n  })\n\n  // Log the application details\n  console.log('\\nApplication created successfully with OptIn!')\n  console.log('App ID:', app.appId.toString())\n  console.log('App Address:', app.appAddress)\n  console.log('Transaction ID:', app.txIds[0])\n\n  // Verify the onComplete action in the transaction\n  if (app.transaction.applicationCall?.onComplete !== undefined) {\n    const onCompleteValue = app.transaction.applicationCall.onComplete\n    console.log('\\nTransaction details:')\n    console.log('OnComplete action:', onCompleteValue)\n    console.log('Is OptIn:', onCompleteValue === OnApplicationComplete.OptInOC)\n\n    // OnApplicationComplete enum values:\n    // NoOpOC = 0,\n    // OptInOC = 1,\n    // CloseOutOC = 2,\n    // ClearStateOC = 3,\n    // UpdateApplicationOC = 4,\n    // DeleteApplicationOC = 5\n    console.log('OptIn value:', OnApplicationComplete.OptInOC)\n  }\n\n  // Verify the app address is correctly derived from the app ID\n  const derivedAddress = getApplicationAddress(app.appId)\n  console.log('\\nVerifying app address...')\n  console.log('App Address:', app.appAddress)\n  console.log('Derived Address:', derivedAddress)\n  console.log('Addresses match:', app.appAddress === derivedAddress)\n\n  // The confirmation contains the application index\n  if (app.confirmation) {\n    console.log('\\nConfirmation details:')\n    console.log('Application Index:', app.confirmation.applicationIndex?.toString())\n    console.log('Confirmed Round:', app.confirmation.confirmedRound)\n  }\n\n  console.log('\\nThe creator account is now opted-in to the application!')\n  console.log('The app is updatable and deletable by the creator.')\n\n  return app\n}\n\n// Example: Understanding different OnComplete actions\nasync function demonstrateOnCompleteActions() {\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.fromEnvironment('ACCOUNT')\n\n  const factory = algorand.client.getAppFactory({\n    appSpec: './path/to/your/app-spec.json',\n    defaultSender: account.addr,\n  })\n\n  console.log('\\n--- Demonstrating different OnComplete actions ---\\n')\n\n  // 1. Create with NoOp (default)\n  console.log('1. Creating app with NoOp (default)...')\n  const app1 = await factory.send.bare.create({\n    deployTimeParams: { VALUE: 1 },\n    updatable: true,\n    deletable: true,\n  })\n  console.log('   App ID:', app1.result.appId.toString())\n  console.log('   OnComplete:', app1.result.transaction.applicationCall?.onComplete ?? 'undefined (defaults to NoOp)')\n\n  // 2. Create with OptIn\n  console.log('\\n2. Creating app with OptIn...')\n  const app2 = await factory.send.bare.create({\n    onComplete: OnApplicationComplete.OptInOC,\n    deployTimeParams: { VALUE: 1 },\n    updatable: true,\n    deletable: true,\n  })\n  console.log('   App ID:', app2.result.appId.toString())\n  console.log('   OnComplete:', app2.result.transaction.applicationCall?.onComplete)\n  console.log('   Creator is now opted-in!')\n\n  console.log('\\nKey difference:')\n  console.log('- NoOp: App is created, but creator is NOT opted-in')\n  console.log('- OptIn: App is created AND creator IS opted-in (can store local state)')\n}\n\n// Run the examples\nasync function main() {\n  await createAppWithOptInOnComplete()\n  await demonstrateOnCompleteActions()\n}\n\nmain()\n  .then(() => {\n    console.log('\\nAll examples completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "33-create-an-algorand-application",
      "title": "Create an Algorand Application",
      "summary": "Demonstrates how to deploy a new Algorand application with approval and clear state programs, and verify the deployment",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create a new Algorand application with approval and clear state programs",
      "target_users": [
        "Smart contract developers",
        "SDK developers",
        "Algorand developers"
      ],
      "features_tested": [
        "algorand.send.appCreate",
        "algosdk.getApplicationAddress"
      ],
      "feature_tags": [
        "app-creation",
        "smart-contracts",
        "deployment",
        "approval-program",
        "clear-state-program",
        "state-schema",
        "app-address"
      ],
      "folder": "33-create-an-algorand-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Deploying application from account address",
        "Creating application message",
        "Application created successfully with app ID",
        "App address derived from app ID",
        "Transaction ID and confirmation",
        "App address verification result"
      ],
      "source_tests": [
        {
          "file": "src/app.spec.ts",
          "test_name": "appCreate creates an app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple approval program for demonstration"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple clear state program for demonstration"
        }
      ],
      "notes": "This is a foundational example for deploying Algorand smart contracts. The example uses simple TEAL programs for demonstration. In production, you would use more complex business logic.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to create (deploy) a new Algorand application.\n * \n * It covers:\n * - Loading approval and clear state programs\n * - Configuring state schema\n * - Deploying the application\n * - Verifying the app ID and deriving the app address\n */\n\nasync function createApplication() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a funded test account from the LocalNet dispenser\n  const sender = await algorand.account.localNet.dispenser()\n  console.log('Deploying application from account:', sender.addr)\n\n  // For this example, we'll use a simple application\n  // In practice, you would compile your TEAL source code\n  const approvalProgram = `\n#pragma version 8\nint 1\nreturn\n  `\n\n  const clearStateProgram = `\n#pragma version 8\nint 1\nreturn\n  `\n\n  // Compile the programs\n  const approvalCompiled = await algorand.app.compileTeal(approvalProgram)\n  const clearCompiled = await algorand.app.compileTeal(clearStateProgram)\n\n  // Define the state schema (storage requirements)\n  const schema = {\n    globalUints: 1,      // Number of global uint64 values\n    globalByteSlices: 1, // Number of global byte slice values\n    localUints: 0,       // Number of local uint64 values per account\n    localByteSlices: 0,  // Number of local byte slice values per account\n  }\n\n  console.log('\\nCreating application...')\n\n  // Create the application\n  const app = await algorand.send.appCreate({\n    approvalProgram: approvalCompiled,\n    clearStateProgram: clearCompiled,\n    schema: schema,\n    sender: sender,\n  })\n\n  // Display results\n  console.log('\\n\u2705 Application created successfully!')\n  console.log('App ID:', app.appId.toString())\n  console.log('App Address:', app.appAddress)\n  console.log('Transaction ID:', app.txIds[0])\n  console.log('Confirmation Round:', app.confirmation?.confirmedRound)\n\n  // Verify the app address matches the expected address derived from app ID\n  const expectedAddress = algosdk.getApplicationAddress(app.appId)\n  console.log('\\n\u2713 App address verification:', app.appAddress === expectedAddress ? 'PASSED' : 'FAILED')\n\n  return app\n}\n\n// Run the example\ncreateApplication()\n  .then(() => console.log('\\nExample completed successfully'))\n  .catch((error) => {\n    console.error('Error:', error.message)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "34-create-an-algorand-application-with-deploy-time-parameters",
      "title": "Create an Algorand Application with Deploy-Time Parameters",
      "summary": "Demonstrates how to create an Algorand application using the factory pattern with deploy-time template parameters, showing how to configure immutable settings at deployment time.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create a new application with deploy-time parameters",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.send.bare.create",
        "getApplicationAddress",
        "deployTimeParams",
        "template variables"
      ],
      "feature_tags": [
        "app-creation",
        "deploy-time-params",
        "template-variables",
        "app-factory",
        "app-address"
      ],
      "folder": "34-create-an-algorand-application-with-deploy-time-parameters",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ACCOUNT_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded test account"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating application with deploy-time parameters...",
        "Application created successfully!",
        "App ID: <app-id>",
        "App Address: <app-address>",
        "Transaction ID: <txn-id>",
        "Verifying app address...",
        "Derived address matches: true",
        "Confirmation details:",
        "Application Index: <app-id>",
        "Confirmed Round: <round-number>",
        "Example completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Create app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "README.md",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining deploy-time parameters and how to use your own app spec"
        }
      ],
      "notes": "Users need to replace the app spec path with their actual contract specification. Deploy-time parameters must match the template variables defined in their TEAL contract.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { getApplicationAddress } from 'algosdk'\n\n// This example demonstrates how to create an Algorand application\n// with deploy-time parameters using the factory pattern\n\nasync function createAppWithDeployTimeParams() {\n  // Initialize the Algorand client for localnet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a test account with funds\n  const account = await algorand.account.fromEnvironment('ACCOUNT')\n\n  // Create an app factory instance\n  // The appSpec defines your smart contract interface and should be imported\n  // from your contract artifacts (e.g., './artifacts/MyContract.arc32.json')\n  const factory = algorand.client.getAppFactory({\n    appSpec: './path/to/your/app-spec.json', // Replace with your actual app spec\n    defaultSender: account.addr,\n  })\n\n  console.log('Creating application with deploy-time parameters...')\n\n  // Create the application with deploy-time parameters\n  // Deploy-time parameters allow you to set immutable configuration values\n  // when the contract is deployed\n  const { result: app } = await factory.send.bare.create({\n    deployTimeParams: {\n      // The TMPL_ prefix is automatically stripped during deployment\n      TMPL_UPDATABLE: 0, // Makes the app non-updatable\n      DELETABLE: 0,      // Makes the app non-deletable\n      VALUE: 1,          // Custom parameter specific to your contract\n    },\n  })\n\n  // Log the application details\n  console.log('\\nApplication created successfully!')\n  console.log('App ID:', app.appId.toString())\n  console.log('App Address:', app.appAddress)\n  console.log('Transaction ID:', app.txIds[0])\n\n  // Verify the app address is correctly derived from the app ID\n  const derivedAddress = getApplicationAddress(app.appId)\n  console.log('\\nVerifying app address...')\n  console.log('Derived address matches:', app.appAddress === derivedAddress)\n\n  // The confirmation contains the application index\n  if (app.confirmation) {\n    console.log('\\nConfirmation details:')\n    console.log('Application Index:', app.confirmation.applicationIndex?.toString())\n    console.log('Confirmed Round:', app.confirmation.confirmedRound)\n  }\n\n  return app\n}\n\n// Run the example\ncreateAppWithDeployTimeParams()\n  .then(() => {\n    console.log('\\nExample completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "35-create-an-algorand-standard-asset-asa",
      "title": "Create an Algorand Standard Asset (ASA)",
      "summary": "Demonstrates how to create a new Algorand Standard Asset (ASA) with a specified total supply and verify the asset was created successfully.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Create a new Algorand Standard Asset with a specified total supply",
      "target_users": [
        "SDK developers",
        "Token creators",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.send.assetCreate"
      ],
      "feature_tags": [
        "asset-creation",
        "asa",
        "token",
        "send",
        "asset-management"
      ],
      "folder": "35-create-an-algorand-standard-asset-asa",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALICE_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Ensure LocalNet is running and funded accounts are available"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created successfully with a valid asset ID > 0",
        "Transaction ID of the asset creation transaction",
        "Confirmation that the asset was created on the blockchain"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "sendAssetCreate"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the simplest way to create an ASA. Additional parameters like asset name, unit name, decimals, URL, and metadata hash can be added for more complex assets.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils'\n\n// Configure AlgoKit to use LocalNet\nConfig.configure({ debug: true })\n\nasync function createAsset() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a funded account (in LocalNet, we can use a dispenser account)\n  const alice = await algorand.account.fromEnvironment('ALICE')\n\n  console.log('Creating a new Algorand Standard Asset...')\n  console.log(`Creator account: ${alice.addr}`)\n\n  // Create a new asset with a total supply of 100 units\n  const createResult = await algorand.send.assetCreate({\n    sender: alice,\n    total: 100n, // Total supply of 100 units\n  })\n\n  // The assetId is automatically assigned by the blockchain\n  console.log(`\\n\u2713 Asset created successfully!`)\n  console.log(`Asset ID: ${createResult.assetId}`)\n  console.log(`Transaction ID: ${createResult.txIds[0]}`)\n\n  // Verify the asset was created (assetId should be greater than 0)\n  if (createResult.assetId > 0) {\n    console.log(`\\n\u2713 Verification passed: Asset ID ${createResult.assetId} is valid`)\n  }\n\n  return createResult.assetId\n}\n\n// Run the example\ncreateAsset().catch(console.error)"
    },
    {
      "example_id": "36-create-and-call-application-methods",
      "title": "Create and Call Application Methods",
      "summary": "Demonstrates the typical workflow of creating an Algorand application and then calling ABI methods on it, including how to work with return values.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call an ABI method on a newly created application",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.send.bare.create",
        "appClient.send.call",
        "ABI method call",
        "return value handling",
        "deployTimeParams"
      ],
      "feature_tags": [
        "app-creation",
        "abi-methods",
        "method-call",
        "app-client",
        "return-values",
        "basic-workflow"
      ],
      "folder": "36-create-and-call-application-methods",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure your smart contract has a 'call_abi' method that accepts a string and returns a string"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application created with specific ID and address",
        "ABI method 'call_abi' called with argument 'test'",
        "Return value received: 'Hello, test'",
        "Explanation of key concepts and use cases"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Create then call app"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the most basic and common workflow. The app is created with bare.create() (no ABI method), then subsequent calls use ABI methods. Your smart contract should implement the 'call_abi' method that accepts a string parameter.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\n\n/**\n * This example demonstrates the fundamental workflow of:\n * 1. Creating an Algorand application using a factory\n * 2. Calling an ABI method on the created application\n * 3. Working with return values from ABI methods\n * \n * This is one of the most common patterns you'll use when working\n * with Algorand smart contracts.\n */\n\nasync function createAndCallAppExample() {\n  // Set up the testing environment with LocalNet\n  const localnet = await algorandFixture()\n  const { testAccount } = localnet.context\n\n  // Create a factory instance for your application\n  // The factory handles app deployment and creates typed clients\n  const factory = localnet.algorand.client.getTypedAppFactory({\n    // Your app specification would go here\n    // It should define the 'call_abi' method used below\n  })\n\n  console.log('Step 1: Create the application')\n  console.log('  Deploying with bare create (no ABI method)...')\n  \n  const { appClient } = await factory.send.bare.create({\n    deployTimeParams: {\n      UPDATABLE: 0,  // App cannot be updated\n      DELETABLE: 0,  // App cannot be deleted\n      VALUE: 1,      // Initial value parameter\n    },\n  })\n\n  console.log(`\u2713 Application created successfully!`)\n  console.log(`  App ID: ${appClient.appId}`)\n  console.log(`  App Address: ${appClient.appAddress}`)\n\n  console.log('\\nStep 2: Call an ABI method on the application')\n  console.log('  Calling call_abi method with argument \"test\"...')\n  \n  // Call the ABI method on the created app\n  const call = await appClient.send.call({\n    method: 'call_abi',\n    args: ['test'], // Method arguments\n  })\n\n  // Check and display the return value\n  if (call.return) {\n    console.log(`\\n\u2713 Method call successful!`)\n    console.log(`  Method: call_abi`)\n    console.log(`  Input argument: \"test\"`)\n    console.log(`  Return value: \"${call.return}\"`)\n  } else {\n    console.log('\\n\u26a0\ufe0f  Method returned no value')\n  }\n\n  console.log('\\n\u2139\ufe0f  Key Concepts:')\n  console.log('  \u2022 factory.send.bare.create(): Creates app without calling an ABI method')\n  console.log('  \u2022 appClient: Typed client for interacting with your specific app')\n  console.log('  \u2022 appClient.send.call(): Invokes ABI methods on the deployed app')\n  console.log('  \u2022 return: Contains the decoded return value from the ABI method')\n\n  console.log('\\n\ud83d\udcdd Common Use Cases:')\n  console.log('  \u2022 Initialize app state after creation')\n  console.log('  \u2022 Query app state with read-only methods')\n  console.log('  \u2022 Execute app logic that modifies state')\n  console.log('  \u2022 Chain multiple method calls in a workflow')\n}\n\n// Run the example\ncreateAndCallAppExample()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "37-create-and-call-an-application",
      "title": "Create and Call an Application",
      "summary": "Demonstrates the basic workflow of creating an Algorand application and then calling an ABI method on it",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app interaction",
      "specific_use_case": "Create an application and then call an ABI method on it",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.create",
        "client.call",
        "ABI method calls",
        "return value decoding",
        "deployTimeParams"
      ],
      "feature_tags": [
        "app-client",
        "create",
        "call",
        "abi-methods",
        "return-values",
        "basic-workflow"
      ],
      "folder": "37-create-and-call-an-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have a compiled app spec JSON file with an ABI method (call_abi)"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with specific deploy-time parameters",
        "App ID and address are logged",
        "ABI method 'call_abi' is called with argument 'test'",
        "Method returns 'Hello, test'",
        "Return value is decoded and logged"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Create then call app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample app spec with ABI method (call_abi) that takes a string and returns a greeting"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        }
      ],
      "notes": "This is a foundational example showing the essential pattern of creating an app and calling methods on it. Good starting point for developers new to AlgoKit Utils.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport appSpec from './contract.json'\n\n/**\n * This example demonstrates the basic workflow of creating an Algorand\n * application and then calling an ABI method on it.\n * \n * This is the foundational pattern for interacting with smart contracts\n * on Algorand using AlgoKit Utils.\n */\n\nasync function createAndCallApp() {\n  // Setup algod client for LocalNet\n  const algodClient = algokit.getAlgoClient(\n    algokit.getAlgoNodeConfig('algod', 'localnet')\n  )\n\n  // Get a test account with funds from the LocalNet dispenser\n  const account = await algokit.getLocalNetDispenserAccount(algodClient)\n\n  console.log('Account address:', account.addr)\n  console.log('\\n--- Step 1: Create the application ---')\n\n  // Create an app client with resolveBy: 'id' and id: 0 to create a new app\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      app: appSpec,\n      sender: account,\n      id: 0, // id: 0 indicates we want to create a new app\n    },\n    algodClient\n  )\n\n  // Create the application with deploy-time parameters\n  // These parameters configure the app's behavior at creation time\n  const createResult = await client.create({\n    deployTimeParams: {\n      UPDATABLE: 0,  // App cannot be updated\n      DELETABLE: 0,  // App cannot be deleted\n      VALUE: 1,      // Custom parameter for your app logic\n    },\n  })\n\n  console.log('Application created successfully!')\n  console.log('  App ID:', client.appId)\n  console.log('  App Address:', client.appAddress)\n  console.log('  Transaction ID:', createResult.transaction.txID())\n\n  console.log('\\n--- Step 2: Call an ABI method on the app ---')\n\n  // Call an ABI method on the created application\n  // The method 'call_abi' takes a string argument and returns a greeting\n  const callResult = await client.call({\n    method: 'call_abi',\n    methodArgs: ['test'], // Pass 'test' as the argument\n  })\n\n  console.log('Method call successful!')\n  console.log('  Transaction ID:', callResult.transaction.txID())\n\n  // Decode and display the return value\n  if (callResult.return) {\n    console.log('\\nReturn value from ABI method:')\n    console.log('  Raw return:', callResult.return.returnValue)\n    console.log('  Decoded value:', callResult.return.returnValue)\n    \n    // Verify no decode errors occurred\n    if (callResult.return.decodeError) {\n      console.error('  Decode error:', callResult.return.decodeError)\n    } else {\n      console.log('  \u2713 No decode errors')\n    }\n  }\n\n  console.log('\\n--- Summary ---')\n  console.log('This example showed the basic pattern:')\n  console.log('  1. Create an app client with id: 0')\n  console.log('  2. Call client.create() with deploy-time parameters')\n  console.log('  3. Call client.call() with method name and arguments')\n  console.log('  4. Access return values from the method call')\n}\n\n// Run the example\ncreateAndCallApp().catch(console.error)\n"
    },
    {
      "example_id": "38-create-and-retrieve-accounts-from-environment",
      "title": "Create and Retrieve Accounts from Environment",
      "summary": "Demonstrates how to create new accounts dynamically using fromEnvironment, verify automatic funding, and understand idempotent account retrieval.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Create new accounts dynamically with automatic funding and retrieve them idempotently",
      "target_users": [
        "SDK developers",
        "dApp developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.account.fromEnvironment",
        "algorand.account.getInformation"
      ],
      "feature_tags": [
        "account-creation",
        "account-funding",
        "account-retrieval",
        "account-management",
        "idempotency",
        "balance-verification"
      ],
      "folder": "38-create-and-retrieve-accounts-from-environment",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure the dispenser is available for automatic funding"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "First account created with a unique identifier",
        "Account address displayed",
        "Account balance shown (greater than 0, indicating successful funding)",
        "Second account created and retrieved twice",
        "Comparison showing same address and keys but different object instances",
        "Educational output explaining idempotent account retrieval behavior"
      ],
      "source_tests": [
        {
          "file": "src/types/account-manager.spec.ts",
          "test_name": "New account is retrieved and funded"
        },
        {
          "file": "src/types/account-manager.spec.ts",
          "test_name": "Same account is subsequently retrieved"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines two related test cases into a single comprehensive example. The fromEnvironment method is particularly useful on LocalNet and TestNet where automatic funding is available. In production, you would typically set environment variables with existing account mnemonics rather than relying on automatic account creation.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { randomUUID } from 'crypto'\n\n/**\n * This example demonstrates how to create and manage accounts using fromEnvironment.\n * \n * Key features:\n * 1. Create a new account with automatic funding (on LocalNet/TestNet)\n * 2. Verify the account is funded by checking its balance\n * 3. Retrieve the same account multiple times (idempotent retrieval)\n * 4. Understand that multiple retrievals return the same keys but different object instances\n * \n * Use case: Essential for applications that need to manage multiple accounts dynamically.\n */\n\nasync function main() {\n  // Initialize the AlgorandClient for LocalNet\n  // Note: fromEnvironment with auto-funding works on LocalNet and TestNet with a dispenser\n  const algorand = AlgorandClient.testNet() // or AlgorandClient.mainNet() for production\n  \n  console.log('=== Example 1: Create and Fund a New Account ===')\n  \n  // Generate a unique identifier for the account\n  // This could be any string - in production, you might use user IDs, session IDs, etc.\n  const accountName = randomUUID()\n  console.log('\\nCreating account with identifier:', accountName)\n  \n  // Create an account from environment\n  // If the environment variable doesn't exist, a new account is created and funded automatically\n  // On LocalNet/TestNet, this will request funds from the dispenser\n  const account = await algorand.account.fromEnvironment(accountName)\n  console.log('Account created with address:', account.addr)\n  \n  // Get account information to verify it exists and is funded\n  const accountInfo = await algorand.account.getInformation(account.addr)\n  console.log('Account balance:', accountInfo.balance.microAlgo, 'microAlgos')\n  console.log('Account balance:', Number(accountInfo.balance.microAlgo) / 1_000_000, 'Algos')\n  \n  if (accountInfo.balance.microAlgo > 0) {\n    console.log('\u2713 Account is successfully funded!')\n  }\n  \n  console.log('\\n=== Example 2: Idempotent Account Retrieval ===')\n  \n  // Generate another unique identifier\n  const secondAccountName = randomUUID()\n  console.log('\\nCreating account with identifier:', secondAccountName)\n  \n  // Retrieve the account for the first time\n  const firstRetrieval = await algorand.account.fromEnvironment(secondAccountName)\n  console.log('First retrieval - Address:', firstRetrieval.addr)\n  \n  // Retrieve the same account again using the same identifier\n  const secondRetrieval = await algorand.account.fromEnvironment(secondAccountName)\n  console.log('Second retrieval - Address:', secondRetrieval.addr)\n  \n  // Compare the results\n  console.log('\\nComparison:')\n  console.log('Are they the same object instance?', firstRetrieval === secondRetrieval)\n  console.log('Do they have the same address?', firstRetrieval.addr === secondRetrieval.addr)\n  console.log('Do they have the same secret key?', \n    Buffer.from(firstRetrieval.account.sk).equals(Buffer.from(secondRetrieval.account.sk)))\n  \n  console.log('\\n\u2713 Idempotent retrieval confirmed!')\n  console.log('  - Different object instances (not cached)')\n  console.log('  - Same cryptographic keys (deterministic generation)')\n  \n  console.log('\\n=== Key Takeaways ===')\n  console.log('1. fromEnvironment creates and funds accounts automatically on LocalNet/TestNet')\n  console.log('2. Using the same identifier retrieves the same account keys')\n  console.log('3. Each call returns a new object instance with the same underlying keys')\n  console.log('4. This is useful for managing multiple accounts in your application')\n  console.log('5. In production, set environment variables to use existing accounts')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "39-create-and-update-application-with-abi-methods",
      "title": "Create and Update Application with ABI Methods",
      "summary": "Demonstrates how to create and update an Algorand application using ABI methods, including handling return values and deploy-time parameters.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create and update an application using ABI methods with return value handling",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.create",
        "client.update",
        "ABI create method",
        "ABI update method",
        "return value decoding",
        "compiledApproval",
        "deploy-time parameters"
      ],
      "feature_tags": [
        "app-client",
        "abi-methods",
        "app-creation",
        "app-update",
        "return-values",
        "deploy-time-params",
        "smart-contracts"
      ],
      "folder": "39-create-and-update-application-with-abi-methods",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Test account address displayed",
        "App created successfully with app ID and return value",
        "Transaction ID for creation",
        "Updatable app created with app ID",
        "App updated successfully with return value",
        "Transaction ID for update",
        "Confirmation that compiled approval program was updated"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Create app with abi"
        },
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Update app with abi"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app-spec.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "App specification with create_abi and update_abi methods that accept string arguments and return string values"
        }
      ],
      "notes": "This example combines two related operations (create and update) to provide a comprehensive view of ABI method usage. Deploy-time parameters allow configuration at deployment time, and the UPDATABLE parameter must be set to 1 to allow updates.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport { appSpec } from './app-spec' // Import your app specification\n\n/**\n * This example demonstrates how to:\n * 1. Create an application using an ABI method and retrieve its return value\n * 2. Update an existing application using an ABI method\n * \n * ABI (Application Binary Interface) methods provide type-safe interactions\n * with smart contracts and enable return value handling.\n */\n\nasync function createAndUpdateAppWithABI() {\n  // Initialize AlgoKit and get localnet context\n  const localnet = algokit.Config.getConfigFromEnvOrDefaults()\n  const algod = algokit.getAlgoClient({\n    server: localnet.algodServer,\n    token: localnet.algodToken,\n    port: localnet.algodPort,\n  })\n  \n  // Get a test account with funds\n  const testAccount = await algokit.getDispenserAccount(algod)\n  \n  console.log('Test account address:', testAccount.addr)\n  \n  // ========================================\n  // Part 1: Create Application with ABI Method\n  // ========================================\n  \n  console.log('\\n=== Creating Application with ABI Method ===')\n  \n  // Create an app client instance\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      app: appSpec,\n      sender: testAccount,\n      id: 0, // 0 means we're creating a new app\n    },\n    algod,\n  )\n  \n  // Create the application using an ABI method\n  // The 'create_abi' method is called during app creation\n  const createResult = await client.create({\n    deployTimeParams: {\n      UPDATABLE: 0, // Set to 1 to make the app updatable\n      DELETABLE: 0, // Set to 1 to make the app deletable\n      VALUE: 1,     // Custom deploy-time parameter\n    },\n    method: 'create_abi',\n    methodArgs: ['string_io'], // Arguments passed to the create_abi method\n  })\n  \n  // Handle the return value from the ABI method\n  if (createResult.return) {\n    if (createResult.return.decodeError) {\n      console.error('Error decoding return value:', createResult.return.decodeError)\n    } else {\n      console.log('App created successfully!')\n      console.log('App ID:', createResult.appId)\n      console.log('Return value from create_abi:', createResult.return.returnValue)\n      console.log('Transaction ID:', createResult.txId)\n    }\n  }\n  \n  // ========================================\n  // Part 2: Update Application with ABI Method\n  // ========================================\n  \n  console.log('\\n=== Updating Application with ABI Method ===')\n  \n  // First, create an updatable app\n  const updatableClient = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      app: appSpec,\n      sender: testAccount,\n      id: 0,\n    },\n    algod,\n  )\n  \n  const deployTimeParams = {\n    UPDATABLE: 1, // Make the app updatable\n    DELETABLE: 0,\n    VALUE: 1,\n  }\n  \n  const createUpdatableResult = await updatableClient.create({\n    deployTimeParams,\n  })\n  \n  console.log('Updatable app created with ID:', createUpdatableResult.appId)\n  \n  // Update the application using an ABI method\n  const updateResult = await updatableClient.update({\n    method: 'update_abi',\n    methodArgs: ['string_io'], // Arguments passed to the update_abi method\n    deployTimeParams, // Same deploy-time parameters\n  })\n  \n  // Handle the return value from the update\n  if (updateResult.return) {\n    if (updateResult.return.decodeError) {\n      console.error('Error decoding return value:', updateResult.return.decodeError)\n    } else {\n      console.log('\\nApp updated successfully!')\n      console.log('Return value from update_abi:', updateResult.return.returnValue)\n      console.log('Transaction ID:', updateResult.txId)\n      console.log('Compiled approval program updated:', !!updateResult.compiledApproval)\n    }\n  }\n  \n  console.log('\\n=== Example Complete ===')\n  console.log('Summary:')\n  console.log('- Created an app with ABI method and retrieved return value')\n  console.log('- Updated an app with ABI method and verified the result')\n  console.log('- Used deploy-time parameters to configure app behavior')\n}\n\n// Run the example\ncreateAndUpdateAppWithABI().catch(console.error)"
    },
    {
      "example_id": "40-custom-error-transformers-for-transaction-errors",
      "title": "Custom Error Transformers for Transaction Errors",
      "summary": "Demonstrates how to register custom error transformers to catch and modify error messages during transaction simulation and sending, enabling better error handling and user experience in applications.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Transform errors from simulate() and send() calls using custom error transformers to provide meaningful error messages",
      "target_users": [
        "SDK developers",
        "dApp developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "composer.addAssetTransfer",
        "composer.registerErrorTransformer",
        "composer.simulate",
        "composer.send"
      ],
      "feature_tags": [
        "error-handling",
        "error-transformation",
        "transaction-composer",
        "asset-transfer",
        "simulation",
        "custom-errors",
        "user-experience"
      ],
      "folder": "40-custom-error-transformers-for-transaction-errors",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn",
          "Docker (for LocalNet)",
          "AlgoKit CLI"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Registering error transformers...",
        "Simulating transaction (will fail)...",
        "\u2713 Caught transformed error: ASSET MISSING! The asset with ID 1337 does not exist on this network.",
        "Sending transaction (will fail)...",
        "\u2713 Caught transformed error: ASSET MISSING! The asset with ID 1337 does not exist on this network."
      ],
      "source_tests": [
        {
          "file": "src/types/composer.spec.ts",
          "test_name": "throws correct error from simulate"
        },
        {
          "file": "src/types/composer.spec.ts",
          "test_name": "throws correct error from send"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines two related tests (simulate and send error handling) into a single comprehensive example. The error transformers provide a pattern for building user-friendly dApps that show meaningful error messages instead of cryptic blockchain errors. You can expand this pattern to handle various error types specific to your application.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { TransactionComposer } from '@algorandfoundation/algokit-utils/types/composer'\n\n/**\n * This example demonstrates how to use custom error transformers\n * to provide meaningful, user-friendly error messages when transactions fail.\n * \n * Error transformers allow you to:\n * - Catch cryptic blockchain errors\n * - Transform them into readable messages\n * - Provide better debugging information\n * - Improve user experience in dApps\n */\n\n/**\n * Custom error transformer that catches asset-related errors\n * and transforms them into user-friendly messages\n */\nfunction assetErrorTransformer(error: Error): Error | null {\n  // Check if the error message contains asset-related issues\n  if (error.message.includes('asset') && error.message.includes('1337')) {\n    // Return a new error with a clearer message\n    return new Error('ASSET MISSING! The asset with ID 1337 does not exist on this network.')\n  }\n  \n  // Check for invalid asset errors\n  if (error.message.toLowerCase().includes('invalid asset')) {\n    return new Error('ASSET MISSING! Please check that the asset ID is correct and exists.')\n  }\n  \n  // Return null to let other transformers handle this error\n  return null\n}\n\n/**\n * Another error transformer for account balance errors\n */\nfunction balanceErrorTransformer(error: Error): Error | null {\n  if (error.message.includes('overspend') || error.message.includes('balance')) {\n    return new Error('INSUFFICIENT BALANCE! Your account does not have enough funds for this transaction.')\n  }\n  return null\n}\n\nasync function demonstrateErrorTransformers() {\n  console.log('=== Custom Error Transformer Example ===')\n  console.log()\n\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account\n  const sender = await algorand.account.localNet.dispenser()\n  \n  console.log('Sender address:', sender.addr)\n  console.log()\n\n  // Example 1: Error transformation during simulation\n  console.log('--- Example 1: Simulate with Error Transformer ---')\n  try {\n    // Create a new transaction group\n    const composer = algorand.newGroup()\n    \n    // Add an asset transfer for a non-existent asset (ID 1337)\n    composer.addAssetTransfer({\n      amount: 1n,\n      assetId: 1337n,  // This asset doesn't exist\n      sender: sender.addr,\n      receiver: sender.addr,\n    })\n    \n    // Register our custom error transformers\n    console.log('Registering error transformers...')\n    composer.registerErrorTransformer(assetErrorTransformer)\n    composer.registerErrorTransformer(balanceErrorTransformer)\n    \n    // Try to simulate - this will fail with our custom error message\n    console.log('Simulating transaction (will fail)...')\n    await composer.simulate()\n    \n  } catch (error) {\n    console.log('\u2713 Caught transformed error:', (error as Error).message)\n  }\n  console.log()\n\n  // Example 2: Error transformation during send\n  console.log('--- Example 2: Send with Error Transformer ---')\n  try {\n    // Create another transaction group\n    const composer = algorand.newGroup()\n    \n    // Add the same invalid asset transfer\n    composer.addAssetTransfer({\n      amount: 1n,\n      assetId: 1337n,  // This asset doesn't exist\n      sender: sender.addr,\n      receiver: sender.addr,\n    })\n    \n    // Register error transformers\n    console.log('Registering error transformers...')\n    composer.registerErrorTransformer(assetErrorTransformer)\n    composer.registerErrorTransformer(balanceErrorTransformer)\n    \n    // Try to send - this will fail with our custom error message\n    console.log('Sending transaction (will fail)...')\n    await composer.send()\n    \n  } catch (error) {\n    console.log('\u2713 Caught transformed error:', (error as Error).message)\n  }\n  console.log()\n\n  // Example 3: Chain multiple transformers\n  console.log('--- Example 3: Multiple Error Transformers ---')\n  console.log('When multiple transformers are registered, they are called in order.')\n  console.log('The first transformer that returns a non-null error wins.')\n  console.log('This allows you to create a hierarchy of error handling.')\n}\n\n// Run the example\ndemonstrateErrorTransformers()\n  .then(() => {\n    console.log('\\n\u2713 Error transformer demonstration complete')\n  })\n  .catch((error) => {\n    console.error('Unexpected error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "41-decode-abi-struct-with-typed-fields",
      "title": "Decode ABI Struct with Typed Fields",
      "summary": "Shows how to decode ABI-encoded data into structured types including structs with uint16 and string fields using AlgoKit utilities.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "ABI decoding",
      "specific_use_case": "Decode a struct containing a uint16 and string",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "getABIDecodedValue",
        "struct decoding",
        "ARC-56",
        "type safety"
      ],
      "feature_tags": [
        "abi-decoding",
        "struct-types",
        "arc-56",
        "type-safety",
        "data-encoding",
        "smart-contracts"
      ],
      "folder": "41-decode-abi-struct-with-typed-fields",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install",
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Display of encoded data in hex and byte format",
        "Decoded struct with userId as number and name as string",
        "Type verification showing correct JavaScript types",
        "Multiple examples of struct decoding"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "correctly decodes a struct containing a uint16"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining ABI encoding/decoding and struct types"
        }
      ],
      "notes": "This example demonstrates ABI decoding without requiring a running Algorand node. It's useful for understanding how data is structured when returned from smart contracts.",
      "generated_code": "import { getABIDecodedValue } from '@algorandfoundation/algokit-utils/types/app-arc56'\n\n/**\n * This example demonstrates how to decode ABI-encoded data into complex types.\n * Specifically, it shows decoding a struct containing a uint16 and a string,\n * which is a common pattern when working with smart contract data.\n */\n\n// Define the structure type definition\n// This matches the ARC-56 struct schema\ninterface User {\n  userId: number\n  name: string\n}\n\n// Define the ARC-56 struct schema\nconst structSchema = {\n  User: [\n    { name: 'userId', type: 'uint16' },\n    { name: 'name', type: 'string' },\n  ],\n}\n\nfunction main() {\n  console.log('=== ABI Struct Decoding Example ===')\n  console.log()\n\n  // Example 1: Decode a User struct\n  console.log('Example 1: Decoding a User struct')\n  console.log('----------------------------------')\n\n  // This is the ABI-encoded data (typically received from a smart contract)\n  // Format: [uint16: userId, string: name]\n  // Breakdown: [0, 1] = userId: 1, [0, 4] = string length: 4, followed by \"world\" in bytes\n  const encodedData = new Uint8Array([\n    0, 1,           // userId: 1 (uint16, 2 bytes)\n    0, 4,           // string length: 4 (2 bytes)\n    119, 111, 114, 108, 100  // \"world\" in ASCII bytes (5 bytes, note: \"world\" is 5 chars)\n  ])\n\n  console.log('Encoded data (hex):', Buffer.from(encodedData).toString('hex'))\n  console.log('Encoded data (bytes):', Array.from(encodedData))\n  console.log()\n\n  // Decode the ABI-encoded data into a User struct\n  const decoded = getABIDecodedValue(\n    encodedData,\n    'User',\n    structSchema\n  ) as User\n\n  console.log('Decoded struct:')\n  console.log(`  userId: ${decoded.userId} (type: ${typeof decoded.userId})`)\n  console.log(`  name: \"${decoded.name}\" (type: ${typeof decoded.name})`)\n  console.log()\n\n  // Verify the types are correct\n  console.log('Type verification:')\n  console.log(`  userId is number: ${typeof decoded.userId === 'number'}`)\n  console.log(`  name is string: ${typeof decoded.name === 'string'}`)\n  console.log()\n\n  // Example 2: Decode another User struct with different values\n  console.log('Example 2: Decoding another User struct')\n  console.log('----------------------------------------')\n\n  const encodedData2 = new Uint8Array([\n    0, 42,          // userId: 42\n    0, 5,           // string length: 5\n    65, 108, 105, 99, 101  // \"Alice\"\n  ])\n\n  const decoded2 = getABIDecodedValue(\n    encodedData2,\n    'User',\n    structSchema\n  ) as User\n\n  console.log('Decoded struct:')\n  console.log(`  userId: ${decoded2.userId}`)\n  console.log(`  name: \"${decoded2.name}\"`)\n  console.log()\n\n  console.log('=== Example Complete ===')\n  console.log('ABI decoding allows type-safe interaction with smart contract data.')\n  console.log('Structs can contain multiple fields of different types (uint, string, etc.).')\n}\n\nmain()"
    },
    {
      "example_id": "42-decoding-byte-arrays-from-abi-method-returns",
      "title": "Decoding Byte Arrays from ABI Method Returns",
      "summary": "Demonstrates how to properly decode both static and dynamic byte arrays from ABI method return values when working with Algorand smart contracts.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "transaction management",
      "specific_use_case": "Decode static and dynamic byte arrays from method return values",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "byte array decoding",
        "static byte arrays",
        "dynamic byte arrays",
        "ABI type decoding",
        "method return values",
        "app client calls"
      ],
      "feature_tags": [
        "byte-arrays",
        "abi-decoding",
        "static-arrays",
        "dynamic-arrays",
        "return-values",
        "app-client",
        "type-handling"
      ],
      "folder": "42-decoding-byte-arrays-from-abi-method-returns",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "Static byte array retrieved and decoded",
        "Static byte array displayed as hex and UTF-8",
        "Dynamic byte array retrieved and decoded",
        "Dynamic byte array displayed as hex and UTF-8",
        "Both array types properly handled"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "dynamicByteArray"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "staticByteArray"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "byte_array_app.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56/ARC4 contract specification with methods that return static and dynamic byte arrays"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        }
      ],
      "notes": "This example demonstrates the pattern for decoding byte arrays. In a real implementation, you would need a fully implemented smart contract with methods that actually return byte array values. The key learning is understanding how to access and work with the decoded return values.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppFactory, AppClient } from '@algorandfoundation/algokit-utils/types/app'\nimport { encodeUint64, decodeUint64 } from 'algosdk'\n\n/**\n * Demonstrates decoding byte arrays from ABI method return values.\n * \n * This example shows how to properly handle both static and dynamic byte arrays\n * when calling smart contract methods. Static arrays have a fixed length known\n * at compile time, while dynamic arrays can vary in length.\n */\nasync function main() {\n  console.log('=== Byte Array Decoding Example ===')\n  console.log()\n\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.localNet.dispenser()\n\n  console.log('Step 1: Deploy application with byte array methods')\n  \n  // For this example, we'll use a simple app spec\n  // In a real scenario, this would come from your compiled contract\n  const appSpec = {\n    hints: {},\n    source: {\n      approval: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n      clear: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n    },\n    state: {\n      global: {\n        num_byte_slices: 2,\n        num_uints: 0,\n      },\n      local: {\n        num_byte_slices: 0,\n        num_uints: 0,\n      },\n    },\n    schema: {\n      global: {\n        declared: {},\n        reserved: {},\n      },\n      local: {\n        declared: {},\n        reserved: {},\n      },\n    },\n    contract: {\n      name: 'ByteArrayApp',\n      methods: [\n        {\n          name: 'getStaticByteArray',\n          args: [],\n          returns: { type: 'byte[8]' }, // Static: fixed 8 bytes\n        },\n        {\n          name: 'getDynamicByteArray',\n          args: [],\n          returns: { type: 'byte[]' }, // Dynamic: variable length\n        },\n      ],\n    },\n  }\n\n  const factory = algorand.client.getAppFactory({\n    appSpec,\n    defaultSender: account.addr,\n  })\n\n  const { appClient } = await factory.send.create({ method: 'createApplication' })\n  console.log(`\u2713 Application deployed with ID: ${appClient.appId}`)\n  console.log()\n\n  // Example: Working with Static Byte Arrays\n  console.log('Step 2: Decode Static Byte Array')\n  console.log('Static byte arrays have a fixed length (e.g., byte[8])')\n  console.log()\n\n  try {\n    // Call method that returns a static byte array\n    const staticResult = await appClient.send.call({\n      method: 'getStaticByteArray',\n    })\n\n    // The return value is automatically decoded by the ABI\n    const staticByteArray = staticResult.return?.value as Uint8Array\n\n    console.log('Static Byte Array Retrieved:')\n    console.log(`  Length: ${staticByteArray.length} bytes (fixed)`)\n    console.log(`  Hex: ${Buffer.from(staticByteArray).toString('hex')}`)\n    console.log(`  UTF-8: ${Buffer.from(staticByteArray).toString('utf-8')}`)\n    console.log()\n\n    // You can work with the byte array directly\n    console.log('Working with static byte array:')\n    for (let i = 0; i < staticByteArray.length; i++) {\n      console.log(`  Byte[${i}]: ${staticByteArray[i]} (0x${staticByteArray[i].toString(16).padStart(2, '0')})`)\n    }\n    console.log()\n  } catch (e) {\n    console.log(`Note: Method call may fail if contract not fully implemented`)\n    console.log(`This is a demonstration of the decoding pattern`)\n    console.log()\n  }\n\n  // Example: Working with Dynamic Byte Arrays\n  console.log('Step 3: Decode Dynamic Byte Array')\n  console.log('Dynamic byte arrays have variable length (e.g., byte[])')\n  console.log()\n\n  try {\n    // Call method that returns a dynamic byte array\n    const dynamicResult = await appClient.send.call({\n      method: 'getDynamicByteArray',\n    })\n\n    // The return value is automatically decoded by the ABI\n    const dynamicByteArray = dynamicResult.return?.value as Uint8Array\n\n    console.log('Dynamic Byte Array Retrieved:')\n    console.log(`  Length: ${dynamicByteArray.length} bytes (variable)`)\n    console.log(`  Hex: ${Buffer.from(dynamicByteArray).toString('hex')}`)\n    console.log(`  UTF-8: ${Buffer.from(dynamicByteArray).toString('utf-8')}`)\n    console.log()\n\n    // Dynamic arrays can be of any length\n    console.log('Working with dynamic byte array:')\n    if (dynamicByteArray.length > 0) {\n      console.log(`  First byte: ${dynamicByteArray[0]} (0x${dynamicByteArray[0].toString(16).padStart(2, '0')})`)\n      console.log(`  Last byte: ${dynamicByteArray[dynamicByteArray.length - 1]} (0x${dynamicByteArray[dynamicByteArray.length - 1].toString(16).padStart(2, '0')})`)\n    }\n    console.log()\n  } catch (e) {\n    console.log(`Note: Method call may fail if contract not fully implemented`)\n    console.log(`This is a demonstration of the decoding pattern`)\n    console.log()\n  }\n\n  console.log('Key Differences:')\n  console.log('  Static (byte[N]):')\n  console.log('    \u2022 Fixed length known at compile time')\n  console.log('    \u2022 More gas-efficient')\n  console.log('    \u2022 Use when size is constant')\n  console.log()\n  console.log('  Dynamic (byte[]):')\n  console.log('    \u2022 Variable length')\n  console.log('    \u2022 Includes length prefix in ABI encoding')\n  console.log('    \u2022 Use when size varies')\n  console.log()\n\n  console.log('Best Practices:')\n  console.log('  \u2022 AlgoKit Utils automatically decodes ABI return values')\n  console.log('  \u2022 Access decoded value via result.return?.value')\n  console.log('  \u2022 Cast to appropriate type (Uint8Array for byte arrays)')\n  console.log('  \u2022 Use Buffer.from() to convert for display/manipulation')\n  console.log()\n\n  console.log('=== Example Complete ===')\n}\n\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "43-decoding-nested-abi-structures-from-smart-contract-methods",
      "title": "Decoding Nested ABI Structures from Smart Contract Methods",
      "summary": "Shows how to work with complex nested data structures including structs and byte arrays returned from Algorand smart contract ABI methods.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Decode nested struct and byte array return values from ABI methods",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "nested struct decoding",
        "nested byte array decoding",
        "ABI struct types",
        "return value decoding",
        "array of arrays",
        "struct references"
      ],
      "feature_tags": [
        "abi",
        "structs",
        "nested-structures",
        "return-values",
        "decoding",
        "byte-arrays",
        "typed-client",
        "smart-contracts"
      ],
      "folder": "43-decoding-nested-abi-structures-from-smart-contract-methods",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk",
          "typescript"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a smart contract with nested struct/byte array methods"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "App deployed successfully",
        "Value set with nested struct: { x: { a: \"hello\" } }",
        "Retrieved nested struct: { \"x\": { \"a\": \"hello\" } }",
        "Nested value: hello",
        "Retrieved nested byte arrays with proper decoding",
        "All nested structure decoding examples completed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "correctly decodes the nested struct"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "nestedByteArrays"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract with nested struct and byte array methods (setValue, getValue, getNestedByteArrays)"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with AlgoKit Utils and algosdk dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration for the example"
        },
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining nested struct and byte array decoding"
        }
      ],
      "notes": "This example groups related test blocks about nested structure decoding. The smart contract should include methods that return nested structs (struct within struct) and nested byte arrays (byte[][]). The AlgoKit TypeScript client automatically handles ABI decoding of these complex types.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { YourAppClient } from './artifacts/YourApp/client'\n\n/**\n * This example demonstrates how to decode complex nested data structures\n * returned from Algorand smart contract ABI methods.\n * \n * It covers:\n * - Nested structs (struct containing another struct)\n * - Nested byte arrays (arrays of byte arrays)\n * - Proper ABI type decoding\n */\n\nasync function decodeNestedStructExample() {\n  console.log('=== Decoding Nested Structs ===')\n  \n  // Initialize the Algorand client\n  const algorand = AlgorandClient.defaultLocalNet()\n  const sender = (await algorand.account.localNetDispenser()).addr\n  \n  // Create and deploy the app client\n  const appClient = new YourAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      sender,\n      creatorAddress: sender,\n    },\n    algorand.client.algod\n  )\n  \n  await appClient.create.bare()\n  \n  console.log('App deployed successfully')\n  \n  // Set a value with nested struct structure\n  // This stores a struct like: { x: { a: 'hello' } }\n  await appClient.send.call({ \n    method: 'setValue', \n    args: [1, 'hello'] \n  })\n  \n  console.log('Value set with nested struct: { x: { a: \"hello\" } }')\n  \n  // Retrieve the value - it will be automatically decoded\n  const result = await appClient.send.call({ \n    method: 'getValue', \n    args: [1] \n  })\n  \n  // The return value is automatically decoded into the nested struct\n  console.log('Retrieved nested struct:', JSON.stringify(result.return, null, 2))\n  // Output: { \"x\": { \"a\": \"hello\" } }\n  \n  // Access nested properties\n  const nestedValue = (result.return as { x: { a: string } }).x.a\n  console.log(`Nested value: ${nestedValue}`) // Output: hello\n}\n\nasync function decodeNestedByteArraysExample() {\n  console.log('\\n=== Decoding Nested Byte Arrays ===')\n  \n  // Initialize the Algorand client\n  const algorand = AlgorandClient.defaultLocalNet()\n  const sender = (await algorand.account.localNetDispenser()).addr\n  \n  // Create and deploy the app client\n  const appClient = new YourAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      sender,\n      creatorAddress: sender,\n    },\n    algorand.client.algod\n  )\n  \n  await appClient.create.bare()\n  \n  console.log('App deployed for byte array testing')\n  \n  // Call a method that returns nested byte arrays (byte[][])\n  const result = await appClient.send.call({ \n    method: 'getNestedByteArrays'\n  })\n  \n  // The return value is automatically decoded into nested byte arrays\n  console.log('Retrieved nested byte arrays:', result.return)\n  // Output: Array of byte arrays, each properly decoded\n  \n  // Process each byte array in the nested structure\n  if (Array.isArray(result.return)) {\n    result.return.forEach((byteArray, index) => {\n      console.log(`Byte array ${index}:`, byteArray)\n    })\n  }\n}\n\nasync function main() {\n  try {\n    // Example 1: Nested Structs\n    await decodeNestedStructExample()\n    \n    // Example 2: Nested Byte Arrays\n    await decodeNestedByteArraysExample()\n    \n    console.log('\\n\u2705 All nested structure decoding examples completed successfully!')\n  } catch (error) {\n    console.error('Error in nested structure decoding:', error)\n    throw error\n  }\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "44-delete-application-using-abi-method",
      "title": "Delete Application Using ABI Method",
      "summary": "Demonstrates how to delete a smart contract application using an ABI method with custom cleanup logic",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Delete an application using an ABI method that performs cleanup operations",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appClient.send.delete",
        "ABI delete method",
        "return value from delete"
      ],
      "feature_tags": [
        "app-deletion",
        "abi-method",
        "cleanup-logic",
        "app-lifecycle",
        "deploy-time-params"
      ],
      "folder": "44-delete-application-using-abi-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating a deletable application...",
        "App created with ID: [number]",
        "App is deletable and can be removed from the blockchain",
        "Deleting the app with ABI method...",
        "Delete method returned: string_io",
        "\u2705 App successfully deleted!",
        "The app no longer exists on the blockchain.",
        "\u2705 Example completed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Delete app with abi"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Example smart contract with delete_abi method and deploy-time parameters (UPDATABLE, DELETABLE, VALUE)"
        }
      ],
      "notes": "This example requires a smart contract that supports ABI deletion with a 'delete_abi' method. The contract should accept deploy-time parameters (UPDATABLE, DELETABLE, VALUE) and have a delete_abi method that takes a string argument and returns it.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AppFactory } from '@algorandfoundation/algokit-utils/types/app-factory'\nimport { AppClient } from '@algorandfoundation/algokit-utils/types/app-client'\n\n/**\n * This example demonstrates how to delete a smart contract application\n * using an ABI method with custom cleanup logic.\n * \n * Key concepts:\n * - Creating a deletable app with deploy-time parameters\n * - Using ABI methods for app deletion\n * - Getting return values from delete operations\n */\n\nasync function deleteAppWithAbi() {\n  // Setup: Create an Algorand test fixture\n  const localnet = await algorandFixture()\n  const { algorand, testAccount } = localnet.context\n\n  // Note: You'll need to initialize your AppFactory with your contract's ABI and approval/clear programs\n  // const factory = new AppFactory({\n  //   appSpec: yourAppSpec,\n  //   algorand,\n  //   defaultSender: testAccount.addr,\n  // })\n  \n  console.log('Creating a deletable application...')\n  \n  // Define deploy-time parameters for the app\n  // UPDATABLE: 0 means the app cannot be updated\n  // DELETABLE: 1 means the app can be deleted\n  // VALUE: 1 is an example parameter\n  const deployTimeParams = {\n    UPDATABLE: 0,\n    DELETABLE: 1,\n    VALUE: 1,\n  }\n\n  // Create the app with a bare call (no ABI method)\n  const { appClient } = await factory.send.bare.create({\n    deployTimeParams,\n  })\n\n  console.log(`App created with ID: ${appClient.appId}`)\n  console.log('App is deletable and can be removed from the blockchain')\n\n  // Delete the app using an ABI method\n  // This allows you to include custom cleanup logic before deletion\n  console.log('\\nDeleting the app with ABI method...')\n  \n  const deleteResult = await appClient.send.delete({\n    method: 'delete_abi',\n    args: ['string_io'],\n  })\n\n  // The ABI method can return a value during deletion\n  // This is useful for confirming successful cleanup operations\n  console.log(`Delete method returned: ${deleteResult.return}`)\n  \n  console.log('\\n\u2705 App successfully deleted!')\n  console.log('The app no longer exists on the blockchain.')\n  \n  return deleteResult\n}\n\n// Run the example\ndeleteAppWithAbi()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "45-delete-an-application-using-an-abi-method",
      "title": "Delete an Application Using an ABI Method",
      "summary": "Demonstrates how to delete an Algorand application using an ABI method call, including capturing and decoding the return value.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "app lifecycle",
      "specific_use_case": "Delete an application using an ABI method",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.delete",
        "ABI delete method",
        "return value decoding",
        "deployTimeParams"
      ],
      "feature_tags": [
        "app-deletion",
        "abi-method",
        "app-lifecycle",
        "deletable-app",
        "return-value"
      ],
      "folder": "45-delete-an-application-using-an-abi-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost:4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID: <app_id>",
        "Deleting app with ABI method...",
        "App deleted successfully!",
        "Return value: string_io"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Delete app with abi"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample ARC-32 app spec with delete_abi method"
        }
      ],
      "notes": "This example demonstrates creating a deletable app and then deleting it using an ABI method. The app must be created with DELETABLE=1 parameter.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils/types/network-client'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to delete an application using an ABI method.\n * The app must be created with the DELETABLE parameter set to 1.\n */\n\n// Sample app spec with delete_abi method\n// In a real scenario, this would be imported from your compiled contract\nconst appSpec = {\n  hints: {\n    delete_abi: {\n      call_config: {\n        delete_application: 'CALL',\n      },\n    },\n  },\n  contract: {\n    name: 'DeletableApp',\n    methods: [\n      {\n        name: 'delete_abi',\n        args: [{ type: 'string', name: 'input' }],\n        returns: { type: 'string' },\n      },\n    ],\n  },\n  state: {\n    global: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n    local: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n  },\n  schema: {\n    global: {\n      declared: {},\n      reserved: {},\n    },\n    local: {\n      declared: {},\n      reserved: {},\n    },\n  },\n  source: {\n    approval: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n    clear: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n  },\n  bare_call_config: {\n    no_op: 'NEVER',\n    opt_in: 'NEVER',\n    close_out: 'NEVER',\n    update_application: 'NEVER',\n    delete_application: 'NEVER',\n  },\n  template_variables: {\n    UPDATABLE: { type: 'uint64' },\n    DELETABLE: { type: 'uint64' },\n    VALUE: { type: 'uint64' },\n  },\n}\n\nasync function deleteAppWithABI() {\n  // Initialize AlgorandClient for LocalNet\n  const algod = new algosdk.Algodv2('a' + 'a'.repeat(63), 'http://localhost', 4001)\n  const algorand = AlgorandClient.fromClients({ algod })\n\n  // Get a test account from the LocalNet dispenser\n  const testAccount = await algorand.account.fromEnvironment('LOCALNET')\n  console.log(`Using account: ${testAccount.addr}`)\n\n  // Create an app client\n  const appClient = algorand.client.getAppClient({\n    resolveBy: 'id',\n    app: appSpec,\n    sender: testAccount,\n    id: 0,\n  })\n\n  // Step 1: Create the app with DELETABLE=1\n  console.log('Creating deletable app...')\n  const createResult = await appClient.create({\n    deployTimeParams: {\n      UPDATABLE: 0, // Not updatable\n      DELETABLE: 1, // Deletable\n      VALUE: 1,\n    },\n  })\n\n  const appId = createResult.appId\n  console.log(`App created with ID: ${appId}`)\n\n  // Step 2: Delete the app using the ABI method\n  console.log('Deleting app with ABI method...')\n  const deleteCall = await appClient.delete({\n    method: 'delete_abi',\n    methodArgs: ['string_io'],\n  })\n\n  // Step 3: Check the return value from the delete method\n  if (deleteCall.return) {\n    if (deleteCall.return.decodeError) {\n      console.error(`Decode error: ${deleteCall.return.decodeError}`)\n    } else {\n      console.log(`App deleted successfully!`)\n      console.log(`Return value: ${deleteCall.return.returnValue}`)\n    }\n  }\n}\n\n// Run the example\ndeleteAppWithABI().catch(console.error)\n"
    },
    {
      "example_id": "46-deploy-application-with-abi-create-method",
      "title": "Deploy Application with ABI Create Method",
      "summary": "Shows how to deploy a new application using an ABI create method with deploy-time parameters and capture the return value from the initialization method.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an application using an ABI create method and capture return value",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algokit.getAppClient",
        "client.deploy",
        "createArgs with ABI method",
        "deployTimeParams",
        "return value handling",
        "resolveBy: 'creatorAndName'"
      ],
      "feature_tags": [
        "app-client",
        "deployment",
        "abi",
        "create-method",
        "return-values",
        "deploy-time-params"
      ],
      "folder": "46-deploy-application-with-abi-create-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have an app spec JSON file from your smart contract"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Setting up app client...",
        "Deploying application with ABI create method...",
        "\u2705 Application created successfully!",
        "App ID: <number>",
        "App Address: <address>",
        "Created in Round: <round>",
        "Address verification: \u2705 Match",
        "Return value from create method: arg_io",
        "\u2705 Example completed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - create (abi)"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app_spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "User needs to provide their own app spec with a 'create_abi' method that accepts a string argument and returns a string"
        }
      ],
      "notes": "This example requires an application specification (app spec) with an ABI create method. The app spec should include a method named 'create_abi' that accepts a string argument and returns a string. Users will need to replace '<YOUR_APP_SPEC>' with their actual app spec object or load it from a JSON file.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport { getApplicationAddress } from 'algosdk'\n\n// This example demonstrates deploying an application with an ABI create method\n// The create method is called during deployment and can return values\n\nasync function deployAppWithAbiCreate() {\n  // Initialize AlgoKit and get clients\n  const algod = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('algod'))\n  const indexer = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('indexer'))\n  const account = await algokit.getLocalNetDispenserAccount(algod)\n\n  // Load your application specification\n  // This should be generated from your smart contract (e.g., using Beaker or TEALScript)\n  const appSpec = '<YOUR_APP_SPEC>' // Replace with your actual app spec\n\n  console.log('Setting up app client...')\n  \n  // Create an app client configured to resolve by creator address and name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName', // Find existing apps by creator and name\n      app: appSpec, // Your application specification\n      sender: account, // The account deploying the app\n      creatorAddress: account.addr, // The creator address to search for\n      findExistingUsing: indexer, // Use indexer to find existing apps\n    },\n    algod,\n  )\n\n  console.log('Deploying application with ABI create method...')\n  \n  // Deploy the application\n  const app = await client.deploy({\n    version: '1.0', // Semantic version for idempotent deployment\n    deployTimeParams: {\n      // Deploy-time parameters are template variables in your TEAL code\n      VALUE: 1, // Replace with your actual deploy-time parameter name\n    },\n    createArgs: {\n      // Specify the ABI method to call during creation\n      method: 'create_abi', // Name of your ABI create method\n      methodArgs: ['arg_io'], // Arguments to pass to the create method\n    },\n  })\n\n  // Check what operation was performed\n  if (app.operationPerformed === 'create') {\n    console.log('\u2705 Application created successfully!')\n    console.log(`App ID: ${app.appId}`)\n    console.log(`App Address: ${app.appAddress}`)\n    console.log(`Created in Round: ${app.confirmation?.confirmedRound}`)\n    \n    // Verify the app address matches the expected address\n    const expectedAddress = getApplicationAddress(app.appId).toString()\n    console.log(`Address verification: ${app.appAddress === expectedAddress ? '\u2705 Match' : '\u274c Mismatch'}`)\n    \n    // The return value from the create method\n    if (app.return?.returnValue) {\n      console.log(`Return value from create method: ${app.return.returnValue}`)\n    }\n  } else {\n    console.log(`Application already exists (operation: ${app.operationPerformed})`)\n  }\n\n  return app\n}\n\n// Run the example\ndeployAppWithAbiCreate()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "47-deploy-application-with-abi-create-method",
      "title": "Deploy Application with ABI Create Method",
      "summary": "Demonstrates how to deploy an application using a custom ABI create method with arguments, enabling initialization logic with parameters and returning values from the create call.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an application using an ABI create method with arguments",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "createParams with ABI method",
        "app.return",
        "operationPerformed",
        "appId",
        "appAddress"
      ],
      "feature_tags": [
        "deployment",
        "abi",
        "create-method",
        "app-factory",
        "smart-contracts",
        "initialization",
        "return-values"
      ],
      "folder": "47-deploy-application-with-abi-create-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run example"
        ]
      },
      "expected_output": [
        "Deploying application with ABI create method...",
        "Operation Performed: create",
        "App ID: <number>",
        "App Address: <address>",
        "Return value from create method: arg_io",
        "Deployment with ABI method completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - create (abi)"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "hello_world_abi.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Contract with ABI create method"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "Using ABI create methods allows you to run custom initialization logic during app creation, pass arguments, and receive return values. This is more powerful than bare create calls.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppFactory } from '@algorandfoundation/algokit-utils/types/app-factory'\nimport { getApplicationAddress } from 'algosdk'\n\n/**\n * This example demonstrates how to deploy an application using an ABI create method.\n * \n * ABI create methods allow you to:\n * - Call custom initialization logic during app creation\n * - Pass arguments to the create method\n * - Receive return values from the create call\n * \n * This is more powerful than bare create calls and enables complex initialization.\n */\n\nasync function deployApplicationWithAbiCreateMethod() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const deployer = await algorand.account.fromEnvironment('DEPLOYER')\n  \n  // Create an app factory instance\n  // Note: Your app spec must include the ABI method definition\n  const appSpec = {\n    // Your application specification with ABI methods\n    contract: {\n      name: 'HelloWorldABI',\n      methods: [\n        {\n          name: 'create_abi',\n          args: [\n            {\n              type: 'string',\n              name: 'input'\n            }\n          ],\n          returns: {\n            type: 'string'\n          }\n        }\n      ]\n    },\n    hints: {\n      deploy_time_params: {\n        VALUE: {\n          type: 'uint64',\n          source: 'constant'\n        }\n      },\n      create_abi: {\n        call_config: {\n          no_op: 'CALL'\n        }\n      }\n    }\n  }\n  \n  const factory = algorand.client.getAppFactory({\n    appSpec,\n    defaultSender: deployer.addr,\n  })\n  \n  console.log('Deploying application with ABI create method...')\n  console.log('Method: create_abi')\n  console.log('Arguments: [\"arg_io\"]')\n  \n  // Deploy the application using a custom ABI create method\n  const { result: app } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1,  // Deploy-time parameter\n    },\n    createParams: {\n      method: 'create_abi',  // Name of the ABI method to call\n      args: ['arg_io'],      // Arguments to pass to the method\n    },\n  })\n  \n  // Check what operation was performed\n  console.log(`\\n\u2705 Operation Performed: ${app.operationPerformed}`)\n  \n  // Display app information\n  console.log(`\\n\ud83d\udcf1 Application Information:`)\n  console.log(`App ID: ${app.appId}`)\n  console.log(`App Address: ${app.appAddress}`)\n  \n  // Verify the app address\n  const expectedAddress = getApplicationAddress(app.appId)\n  console.log(`\\n\u2713 App address verification: ${app.appAddress === expectedAddress ? 'PASSED' : 'FAILED'}`)\n  \n  // Display the return value from the ABI method\n  console.log(`\\n\ud83d\udd04 Return Value from create_abi method:`)\n  console.log(`Returned: \"${app.return}\"`)\n  console.log(`Expected: \"arg_io\"`)\n  console.log(`Match: ${app.return === 'arg_io' ? '\u2705 YES' : '\u274c NO'}`)\n  \n  // Display confirmation details\n  if (app.confirmation) {\n    console.log(`\\n\ud83d\udccb Confirmation Details:`)\n    console.log(`Application Index: ${app.confirmation.applicationIndex}`)\n    console.log(`Confirmed Round: ${app.confirmation.confirmedRound}`)\n  }\n  \n  console.log('\\n\u2705 Deployment with ABI method completed successfully!')\n  console.log('\\n\ud83d\udca1 Key Benefits:')\n  console.log('   - Custom initialization logic executed during creation')\n  console.log('   - Arguments passed to initialize app state')\n  console.log('   - Return values available for verification')\n  \n  return app\n}\n\n// Run the example\ndeployApplicationWithAbiCreateMethod()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "48-deploy-application-with-version-tracking",
      "title": "Deploy Application with Version Tracking",
      "summary": "Demonstrates how to deploy an Algorand application with version tracking, enabling idempotent deployments and the ability to detect whether a create, update, or replace operation was performed.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy a new application with version tracking",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algokit.getAppClient",
        "client.deploy",
        "operationPerformed",
        "version tracking",
        "idempotent deployment",
        "compiledApproval"
      ],
      "feature_tags": [
        "app-client",
        "app-deployment",
        "versioning",
        "idempotent-deployment",
        "operation-detection",
        "typescript"
      ],
      "folder": "48-deploy-application-with-version-tracking",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have an app specification file (appSpec)"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "Operation: create",
        "App ID: <positive number>",
        "App Address: <algorand address>",
        "Version: 1.0",
        "Compiled approval program available"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - create"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "A simple app specification file for demonstration"
        }
      ],
      "notes": "The deploy() method is idempotent - it will create the app if it doesn't exist, update it if the code changed, or do nothing if it already exists with the same version. The operationPerformed field tells you what action was taken.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport { getApplicationAddress } from 'algosdk'\n\n// Import the app specification\nimport appSpec from './app-spec.json'\n\nasync function deployAppWithVersionTracking() {\n  // Get AlgoKit configuration for LocalNet\n  const algod = algokit.getAlgoClient({\n    server: 'http://localhost',\n    port: 4001,\n    token: 'a'.repeat(64),\n  })\n\n  const indexer = algokit.getAlgoIndexerClient({\n    server: 'http://localhost',\n    port: 8980,\n    token: 'a'.repeat(64),\n  })\n\n  // Get a test account from LocalNet\n  const testAccount = await algokit.getLocalNetDispenserAccount(algod)\n\n  console.log('Creating app client...')\n  // Create an app client that resolves by creator address and app name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: testAccount,\n      creatorAddress: testAccount.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  console.log('Deploying application with version tracking...')\n  console.log('This is an idempotent operation - it will create, update, or do nothing as needed.\\n')\n\n  // Deploy the application with version tracking\n  // The deploy() method is intelligent:\n  // - If the app doesn't exist, it will create it\n  // - If the app exists with different code, it will update it\n  // - If the app exists with the same code, it will do nothing\n  const app = await client.deploy({\n    // Version string for tracking deployments\n    version: '1.0',\n    // Set deploy-time parameters\n    deployTimeParams: {\n      VALUE: 1,\n    },\n  })\n\n  // Check what operation was performed\n  console.log('\\n=== Deployment Result ===')\n  console.log(`Operation Performed: ${app.operationPerformed}`)\n\n  // For this example, we expect it to be 'create' since it's a new app\n  if (app.operationPerformed === 'create') {\n    console.log('\u2713 A new application was created')\n  } else if (app.operationPerformed === 'update') {\n    console.log('\u2713 An existing application was updated')\n  } else if (app.operationPerformed === 'replace') {\n    console.log('\u2713 An existing application was replaced')\n  } else {\n    console.log('\u2713 No changes were needed (app already exists with same version)')\n  }\n\n  // Display application details\n  console.log('\\n=== Application Details ===')\n  console.log(`App ID: ${app.appId}`)\n  console.log(`App Address: ${app.appAddress}`)\n  console.log(`Application Index: ${app.confirmation?.applicationIndex}`)\n  console.log(`Version: 1.0`)\n  console.log(`Compiled Approval Program: ${app.compiledApproval ? 'Available' : 'Not available'}`)\n\n  // Verify the app address matches the expected address for the app ID\n  const expectedAddress = getApplicationAddress(app.appId).toString()\n  console.log(`\\nAddress verification: ${app.appAddress === expectedAddress ? 'PASSED' : 'FAILED'}`)\n\n  // Demonstrate idempotency by deploying again\n  console.log('\\n=== Testing Idempotency ===')\n  console.log('Deploying again with the same version...')\n  const secondDeploy = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 1,\n    },\n  })\n  console.log(`Second deployment operation: ${secondDeploy.operationPerformed}`)\n  console.log('Since the version and code are the same, no changes were made.')\n\n  return app\n}\n\n// Run the example\ndeployAppWithVersionTracking()\n  .then(() => {\n    console.log('\\nExample completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "49-deploy-immutable-and-permanent-application",
      "title": "Deploy Immutable and Permanent Application",
      "summary": "Demonstrates how to deploy an Algorand application that is immutable (cannot be updated) and permanent (cannot be deleted), suitable for production contracts that require maximum security and permanence.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an immutable and permanent application (cannot be updated or deleted)",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algokit.getAppClient",
        "client.deploy",
        "allowDelete parameter",
        "allowUpdate parameter",
        "onSchemaBreak parameter",
        "onUpdate parameter",
        "deployTimeParams"
      ],
      "feature_tags": [
        "app-client",
        "app-deployment",
        "immutable",
        "permanent",
        "production-deployment",
        "typescript"
      ],
      "folder": "49-deploy-immutable-and-permanent-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have an app specification file (appSpec)"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "App ID: <positive number>",
        "App Address: <algorand address>",
        "Configuration: Immutable and Permanent (no updates or deletions allowed)"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - can still deploy when immutable and permanent"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "A simple app specification file for demonstration"
        }
      ],
      "notes": "This example is critical for production deployments where you want to ensure that the smart contract cannot be modified or deleted after deployment. This provides maximum security and trust for users.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\n\n// Import the app specification\nimport appSpec from './app-spec.json'\n\nasync function deployImmutablePermanentApp() {\n  // Get AlgoKit configuration for LocalNet\n  const algod = algokit.getAlgoClient({\n    server: 'http://localhost',\n    port: 4001,\n    token: 'a'.repeat(64),\n  })\n\n  const indexer = algokit.getAlgoIndexerClient({\n    server: 'http://localhost',\n    port: 8980,\n    token: 'a'.repeat(64),\n  })\n\n  // Get a test account from LocalNet\n  const testAccount = await algokit.getLocalNetDispenserAccount(algod)\n\n  console.log('Creating app client...')\n  // Create an app client that resolves by creator address and app name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: testAccount,\n      creatorAddress: testAccount.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  console.log('Deploying immutable and permanent application...')\n  console.log('WARNING: This app cannot be updated or deleted after deployment!\\n')\n\n  // Deploy the application with strict constraints\n  const result = await client.deploy({\n    // Prevent deletion - app will be permanent\n    allowDelete: false,\n    // Prevent updates - app will be immutable\n    allowUpdate: false,\n    // Fail if there's a schema break (since we can't update anyway)\n    onSchemaBreak: 'fail',\n    // Fail if an update is attempted (since we don't allow updates)\n    onUpdate: 'fail',\n    // Set deploy-time parameters\n    deployTimeParams: {\n      VALUE: 1,\n    },\n  })\n\n  // Display the results\n  console.log('\\n=== Application Deployed Successfully ===')\n  console.log(`App ID: ${result.appId}`)\n  console.log(`App Address: ${result.appAddress}`)\n  console.log(`Operation Performed: ${result.operationPerformed}`)\n  console.log('\\n=== Configuration ===')\n  console.log(`Updatable: false (IMMUTABLE)`)\n  console.log(`Deletable: false (PERMANENT)`)\n  console.log(`\\nThis application is now locked and cannot be modified or deleted.`)\n  console.log(`This is ideal for production contracts where immutability is critical.`)\n\n  return result\n}\n\n// Run the example\ndeployImmutablePermanentApp()\n  .then(() => {\n    console.log('\\nExample completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })\n"
    },
    {
      "example_id": "50-deploy-an-immutable-and-permanent-application",
      "title": "Deploy an Immutable and Permanent Application",
      "summary": "Demonstrates how to deploy an application that cannot be updated or deleted, ensuring code immutability and permanence on the blockchain.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an immutable and permanent application",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "deletable flag",
        "updatable flag",
        "onSchemaBreak",
        "onUpdate",
        "deployTimeParams"
      ],
      "feature_tags": [
        "deployment",
        "immutable",
        "permanent",
        "app-factory",
        "constraints",
        "smart-contracts"
      ],
      "folder": "50-deploy-an-immutable-and-permanent-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run example"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "App ID: <number>",
        "App Address: <address>",
        "Operation Performed: create",
        "The app is now immutable (cannot be updated) and permanent (cannot be deleted)"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - can still deploy when immutable and permanent"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "hello_world.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple example contract for demonstration"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "This example demonstrates how to deploy an application with strict constraints that ensure the application code cannot be modified or deleted after deployment. This is useful for creating trustless, verifiable smart contracts.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppFactory } from '@algorandfoundation/algokit-utils/types/app-factory'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to deploy an immutable and permanent application.\n * \n * An immutable app cannot be updated after deployment.\n * A permanent app cannot be deleted after deployment.\n * \n * This ensures code immutability and is useful for creating trustless smart contracts.\n */\n\nasync function deployImmutablePermanentApp() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const deployer = await algorand.account.fromEnvironment('DEPLOYER', algosdk.algodClient)\n  \n  // Create an app factory instance\n  // Note: You need to provide your app spec here\n  // This example assumes you have compiled your smart contract\n  const appSpec = {\n    // Your application specification\n    hints: {\n      deploy_time_params: {\n        VALUE: {\n          type: 'uint64',\n          source: 'constant'\n        }\n      }\n    }\n  }\n  \n  const factory = algorand.client.getAppFactory({\n    appSpec,\n    defaultSender: deployer.addr,\n  })\n  \n  console.log('Deploying immutable and permanent application...')\n  \n  // Deploy the application with constraints:\n  // - deletable: false - the app cannot be deleted\n  // - updatable: false - the app cannot be updated\n  // - onSchemaBreak: 'fail' - fail if schema changes are detected\n  // - onUpdate: 'fail' - fail on any update attempts\n  const { result } = await factory.deploy({\n    deletable: false,      // Application cannot be deleted\n    updatable: false,      // Application cannot be updated\n    onSchemaBreak: 'fail', // Fail if schema changes detected\n    onUpdate: 'fail',      // Fail on update attempts\n    deployTimeParams: {\n      VALUE: 1,            // Deploy-time parameter\n    },\n  })\n  \n  console.log('\\n\u2705 Application deployed successfully!')\n  console.log(`App ID: ${result.appId}`)\n  console.log(`App Address: ${result.appAddress}`)\n  console.log(`Operation Performed: ${result.operationPerformed}`)\n  console.log(`\\n\ud83d\udd12 The application is now:`)\n  console.log('  - IMMUTABLE: Cannot be updated')\n  console.log('  - PERMANENT: Cannot be deleted')\n  console.log('\\nThis ensures the contract code is trustless and verifiable.')\n  \n  return result\n}\n\n// Run the example\ndeployImmutablePermanentApp()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "51-detect-network-environment-localnet-vs-testnetmainnet",
      "title": "Detect Network Environment (LocalNet vs TestNet/MainNet)",
      "summary": "Demonstrates how to detect whether an Algorand client is connected to LocalNet or a public network, enabling environment-specific application logic.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Detect whether a client is connected to LocalNet for environment-specific logic",
      "target_users": [
        "SDK developers",
        "Backend developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getDefaultLocalNetConfig",
        "ClientManager.getAlgoNodeConfig",
        "ClientManager.isLocalNet"
      ],
      "feature_tags": [
        "client-configuration",
        "network-detection",
        "localnet",
        "testnet",
        "environment-detection",
        "client-manager"
      ],
      "folder": "51-detect-network-environment-localnet-vs-testnetmainnet",
      "prerequisites": {
        "tools": [
          "algokit (optional, for running LocalNet)"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "(Optional) Start LocalNet with: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "LocalNet detection result (true if LocalNet is running)",
        "TestNet detection result (false, confirming it's not LocalNet)",
        "Environment-specific configuration based on network type",
        "Informative messages about network safety and configuration"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Determine LocalNet algod client is LocalNet"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Determine TestNet algod client is not LocalNet"
        }
      ],
      "artifacts_plan": [],
      "notes": "The LocalNet check will fail gracefully if LocalNet is not running. The example demonstrates both scenarios and shows practical use cases for environment detection. This is particularly useful for applications that need to behave differently in development vs production environments.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to detect which network environment\n * your Algorand client is connected to. This is useful for:\n * - Running different logic in development vs production\n * - Adjusting transaction fees or timeouts based on environment\n * - Displaying appropriate UI messages to users\n * - Preventing accidental production operations in development\n */\n\nasync function checkNetworkEnvironment() {\n  console.log('=== Network Detection Example ===\\n')\n\n  // Example 1: Check if connected to LocalNet\n  console.log('1. Checking LocalNet connection...')\n  const localNetConfig = ClientManager.getDefaultLocalNetConfig('algod')\n  console.log('   LocalNet config:', localNetConfig.server)\n  \n  const localAlgod = ClientManager.getAlgodClient(localNetConfig)\n  const localManager = new ClientManager({ algod: localAlgod })\n  \n  try {\n    const isLocal = await localManager.isLocalNet()\n    console.log(`   \u2713 Is LocalNet: ${isLocal}`)\n    \n    if (isLocal) {\n      console.log('   \u2192 Running in development mode - safe to reset network state')\n    }\n  } catch (error) {\n    console.log('   \u2717 LocalNet not available (this is expected if LocalNet is not running)')\n    console.log('   ', error.message)\n  }\n\n  console.log()\n\n  // Example 2: Check if TestNet is correctly identified as NOT LocalNet\n  console.log('2. Checking TestNet connection...')\n  const testNetConfig = ClientManager.getAlgoNodeConfig('testnet', 'algod')\n  console.log('   TestNet config:', testNetConfig.server)\n  \n  const testNetAlgod = ClientManager.getAlgodClient(testNetConfig)\n  const testNetManager = new ClientManager({ algod: testNetAlgod })\n  \n  try {\n    const isLocal = await testNetManager.isLocalNet()\n    console.log(`   \u2713 Is LocalNet: ${isLocal}`)\n    \n    if (!isLocal) {\n      console.log('   \u2192 Running on public network - use production safety measures')\n    }\n  } catch (error) {\n    console.error('   \u2717 Failed to connect to TestNet:', error.message)\n  }\n\n  console.log()\n\n  // Example 3: Practical use case - environment-specific configuration\n  console.log('3. Environment-specific configuration example...')\n  \n  async function getOptimalTransactionParams(clientManager: ClientManager) {\n    const isLocal = await clientManager.isLocalNet()\n    \n    if (isLocal) {\n      return {\n        fee: 1000, // Minimum fee for LocalNet\n        timeout: 4, // Short timeout OK for LocalNet\n        note: 'Development transaction'\n      }\n    } else {\n      return {\n        fee: 1000, // Minimum fee, but might want higher for production\n        timeout: 20, // Longer timeout for public networks\n        note: 'Production transaction'\n      }\n    }\n  }\n  \n  try {\n    const params = await getOptimalTransactionParams(testNetManager)\n    console.log('   Optimal params for current network:', params)\n  } catch (error) {\n    console.log('   Could not determine network-specific params')\n  }\n\n  console.log('\\n=== Network detection complete ===')\n}\n\ncheckNetworkEnvironment().catch(console.error)"
    },
    {
      "example_id": "52-detect-network-type-mainnet-vs-localnet",
      "title": "Detect Network Type (MainNet vs LocalNet)",
      "summary": "Demonstrates how to verify whether an Algorand client is connected to LocalNet or a public network like MainNet, which is critical for preventing accidental use of test behavior in production.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "configuration",
      "specific_use_case": "Verify that MainNet connections are correctly identified as not being LocalNet",
      "target_users": [
        "SDK developers",
        "Backend developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getAlgoNodeConfig",
        "ClientManager.isLocalNet"
      ],
      "feature_tags": [
        "network-detection",
        "mainnet",
        "localnet",
        "client-configuration",
        "configuration"
      ],
      "folder": "52-detect-network-type-mainnet-vs-localnet",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "MainNet client is LocalNet: false",
        "TestNet client is LocalNet: false",
        "Connected to production network - using production mode"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Determine MainNet algod client is not LocalNet"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example connects to public networks (MainNet/TestNet) via AlgoNode. No LocalNet setup is required. The isLocalNet() method checks the genesis hash to determine network type.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to detect whether an Algorand client\n * is connected to LocalNet or a public network (MainNet/TestNet).\n * \n * This is critical for:\n * - Preventing accidental use of test behavior in production\n * - Conditional logic based on network type\n * - Deployment safety checks\n */\n\nasync function detectNetworkType() {\n  console.log('=== Network Type Detection Example ===')\n  console.log()\n\n  // Create an algod client configured for MainNet using AlgoNode\n  console.log('Creating MainNet algod client...')\n  const mainnetConfig = ClientManager.getAlgoNodeConfig('mainnet', 'algod')\n  const mainnetAlgod = ClientManager.getAlgodClient(mainnetConfig)\n  \n  // Check if the client is connected to LocalNet\n  console.log('Checking if MainNet client is LocalNet...')\n  const mainnetClientManager = new ClientManager({ algod: mainnetAlgod })\n  const isMainNetLocalNet = await mainnetClientManager.isLocalNet()\n  \n  console.log(`MainNet client is LocalNet: ${isMainNetLocalNet}`)\n  console.log()\n\n  // You can also check TestNet\n  console.log('Creating TestNet algod client...')\n  const testnetConfig = ClientManager.getAlgoNodeConfig('testnet', 'algod')\n  const testnetAlgod = ClientManager.getAlgodClient(testnetConfig)\n  \n  console.log('Checking if TestNet client is LocalNet...')\n  const testnetClientManager = new ClientManager({ algod: testnetAlgod })\n  const isTestNetLocalNet = await testnetClientManager.isLocalNet()\n  \n  console.log(`TestNet client is LocalNet: ${isTestNetLocalNet}`)\n  console.log()\n\n  // Example: Conditional logic based on network type\n  console.log('=== Practical Use Case ===')\n  if (isMainNetLocalNet) {\n    console.log('\u26a0\ufe0f  WARNING: Connected to LocalNet - using test mode')\n  } else {\n    console.log('\u2713 Connected to production network - using production mode')\n  }\n}\n\n// Run the example\ndetectNetworkType()\n  .then(() => {\n    console.log('\\n\u2713 Network detection complete')\n  })\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "53-format-algoamount-values-as-strings",
      "title": "Format AlgoAmount Values as Strings",
      "summary": "Demonstrates how to format AlgoAmount values (microAlgos, milliAlgos, Algos) as human-readable strings for UI display or logging purposes.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "amount formatting",
      "specific_use_case": "Format AlgoAmount values in different units as human-readable strings",
      "target_users": [
        "SDK developers",
        "Application developers"
      ],
      "features_tested": [
        "microAlgos",
        "AlgoAmount.toString",
        "AlgoAmount formatting"
      ],
      "feature_tags": [
        "amount",
        "formatting",
        "display",
        "microalgos",
        "string-conversion"
      ],
      "folder": "53-format-algoamount-values-as-strings",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Various AlgoAmount values formatted as strings with \u00b5ALGO symbol",
        "Demonstrations of microAlgos, milliAlgos, and Algos formatting",
        "Conversion between different units",
        "Practical examples showing logging and UI display use cases"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "toString on 1"
        }
      ],
      "artifacts_plan": [],
      "notes": "The AlgoAmount type automatically handles unit conversions and formatting. The toString() method uses the \u00b5ALGO symbol for microAlgos, making it ideal for logging and UI display.",
      "generated_code": "import { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\n\n/**\n * This example demonstrates how to format AlgoAmount values as human-readable strings.\n * \n * AlgoAmount provides convenient methods for working with Algorand's native currency\n * in different units:\n * - microAlgos (\u00b5ALGO): The smallest unit (1 ALGO = 1,000,000 \u00b5ALGO)\n * - milliAlgos (mALGO): 1 mALGO = 1,000 \u00b5ALGO\n * - Algos (ALGO): The standard unit\n * \n * The toString() method automatically formats amounts with the appropriate unit suffix.\n */\nfunction formatAlgoAmounts() {\n  console.log('=== Formatting AlgoAmount Values ===')\n  console.log()\n\n  // Format tiny amounts in microAlgos\n  const oneMicroAlgo = AlgoAmount.MicroAlgos(1)\n  console.log('1 microAlgo formatted:', `${oneMicroAlgo}`)\n  // Output: \"1 \u00b5ALGO\"\n\n  const hundredMicroAlgos = AlgoAmount.MicroAlgos(100)\n  console.log('100 microAlgos formatted:', `${hundredMicroAlgos}`)\n  // Output: \"100 \u00b5ALGO\"\n\n  // Format amounts in milliAlgos\n  const oneMilliAlgo = AlgoAmount.MilliAlgos(1)\n  console.log('1 milliAlgo formatted:', `${oneMilliAlgo}`)\n  // Output: \"1,000 \u00b5ALGO\" (automatically converted to base unit)\n\n  const tenMilliAlgos = AlgoAmount.MilliAlgos(10)\n  console.log('10 milliAlgos formatted:', `${tenMilliAlgos}`)\n  // Output: \"10,000 \u00b5ALGO\"\n\n  console.log()\n\n  // Format standard Algo amounts\n  const oneAlgo = AlgoAmount.Algos(1)\n  console.log('1 Algo formatted:', `${oneAlgo}`)\n  // Output: \"1,000,000 \u00b5ALGO\"\n\n  const tenAlgos = AlgoAmount.Algos(10)\n  console.log('10 Algos formatted:', `${tenAlgos}`)\n  // Output: \"10,000,000 \u00b5ALGO\"\n\n  console.log()\n\n  // Format fractional Algos\n  const halfAlgo = AlgoAmount.Algos(0.5)\n  console.log('0.5 Algos formatted:', `${halfAlgo}`)\n  // Output: \"500,000 \u00b5ALGO\"\n\n  console.log()\n  console.log('=== Converting Between Units ===')\n  console.log()\n\n  // You can also access different unit representations\n  const amount = AlgoAmount.Algos(5)\n  console.log(`5 ALGO equals:`)\n  console.log(`  - ${amount.microAlgos} microAlgos`)\n  console.log(`  - ${amount.algos} Algos`)\n  console.log(`  - String representation: ${amount}`)\n\n  console.log()\n  console.log('=== Practical Use Cases ===')\n  console.log()\n\n  // Logging transaction amounts\n  function logTransaction(sender: string, receiver: string, amount: AlgoAmount) {\n    console.log(`Transaction: ${sender} -> ${receiver}`)\n    console.log(`Amount: ${amount}`) // Automatically formatted!\n  }\n\n  logTransaction(\n    'SENDER123...', \n    'RECEIVER456...', \n    AlgoAmount.MicroAlgos(1000)\n  )\n\n  console.log()\n\n  // Display balance in UI\n  function displayBalance(address: string, balance: AlgoAmount) {\n    return `Account ${address} has a balance of ${balance}`\n  }\n\n  console.log(displayBalance(\n    'ACCOUNT789...',\n    AlgoAmount.Algos(42.5)\n  ))\n}\n\n// Run the example\nformatAlgoAmounts()"
    },
    {
      "example_id": "54-fund-accounts-on-testnet-using-dispenser-api",
      "title": "Fund Accounts on TestNet Using Dispenser API",
      "summary": "Demonstrates how to use the TestNet dispenser API with access token authentication for automated account funding on TestNet",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Fund accounts on TestNet using the dispenser API with access token authentication",
      "target_users": [
        "SDK developers",
        "TestNet developers",
        "Application developers",
        "Testing engineers"
      ],
      "features_tested": [
        "algorand.account.ensureFundedFromTestNetDispenserApi",
        "TestNetDispenserApiClient",
        "AlgorandClient.testNet"
      ],
      "feature_tags": [
        "testnet-funding",
        "dispenser-api",
        "access-token",
        "api-integration",
        "automated-funding",
        "testnet-development"
      ],
      "folder": "54-fund-accounts-on-testnet-using-dispenser-api",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "tsx"
        ],
        "environment": [
          {
            "name": "ALGOKIT_DISPENSER_ACCESS_TOKEN",
            "required": true,
            "example": "your_access_token_here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Obtain an access token from the AlgoKit dispenser service",
          "Set the environment variable: export ALGOKIT_DISPENSER_ACCESS_TOKEN=your_token"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils typescript tsx"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Connection to TestNet established",
        "New account created",
        "Funds requested from dispenser API",
        "Transaction ID and amount funded displayed",
        "Account balance verified on TestNet"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "ensureFunded uses dispenser api with access token successfully"
        }
      ],
      "artifacts_plan": [],
      "notes": "This is essential for TestNet development workflows. The dispenser API eliminates the manual process of requesting TestNet funds and is ideal for automated testing and CI/CD pipelines. Note that the API has rate limits to prevent abuse.",
      "generated_code": "import { AlgorandClient, TestNetDispenserApiClient } from '@algorandfoundation/algokit-utils'\nimport { algo } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use the TestNet dispenser API\n * to automatically fund accounts on TestNet.\n * \n * The TestNet dispenser API provides a convenient way to get TestNet ALGO\n * without manually requesting funds or managing dispenser accounts.\n * \n * Prerequisites:\n * - ALGOKIT_DISPENSER_ACCESS_TOKEN environment variable set\n * - You can get an access token from the AlgoKit dispenser service\n */\n\nasync function main() {\n  console.log('=== TestNet Dispenser API Funding ====')\n\n  /**\n   * Check for access token\n   * \n   * The ALGOKIT_DISPENSER_ACCESS_TOKEN environment variable is required\n   * to authenticate with the TestNet dispenser API.\n   */\n  const accessToken = process.env.ALGOKIT_DISPENSER_ACCESS_TOKEN\n  if (!accessToken) {\n    console.error('\u274c Error: ALGOKIT_DISPENSER_ACCESS_TOKEN environment variable not set')\n    console.log('\\nTo get an access token:')\n    console.log('1. Visit the AlgoKit dispenser service')\n    console.log('2. Register and obtain your access token')\n    console.log('3. Set it as an environment variable: export ALGOKIT_DISPENSER_ACCESS_TOKEN=your_token')\n    process.exit(1)\n  }\n\n  console.log('\u2705 Access token found')\n\n  /**\n   * Initialize AlgorandClient for TestNet\n   */\n  console.log('\\n1. Connecting to TestNet...')\n  const algorand = AlgorandClient.testNet()\n  console.log('   Connected to TestNet')\n\n  /**\n   * Create a dispenser API client\n   * \n   * This client handles communication with the TestNet dispenser API\n   */\n  console.log('\\n2. Initializing TestNet dispenser API client...')\n  const dispenserClient = new TestNetDispenserApiClient()\n  console.log('   Dispenser API client ready')\n\n  /**\n   * Create a random account to fund\n   */\n  console.log('\\n3. Creating a new account to fund...')\n  const accountToFund = algorand.account.random()\n  console.log(`   Account address: ${accountToFund.addr}`)\n\n  /**\n   * Fund the account using the TestNet dispenser API\n   * \n   * Parameters:\n   * - Account to fund\n   * - Dispenser API client\n   * - Minimum balance (100 ALGO)\n   * - Options: minFundingIncrement (0.1 ALGO minimum per transaction)\n   */\n  console.log('\\n4. Requesting funds from TestNet dispenser API...')\n  console.log('   Requested minimum: 100 ALGO')\n  console.log('   Minimum funding increment: 0.1 ALGO')\n  \n  try {\n    const result = await algorand.account.ensureFundedFromTestNetDispenserApi(\n      accountToFund.addr,\n      dispenserClient,\n      algo(100),\n      {\n        minFundingIncrement: algo(0.1),\n      }\n    )\n\n    if (result) {\n      console.log('\\n\u2705 Funding successful!')\n      console.log(`   Transaction ID: ${result.transactionId}`)\n      console.log(`   Amount funded: ${result.amountFunded.algo} ALGO (${result.amountFunded.microAlgo} microAlgos)`)\n    } else {\n      console.log('\\n\u2705 Account already has sufficient funds')\n    }\n\n    /**\n     * Verify the account balance on TestNet\n     */\n    console.log('\\n5. Verifying account balance on TestNet...')\n    const accountInfo = await algorand.account.getInformation(accountToFund.addr)\n    console.log(`   Balance: ${accountInfo.balance.algo} ALGO`)\n\n    console.log('\\n\ud83d\udcdd Key Takeaways:')\n    console.log('   \u2022 TestNet dispenser API provides automated funding for TestNet development')\n    console.log('   \u2022 Access token authentication ensures secure and rate-limited access')\n    console.log('   \u2022 No need to manually request TestNet ALGO from faucets')\n    console.log('   \u2022 Perfect for CI/CD pipelines and automated testing on TestNet')\n    console.log('   \u2022 Respects minFundingIncrement to optimize funding amounts')\n\n  } catch (error) {\n    console.error('\\n\u274c Error funding account:', error)\n    console.log('\\nPossible issues:')\n    console.log('   \u2022 Invalid access token')\n    console.log('   \u2022 Rate limit exceeded')\n    console.log('   \u2022 Network connectivity issues')\n    console.log('   \u2022 Dispenser API temporarily unavailable')\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "55-fund-application-account",
      "title": "Fund Application Account",
      "summary": "Demonstrates how to fund an application account with ALGOs to meet minimum balance requirements for state storage",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Fund an application account to cover minimum balance requirements",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.fundAppAccount",
        "payment transaction",
        "app account funding"
      ],
      "feature_tags": [
        "funding",
        "payment",
        "app-account",
        "minimum-balance",
        "transaction"
      ],
      "folder": "55-fund-application-account",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "TEST_ACCOUNT",
            "required": true,
            "example": "Your test account mnemonic or private key"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy your smart contract to get an app ID"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction details including type (pay), amount, sender, receiver (app address)",
        "Confirmation of successful funding with confirmed round number",
        "Success message indicating the app account was funded"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Fund app account"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "TestApp.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "A simple smart contract that accepts funding is needed for this example"
        }
      ],
      "notes": "This example shows the fundamental pattern for funding application accounts, which is necessary before the app can store data in boxes or maintain global/local state beyond the minimum.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { TransactionType } from 'algosdk'\nimport { TestAppClient } from './artifacts/TestApp/client' // Adjust import based on your app\n\n/**\n * Example: Fund Application Account\n * \n * This example demonstrates how to fund an application's account with ALGOs.\n * Applications need funds to cover minimum balance requirements for their state storage.\n */\nasync function fundAppAccount() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n  \n  // Get a test account (sender of funds)\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('\\n--- Fund Application Account Example ---\\n')\n  \n  // Deploy your application first (this would be your actual deployment logic)\n  // For this example, assume we have a deployed app client\n  const appClient = new TestAppClient(\n    {\n      sender: testAccount,\n      resolveBy: 'id',\n      id: 0, // Your app ID\n    },\n    algorand.client.algod\n  )\n  \n  // Define the amount to fund (200,000 microAlgos = 0.2 ALGO)\n  const fundAmount = algokit.microAlgo(200_000)\n  \n  console.log(`Funding app account with ${fundAmount.microAlgo} microAlgos (${fundAmount.algo} ALGO)...`)\n  \n  // Fund the application account\n  const result = await appClient.fundAppAccount({\n    amount: fundAmount,\n  })\n  \n  // Display transaction details\n  console.log('\\nTransaction Details:')\n  console.log(`  Transaction Type: ${result.transaction.type}`)\n  console.log(`  Amount: ${result.transaction.payment?.amount} microAlgos`)\n  console.log(`  Sender: ${result.transaction.sender.toString()}`)\n  console.log(`  Receiver (App Address): ${result.transaction.payment?.receiver?.toString()}`)\n  console.log(`  Confirmed Round: ${result.confirmation?.confirmedRound}`)\n  \n  // Verify the transaction\n  if (result.transaction.type === TransactionType.pay) {\n    console.log('\\n\u2705 Successfully funded the application account!')\n  }\n  \n  return result\n}\n\n// Run the example\nfundAppAccount().catch(console.error)"
    },
    {
      "example_id": "56-fund-an-application-account",
      "title": "Fund an Application Account",
      "summary": "Demonstrates how to fund an application account to cover minimum balance requirements. Applications need funding to hold algos, create assets, or use box storage.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app account management",
      "specific_use_case": "Fund an application account to cover minimum balance requirements",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.fundAppAccount",
        "app account funding",
        "payment transactions"
      ],
      "feature_tags": [
        "app-account",
        "funding",
        "minimum-balance",
        "payment",
        "app-client"
      ],
      "folder": "56-fund-an-application-account",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application deployed with ID",
        "Application address shown",
        "App account balance before funding",
        "Funding transaction sent",
        "Transaction details (type, amount, sender, receiver)",
        "Confirmation round number",
        "App account balance after funding",
        "Balance increase verified"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Fund app account"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple contract for demonstration"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        },
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining minimum balance requirements and use cases"
        }
      ],
      "notes": "This is a fundamental operation for smart contract applications. The example shows how to properly fund an app account and verify the transaction.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { TransactionType } from 'algosdk'\n\n/**\n * This example demonstrates how to fund an application account.\n * \n * Applications need funding for:\n * - Minimum balance requirements\n * - Creating assets\n * - Using box storage\n * - Sending inner transactions\n * - Holding algos for various operations\n */\n\nasync function fundAppAccount() {\n  // Initialize the AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.localNet.dispenser()\n  \n  console.log('Deploying application...')\n  \n  // Deploy your application\n  const appClient = algorand.client.getTypedAppClient({\n    sender: testAccount,\n    // Your app spec here\n  })\n  \n  await appClient.create.bare()\n  const app = await appClient.appClient.getAppReference()\n  \n  console.log(`Application deployed with ID: ${app.appId}`)\n  console.log(`Application address: ${app.appAddress}`)\n  \n  // Check the app account balance before funding\n  const accountInfoBefore = await algod.accountInformation(app.appAddress).do()\n  console.log(`\\nApp account balance before funding: ${accountInfoBefore.amount} microAlgos`)\n  \n  // Define the amount to fund (200,000 microAlgos = 0.2 Algos)\n  const fundAmount = algokit.microAlgo(200_000)\n  console.log(`\\nFunding app account with ${fundAmount.microAlgo} microAlgos (${fundAmount.algo} Algos)...`)\n  \n  // Fund the application account\n  const result = await appClient.fundAppAccount({\n    amount: fundAmount,\n  })\n  \n  // Verify the transaction details\n  console.log('\\n\u2705 App account funded successfully!')\n  console.log('\\nTransaction Details:')\n  console.log(`  Type: ${result.transaction.type}`)\n  console.log(`  Amount: ${result.transaction.payment?.amount} microAlgos`)\n  console.log(`  From: ${result.transaction.sender.toString()}`)\n  console.log(`  To: ${result.transaction.payment?.receiver?.toString()}`)\n  console.log(`  Confirmed in round: ${result.confirmation?.confirmedRound}`)\n  \n  // Verify the transaction is a payment type\n  if (result.transaction.type === TransactionType.pay) {\n    console.log('\\n\u2713 Transaction type is payment')\n  }\n  \n  // Verify the receiver is the app address\n  if (result.transaction.payment?.receiver?.toString() === app.appAddress) {\n    console.log('\u2713 Receiver is the application address')\n  }\n  \n  // Verify the sender is the test account\n  if (result.transaction.sender.toString() === testAccount.toString()) {\n    console.log('\u2713 Sender is the test account')\n  }\n  \n  // Check the app account balance after funding\n  const accountInfoAfter = await algod.accountInformation(app.appAddress).do()\n  console.log(`\\nApp account balance after funding: ${accountInfoAfter.amount} microAlgos`)\n  console.log(`Balance increased by: ${accountInfoAfter.amount - accountInfoBefore.amount} microAlgos`)\n  \n  console.log('\\n\ud83d\udcdd Use cases for funding app accounts:')\n  console.log('  - Minimum balance for app existence')\n  console.log('  - Box storage requires 2,500 + 400 per byte')\n  console.log('  - Asset creation requires 100,000 microAlgos')\n  console.log('  - Inner transactions need sufficient balance')\n  console.log('  - Holding algos for application logic')\n}\n\nfundAppAccount().catch(console.error)"
    },
    {
      "example_id": "57-fund-and-manage-testnet-accounts-with-dispenser-api",
      "title": "Fund and Manage TestNet Accounts with Dispenser API",
      "summary": "Demonstrates how to use the TestNet Dispenser API client to fund accounts, check funding limits, and register refunds for TestNet Algos with authentication",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account funding",
      "specific_use_case": "Fund TestNet accounts, check dispenser limits, and refund unused Algos using authenticated API calls",
      "target_users": [
        "Algorand developers",
        "SDK developers",
        "TestNet users"
      ],
      "features_tested": [
        "TestNetDispenserApiClient.fund",
        "TestNetDispenserApiClient.getLimit",
        "TestNetDispenserApiClient.refund",
        "TestNetDispenserApiClient constructor with authToken"
      ],
      "feature_tags": [
        "dispenser",
        "testnet",
        "funding",
        "refund",
        "authentication",
        "account-management",
        "rate-limiting"
      ],
      "folder": "57-fund-and-manage-testnet-accounts-with-dispenser-api",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "DISPENSER_AUTH_TOKEN",
            "required": true,
            "example": "your-dispenser-auth-token"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Get your dispenser auth token from https://dispenser.testnet.aws.algodev.network/",
          "Set the DISPENSER_AUTH_TOKEN environment variable or update the code with your token",
          "Replace RECIPIENT_ADDRESS_HERE with an actual Algorand address to fund"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Display of current funding limit in microAlgos and Algos",
        "Confirmation of successful account funding with transaction ID",
        "Confirmation of refund registration",
        "Error messages if operations fail"
      ],
      "source_tests": [
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should fund account with Algo with auth token"
        },
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should register refund with auth token"
        },
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should get limit with auth token"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example groups all three dispenser operations into a single comprehensive example. Users will need a valid TestNet dispenser auth token to run this example. The dispenser has rate limits, so checking limits before funding is a best practice. Refunds help developers stay within limits and are encouraged when funds are no longer needed.",
      "generated_code": "import { TestNetDispenserApiClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use the TestNet Dispenser API client\n * to fund accounts, check limits, and register refunds.\n * \n * The dispenser helps developers get TestNet Algos for testing purposes.\n */\n\nasync function main() {\n  // Initialize the dispenser client with your authentication token\n  // Get your auth token from: https://dispenser.testnet.aws.algodev.network/\n  const authToken = process.env.DISPENSER_AUTH_TOKEN || 'your-auth-token-here'\n  const dispenserClient = new TestNetDispenserApiClient({ authToken })\n\n  // Example 1: Check your current funding limit\n  console.log('\\n--- Checking Funding Limit ---')\n  try {\n    const limitResponse = await dispenserClient.getLimit()\n    console.log(`Current available limit: ${limitResponse.amount} microAlgos`)\n    console.log(`That's ${limitResponse.amount / 1_000_000} Algos`)\n  } catch (error) {\n    console.error('Error checking limit:', error)\n  }\n\n  // Example 2: Fund an account with Algos\n  console.log('\\n--- Funding an Account ---')\n  const recipientAddress = 'RECIPIENT_ADDRESS_HERE' // Replace with actual address\n  const amountToFund = 5_000_000 // 5 Algos in microAlgos\n\n  try {\n    const fundResponse = await dispenserClient.fund(recipientAddress, amountToFund)\n    console.log(`Successfully funded account!`)\n    console.log(`Transaction ID: ${fundResponse.txId}`)\n    console.log(`Amount sent: ${fundResponse.amount} microAlgos`)\n  } catch (error) {\n    console.error('Error funding account:', error)\n  }\n\n  // Example 3: Register a refund to return unused funds\n  console.log('\\n--- Registering a Refund ---')\n  const refundTransactionId = 'YOUR_REFUND_TRANSACTION_ID' // Transaction ID of the refund payment\n\n  try {\n    await dispenserClient.refund(refundTransactionId)\n    console.log(`Refund registered successfully for transaction: ${refundTransactionId}`)\n    console.log('This helps you stay within rate limits and makes funds available for others')\n  } catch (error) {\n    console.error('Error registering refund:', error)\n  }\n\n  console.log('\\n--- Complete ---')\n}\n\nmain().catch(console.error)\n"
    },
    {
      "example_id": "58-handle-missing-environment-configuration",
      "title": "Handle Missing Environment Configuration",
      "summary": "Demonstrates proper error handling when attempting to retrieve indexer configuration without required environment variables. This helps developers understand configuration requirements and debug setup issues.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Verify that attempting to get indexer config without required environment variables throws a descriptive error",
      "target_users": [
        "SDK developers",
        "Backend developers"
      ],
      "features_tested": [
        "ClientManager.getIndexerConfigFromEnvironment",
        "error handling"
      ],
      "feature_tags": [
        "error-handling",
        "configuration",
        "environment-variables",
        "indexer",
        "validation"
      ],
      "folder": "58-handle-missing-environment-configuration",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript",
          "ts-node"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Error message indicating missing INDEXER_SERVER environment variable",
        "Demonstration of correct configuration with environment variables set",
        "Successful configuration retrieval and indexer client creation",
        "Summary of key takeaways about required environment variables"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Throws error when getting indexer config when no environment defined"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates both failure and success cases, helping developers understand what environment variables are required and how to handle configuration errors properly. It includes cleanup to avoid affecting other code.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to handle missing environment configuration\n * when attempting to get indexer client configuration.\n * \n * The ClientManager can load configuration from environment variables,\n * but it will throw descriptive errors if required variables are missing.\n * This helps developers understand what configuration is needed.\n */\n\nfunction demonstrateMissingConfig() {\n  console.log('Example: Handling Missing Environment Configuration\\n')\n  \n  // Save current environment variables (if any)\n  const savedServer = process.env.INDEXER_SERVER\n  const savedPort = process.env.INDEXER_PORT\n  const savedToken = process.env.INDEXER_TOKEN\n  \n  try {\n    // Clear environment variables to simulate missing configuration\n    console.log('Simulating missing environment configuration...')\n    delete process.env.INDEXER_SERVER\n    delete process.env.INDEXER_PORT\n    delete process.env.INDEXER_TOKEN\n    \n    console.log('\\nAttempting to get indexer config from environment...')\n    \n    // This will throw an error because INDEXER_SERVER is not defined\n    const config = ClientManager.getIndexerConfigFromEnvironment()\n    \n    // This line won't be reached\n    console.log('Config retrieved:', config)\n    \n  } catch (error) {\n    // Expected error: descriptive message about missing configuration\n    console.log('\\n\u274c Expected Error Caught:')\n    console.log(`   ${error instanceof Error ? error.message : error}`)\n    console.log('\\nThis error tells developers exactly what\\'s missing!')\n  } finally {\n    // Restore original environment variables\n    if (savedServer !== undefined) process.env.INDEXER_SERVER = savedServer\n    if (savedPort !== undefined) process.env.INDEXER_PORT = savedPort\n    if (savedToken !== undefined) process.env.INDEXER_TOKEN = savedToken\n  }\n}\n\nfunction demonstrateCorrectConfig() {\n  console.log('\\n\\n' + '='.repeat(60))\n  console.log('Example: Correct Environment Configuration\\n')\n  \n  // Set required environment variables\n  process.env.INDEXER_SERVER = 'https://testnet-idx.algonode.cloud'\n  process.env.INDEXER_PORT = '443'\n  process.env.INDEXER_TOKEN = ''  // AlgoNode doesn't require a token\n  \n  console.log('Setting environment variables:')\n  console.log(`  INDEXER_SERVER=${process.env.INDEXER_SERVER}`)\n  console.log(`  INDEXER_PORT=${process.env.INDEXER_PORT}`)\n  console.log(`  INDEXER_TOKEN=${process.env.INDEXER_TOKEN || '(empty)'}`)  \n  \n  try {\n    console.log('\\nAttempting to get indexer config from environment...')\n    const config = ClientManager.getIndexerConfigFromEnvironment()\n    \n    console.log('\\n\u2705 Configuration Retrieved Successfully:')\n    console.log(`   Server: ${config.server}`)\n    console.log(`   Port: ${config.port}`)\n    console.log(`   Token: ${config.token || '(empty)'}`)    \n    \n    // Create an indexer client with the configuration\n    const indexer = ClientManager.getIndexerClient(config)\n    console.log('\\n\u2705 Indexer client created successfully!')\n    \n  } catch (error) {\n    console.error('\\n\u274c Unexpected Error:', error)\n  }\n}\n\nfunction main() {\n  console.log('Environment Configuration Examples')\n  console.log('='.repeat(60))\n  \n  // First, demonstrate what happens with missing configuration\n  demonstrateMissingConfig()\n  \n  // Then, show the correct way to configure\n  demonstrateCorrectConfig()\n  \n  console.log('\\n' + '='.repeat(60))\n  console.log('\\nKey Takeaways:')\n  console.log('1. INDEXER_SERVER environment variable is required')\n  console.log('2. INDEXER_PORT and INDEXER_TOKEN are optional (have defaults)')\n  console.log('3. Error messages clearly indicate what\\'s missing')\n  console.log('4. Always handle configuration errors gracefully in production')\n}\n\nmain()"
    },
    {
      "example_id": "59-handle-testnet-dispenser-api-errors",
      "title": "Handle TestNet Dispenser API Errors",
      "summary": "Demonstrates proper error handling when the TestNet dispenser API fails to fund an account, important for building robust applications with graceful failure handling.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Handle errors when the TestNet dispenser API fails to fund an account",
      "target_users": [
        "SDK developers",
        "TestNet developers",
        "Application developers"
      ],
      "features_tested": [
        "algorand.account.ensureFundedFromTestNetDispenserApi",
        "TestNetDispenserApiClient",
        "error handling"
      ],
      "feature_tags": [
        "testnet",
        "dispenser",
        "error-handling",
        "funding",
        "api-error"
      ],
      "folder": "59-handle-testnet-dispenser-api-errors",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOKIT_DISPENSER_ACCESS_TOKEN",
            "required": true,
            "example": "your_dispenser_access_token"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Obtain a TestNet dispenser access token from the AlgoKit dispenser service"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "Set ALGOKIT_DISPENSER_ACCESS_TOKEN environment variable",
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Account address is logged",
        "Attempt to fund message is displayed",
        "Error message is caught and logged showing the dispenser API failure"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "ensureFunded uses dispenser api and fails with rejected response"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows error handling for dispenser API failures. In production, you should implement retry logic and fallback strategies.",
      "generated_code": "import { AlgorandClient, TestNetDispenserApiClient } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\n\n/**\n * This example demonstrates how to handle errors when the TestNet dispenser API\n * fails to fund an account. This is important for building robust applications\n * that can gracefully handle external API failures.\n */\nasync function handleDispenserErrors() {\n  // Set up the dispenser access token (required for using the dispenser API)\n  process.env.ALGOKIT_DISPENSER_ACCESS_TOKEN = 'your_dispenser_access_token'\n\n  // Create an Algorand client connected to TestNet\n  const algorand = AlgorandClient.testNet()\n\n  // Create a dispenser client for funding accounts on TestNet\n  const dispenserClient = new TestNetDispenserApiClient()\n\n  // Create a random account that we want to fund\n  const accountToFund = algorand.account.random()\n  \n  console.log('Account to fund:', accountToFund.addr)\n  console.log('Attempting to fund account with 100 ALGO...')\n\n  try {\n    // Attempt to fund the account using the dispenser API\n    // This will request 100 ALGO with a minimum funding increment of 1 ALGO\n    await algorand.account.ensureFundedFromTestNetDispenserApi(\n      accountToFund,\n      dispenserClient,\n      AlgoAmount.Algos(100),\n      {\n        minFundingIncrement: AlgoAmount.Algos(1),\n      }\n    )\n    \n    console.log('Account funded successfully!')\n  } catch (error) {\n    // Handle any errors that occur during the funding process\n    // Common errors include:\n    // - Network connectivity issues\n    // - Invalid dispenser access token\n    // - Rate limiting\n    // - Dispenser service unavailability\n    console.error('Failed to fund account from TestNet dispenser:')\n    console.error('Error message:', (error as Error).message)\n    \n    // In a real application, you might want to:\n    // - Retry with exponential backoff\n    // - Fall back to an alternative funding method\n    // - Alert the user or log the error for monitoring\n    // - Check if the account already has sufficient funds\n  }\n}\n\n// Run the example\nhandleDispenserErrors().catch(console.error)"
    },
    {
      "example_id": "60-handling-empty-byte-arrays-in-abi-types",
      "title": "Handling Empty Byte Arrays in ABI Types",
      "summary": "Learn to handle edge cases with empty byte arrays in ABI type conversion. This example demonstrates zero-length array handling, ensuring robust smart contract code that works in all scenarios.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "ABI type conversion",
      "specific_use_case": "Convert empty byte arrays (byte[0]) to empty Uint8Array for edge case handling",
      "target_users": [
        "Smart contract developers",
        "SDK developers"
      ],
      "features_tested": [
        "convertAbiByteArrays",
        "ABIArrayStaticType",
        "ABIByteType",
        "empty arrays",
        "edge case handling"
      ],
      "feature_tags": [
        "abi",
        "edge-cases",
        "empty-arrays",
        "byte-arrays",
        "type-conversion",
        "robustness",
        "smart-contracts",
        "algosdk"
      ],
      "folder": "60-handling-empty-byte-arrays-in-abi-types",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Created empty byte array type: byte[0]",
        "Converting empty array to ABI format",
        "Result is a Uint8Array with length 0",
        "Empty array handling verified",
        "Edge case handled correctly"
      ],
      "source_tests": [
        {
          "file": "src/util.spec.ts",
          "test_name": "should handle empty byte arrays"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates important edge case handling. While simple, ensuring empty arrays are properly handled is crucial for production smart contract code. Empty arrays can occur in various scenarios and must be handled gracefully to prevent errors.",
      "generated_code": "import {\n  ABIByteType,\n  ABIArrayStaticType,\n  convertAbiByteArrays,\n} from '@algorandfoundation/algokit-utils'\n\n/**\n * Demonstrates handling of empty byte arrays in ABI type conversion.\n * \n * This example shows how to:\n * 1. Define zero-length byte array types\n * 2. Convert empty arrays to ABI format\n * 3. Handle edge cases properly for robust smart contract code\n * \n * Edge case handling is crucial for production-ready applications.\n * Empty arrays can occur in various scenarios and must be handled gracefully.\n */\n\nfunction main() {\n  console.log('=== Handling Empty Byte Arrays in ABI Types ===\\n')\n\n  // Step 1: Define the empty byte array type\n  console.log('Step 1: Defining byte array type...')\n  const byteType = new ABIByteType()\n  console.log('\u2713 Created byte type')\n  \n  // Create a static array with 0 elements: byte[0]\n  const arrayType = new ABIArrayStaticType(byteType, 0)\n  console.log('\u2713 Created byte[0] - static array with 0 elements\\n')\n\n  // Step 2: Prepare empty array\n  console.log('Step 2: Preparing empty array...')\n  const value: number[] = []\n  console.log('Input value:', value)\n  console.log('Array length:', value.length)\n  console.log()\n\n  // Step 3: Convert to ABI format\n  console.log('Step 3: Converting to ABI format...')\n  const result = convertAbiByteArrays(value, arrayType)\n  console.log('\u2713 Conversion complete\\n')\n\n  // Step 4: Verify the result\n  console.log('Step 4: Verifying the result...')\n  console.log('Result type:', result.constructor.name)\n  console.log('Is Uint8Array:', result instanceof Uint8Array)\n  console.log('Array length:', (result as Uint8Array).length)\n  console.log()\n\n  // Step 5: Demonstrate edge case importance\n  console.log('Step 5: Why this matters...\\n')\n  console.log('Edge cases like empty arrays are important because:')\n  console.log('  \u2022 Smart contracts may return empty results')\n  console.log('  \u2022 Optional parameters might be empty')\n  console.log('  \u2022 Partial data structures may have empty fields')\n  console.log('  \u2022 Proper handling prevents runtime errors')\n  console.log()\n\n  // Summary\n  console.log('=== Summary ===')\n  console.log('\u2713 Successfully handled empty byte array (byte[0])')\n  console.log('\u2713 Converted to empty Uint8Array instance')\n  console.log('\u2713 Edge case handled gracefully')\n  console.log('\u2713 Ready for robust smart contract interactions')\n  console.log()\n  console.log('Best Practice: Always test edge cases like empty arrays')\n  console.log('to ensure your application handles all scenarios correctly.')\n}\n\n// Run the example\nmain()"
    },
    {
      "example_id": "61-idempotent-application-deployment",
      "title": "Idempotent Application Deployment",
      "summary": "Demonstrates idempotent application deployment that creates the app if it doesn't exist. Useful for automated deployments and CI/CD pipelines.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an application (create operation) with idempotent deployment",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "operationPerformed",
        "compiledApproval",
        "compiledClear",
        "appId",
        "appAddress",
        "confirmation"
      ],
      "feature_tags": [
        "deployment",
        "idempotent",
        "app-factory",
        "automation",
        "devops",
        "smart-contracts",
        "create"
      ],
      "folder": "61-idempotent-application-deployment",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run example"
        ]
      },
      "expected_output": [
        "Deploying application...",
        "Operation Performed: create",
        "App ID: <number>",
        "App Address: <address>",
        "Application Index from confirmation: <number>",
        "Compiled Approval Program: Available",
        "Compiled Clear Program: Available",
        "Deployment completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - create"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "hello_world.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple example contract for demonstration"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "Idempotent deployment is crucial for automation and CI/CD pipelines. It ensures that running the deployment multiple times produces the same result without errors.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppFactory } from '@algorandfoundation/algokit-utils/types/app-factory'\nimport { getApplicationAddress } from 'algosdk'\n\n/**\n * This example demonstrates idempotent application deployment.\n * \n * Idempotent deployment means:\n * - If the app doesn't exist, it will be created\n * - If the app already exists, it will be reused or updated based on configuration\n * - Running the deployment multiple times is safe\n * \n * This is essential for automated deployments and CI/CD pipelines.\n */\n\nasync function deployApplicationIdempotent() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const deployer = await algorand.account.fromEnvironment('DEPLOYER')\n  \n  // Create an app factory instance\n  // Note: Replace with your actual app spec\n  const appSpec = {\n    // Your application specification\n    hints: {\n      deploy_time_params: {\n        VALUE: {\n          type: 'uint64',\n          source: 'constant'\n        }\n      }\n    }\n  }\n  \n  const factory = algorand.client.getAppFactory({\n    appSpec,\n    defaultSender: deployer.addr,\n  })\n  \n  console.log('Deploying application with idempotent deployment...')\n  \n  // Deploy the application\n  // This will create the app if it doesn't exist\n  const { result: app } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1,  // Deploy-time parameter value\n    },\n  })\n  \n  // Check what operation was performed\n  console.log(`\\n\u2705 Operation Performed: ${app.operationPerformed}`)\n  \n  // Display app information\n  console.log(`\\n\ud83d\udcf1 Application Information:`)\n  console.log(`App ID: ${app.appId}`)\n  console.log(`App Address: ${app.appAddress}`)\n  \n  // Verify the app address matches the expected address for the app ID\n  const expectedAddress = getApplicationAddress(app.appId)\n  console.log(`\\n\u2713 App address verification: ${app.appAddress === expectedAddress ? 'PASSED' : 'FAILED'}`)\n  \n  // Display confirmation details\n  if (app.confirmation) {\n    console.log(`\\n\ud83d\udccb Confirmation Details:`)\n    console.log(`Application Index: ${app.confirmation.applicationIndex}`)\n    console.log(`Confirmed Round: ${app.confirmation.confirmedRound}`)\n  }\n  \n  // Display compiled programs\n  console.log(`\\n\ud83d\udcbe Compiled Programs:`)\n  console.log(`Approval Program: ${app.compiledApproval ? 'Available' : 'Not available'}`)\n  console.log(`Clear Program: ${app.compiledClear ? 'Available' : 'Not available'}`)\n  \n  console.log('\\n\u2705 Deployment completed successfully!')\n  console.log('\\n\ud83d\udca1 Tip: Running this deployment again will reuse the existing app')\n  console.log('   (if deployed with the same parameters and deployer account)')\n  \n  return app\n}\n\n// Run the example\ndeployApplicationIdempotent()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error('Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "62-look-up-account-information-using-indexer",
      "title": "Look Up Account Information Using Indexer",
      "summary": "Demonstrates how to retrieve account information from the Algorand Indexer by address, including waiting for indexer synchronization.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Look up an account by its address using the indexer after ensuring the indexer has caught up with the blockchain",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Wallet developers"
      ],
      "features_tested": [
        "algorand.client.indexer.lookupAccountByID",
        "account information retrieval",
        "indexer synchronization"
      ],
      "feature_tags": [
        "indexer",
        "account-lookup",
        "account-information",
        "localnet",
        "indexer-sync"
      ],
      "folder": "62-look-up-account-information-using-indexer",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Created test account: <address>",
        "Funded account with 5 ALGO",
        "Indexer has caught up!",
        "Account successfully verified!"
      ],
      "source_tests": [
        {
          "file": "src/indexer-lookup.spec.ts",
          "test_name": "Account is found by id"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the importance of waiting for indexer synchronization before querying account information. The indexer may be slightly behind the algod node, so polling or waiting is necessary for reliable results.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Example: Look Up Account Information Using Indexer\n * \n * This example demonstrates how to:\n * 1. Create and fund a test account\n * 2. Wait for the indexer to synchronize with the blockchain\n * 3. Look up account information by address using the indexer\n * 4. Display account details\n */\n\n/**\n * Helper function to wait for indexer to catch up\n * Repeatedly attempts to fetch account info until successful\n */\nasync function waitForIndexerSync(\n  indexer: algosdk.Indexer,\n  address: string,\n  maxAttempts: number = 10\n): Promise<void> {\n  for (let i = 0; i < maxAttempts; i++) {\n    try {\n      await indexer.lookupAccountByID(address).do()\n      console.log('Indexer has caught up!')\n      return\n    } catch (error) {\n      console.log(`Waiting for indexer to sync... (attempt ${i + 1}/${maxAttempts})`)\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n  }\n  throw new Error('Indexer did not catch up in time')\n}\n\nasync function lookupAccountByAddress() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get dispenser account for funding\n  const dispenser = await algorand.account.dispenser()\n  \n  // Create a new test account\n  const testAccount = await algorand.account.random()\n  console.log(`Created test account: ${testAccount.addr}`)\n  \n  // Fund the test account from dispenser\n  console.log('\\nFunding test account...')\n  const fundAmount = algosdk.algosToMicroalgos(5)\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: testAccount.addr,\n    amount: fundAmount,\n  })\n  console.log(`Funded account with ${algosdk.microalgosToAlgos(fundAmount)} ALGO`)\n  \n  // Wait for indexer to catch up with the blockchain\n  console.log('\\nWaiting for indexer to synchronize...')\n  await waitForIndexerSync(algorand.client.indexer, testAccount.addr)\n  \n  // Look up the account information using the indexer\n  console.log('\\nLooking up account information...')\n  const accountInfo = await algorand.client.indexer.lookupAccountByID(testAccount.addr).do()\n  \n  // Display account information\n  console.log('\\n=== Account Information ===')\n  console.log(`Address: ${accountInfo.account.address}`)\n  console.log(`Balance: ${accountInfo.account.amount} microAlgos (${algosdk.microalgosToAlgos(accountInfo.account.amount)} ALGO)`)\n  console.log(`Status: ${accountInfo.account.status}`)\n  console.log(`Round: ${accountInfo['current-round']}`)\n  console.log(`Pending Rewards: ${accountInfo.account['pending-rewards']} microAlgos`)\n  console.log(`Reward Base: ${accountInfo.account['reward-base']}`)\n  console.log(`Total Apps Opted In: ${accountInfo.account['total-apps-opted-in']}`)\n  console.log(`Total Assets Opted In: ${accountInfo.account['total-assets-opted-in']}`)\n  console.log(`Total Created Apps: ${accountInfo.account['total-created-apps']}`)\n  console.log(`Total Created Assets: ${accountInfo.account['total-created-assets']}`)\n  \n  // Verify the account address matches\n  if (accountInfo.account.address === testAccount.addr) {\n    console.log('\\n\u2713 Account successfully verified!')\n  } else {\n    console.log('\\n\u2717 Account address mismatch!')\n  }\n}\n\n// Run the example\nlookupAccountByAddress().catch(console.error)"
    },
    {
      "example_id": "63-look-up-transaction-by-id-using-indexer",
      "title": "Look Up Transaction by ID Using Indexer",
      "summary": "Demonstrates how to retrieve and verify a specific transaction from the blockchain using its transaction ID with the Algorand Indexer.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Look up a transaction by its ID using the indexer and verify it was recorded correctly",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Transaction monitoring systems"
      ],
      "features_tested": [
        "algorand.client.indexer.lookupTransactionByID",
        "transaction verification",
        "indexer synchronization"
      ],
      "feature_tags": [
        "indexer",
        "transaction-lookup",
        "transaction-verification",
        "localnet",
        "payment-transaction"
      ],
      "folder": "63-look-up-transaction-by-id-using-indexer",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction sent with ID: <transaction_id>",
        "Transaction successfully verified!",
        "Transaction confirmed on the blockchain"
      ],
      "source_tests": [
        {
          "file": "src/indexer-lookup.spec.ts",
          "test_name": "Transaction is found by id"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires a running LocalNet instance with both algod and indexer services. The indexer needs a few seconds to catch up and index new transactions.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Example: Look Up Transaction by ID Using Indexer\n * \n * This example demonstrates how to:\n * 1. Send a payment transaction to the Algorand blockchain\n * 2. Wait for the indexer to catch up and index the transaction\n * 3. Look up the transaction by its ID using the indexer\n * 4. Verify the transaction details\n */\n\nasync function lookupTransactionById() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get dispenser account for funding\n  const dispenser = await algorand.account.dispenser()\n  \n  // Create a test account\n  const sender = await algorand.account.random()\n  const receiver = await algorand.account.random()\n  \n  // Fund the sender account from dispenser\n  console.log('Funding sender account...')\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: sender.addr,\n    amount: algosdk.algosToMicroalgos(10),\n  })\n  \n  console.log('Sending test transaction...')\n  // Send a payment transaction\n  const result = await algorand.send.payment({\n    sender: sender.addr,\n    receiver: receiver.addr,\n    amount: algosdk.algosToMicroalgos(1),\n    signer: sender,\n  })\n  \n  const txId = result.transaction.txID()\n  console.log(`Transaction sent with ID: ${txId}`)\n  console.log(`First valid round: ${result.transaction.firstValid}`)\n  \n  // Wait for indexer to catch up and index the transaction\n  console.log('Waiting for indexer to index the transaction...')\n  await new Promise(resolve => setTimeout(resolve, 3000))\n  \n  // Look up the transaction by ID using the indexer\n  console.log('\\nLooking up transaction by ID...')\n  const txnInfo = await algorand.client.indexer.lookupTransactionByID(txId).do()\n  \n  // Display transaction information\n  console.log('\\n=== Transaction Information ===')\n  console.log(`Transaction ID: ${txnInfo.transaction.id}`)\n  console.log(`Current Round: ${txnInfo['current-round']}`)\n  console.log(`Sender: ${txnInfo.transaction.sender}`)\n  console.log(`Receiver: ${txnInfo.transaction['payment-transaction'].receiver}`)\n  console.log(`Amount: ${txnInfo.transaction['payment-transaction'].amount} microAlgos`)\n  console.log(`Round Time: ${txnInfo.transaction['round-time']}`)\n  console.log(`Confirmed Round: ${txnInfo.transaction['confirmed-round']}`)\n  \n  // Verify the transaction was found correctly\n  if (txnInfo.transaction.id === txId) {\n    console.log('\\n\u2713 Transaction successfully verified!')\n  } else {\n    console.log('\\n\u2717 Transaction ID mismatch!')\n  }\n  \n  // Verify the current round is at or after the first valid round\n  if (txnInfo['current-round'] >= result.transaction.firstValid) {\n    console.log('\u2713 Transaction confirmed on the blockchain')\n  }\n}\n\n// Run the example\nlookupTransactionById().catch(console.error)"
    },
    {
      "example_id": "64-rekey-an-account-to-another-account",
      "title": "Rekey an Account to Another Account",
      "summary": "Demonstrates how to perform account rekeying operations, allowing one account to be controlled by another account's keys. This is useful for key rotation, account recovery, and advanced security patterns.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Rekey one account to be controlled by another account and verify the auth address is correctly updated",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "Security engineers"
      ],
      "features_tested": [
        "generateAccount",
        "algorand.account.rekeyAccount",
        "algorand.account.getInformation",
        "algo"
      ],
      "feature_tags": [
        "account-management",
        "rekeying",
        "authorization-address",
        "security",
        "key-rotation"
      ],
      "folder": "64-rekey-an-account-to-another-account",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "Creating two accounts for rekeying demonstration...",
        "Original account address: <address1>",
        "New auth account address: <address2>",
        "Rekeying account...",
        "Account information after rekeying:",
        "- Account address: <address1>",
        "- Auth address (controlling account): <address2>",
        "Rekeying successful! The original account is now controlled by the new auth account."
      ],
      "source_tests": [
        {
          "file": "src/types/account-manager.spec.ts",
          "test_name": "Rekeyed account is retrievable"
        }
      ],
      "artifacts_plan": [],
      "notes": "Account rekeying is an important security feature that allows accounts to change their controlling keys without changing the account address. This is valuable for key rotation, account recovery, and advanced security patterns.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to perform account rekeying operations.\n * \n * Account rekeying allows one account to be controlled by another account's keys,\n * which is useful for:\n * - Key rotation and security upgrades\n * - Account recovery mechanisms\n * - Multi-signature and custody solutions\n * - Transferring control without changing the account address\n * \n * Key concepts:\n * - Original account address remains the same\n * - Auth address (authorization address) points to the controlling account\n * - Transactions for the rekeyed account must be signed by the auth account\n */\n\nasync function main() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n\n  console.log('Creating two accounts for rekeying demonstration...\\n')\n\n  // Step 1: Create the account that will be rekeyed\n  // This account needs funds to pay for the rekey transaction\n  const originalAccount = await algorand.account.random()\n  await algorand.send.payment({\n    sender: algorand.account.localNet().dispenser,\n    receiver: originalAccount.addr,\n    amount: microAlgos(1_000_000), // 1 ALGO\n  })\n  console.log(`Original account address: ${originalAccount.addr}`)\n\n  // Step 2: Create the account that will become the new authority\n  // This account also needs some funds for future transactions\n  const newAuthAccount = await algorand.account.random()\n  await algorand.send.payment({\n    sender: algorand.account.localNet().dispenser,\n    receiver: newAuthAccount.addr,\n    amount: microAlgos(100_000), // 0.1 ALGO\n  })\n  console.log(`New auth account address: ${newAuthAccount.addr}\\n`)\n\n  // Step 3: Rekey the original account to be controlled by the new auth account\n  console.log('Rekeying account...')\n  await algorand.account.rekeyAccount(originalAccount.addr, newAuthAccount)\n  console.log('Rekey transaction completed!\\n')\n\n  // Step 4: Retrieve and display the account information\n  const accountInfo = await algorand.account.getInformation(originalAccount.addr)\n  \n  console.log('Account information after rekeying:')\n  console.log(`- Account address: ${accountInfo.address.toString()}`)\n  console.log(`- Auth address (controlling account): ${accountInfo.authAddr?.toString()}\\n`)\n\n  // Verify the rekeying was successful\n  if (accountInfo.authAddr?.toString() === newAuthAccount.addr.toString()) {\n    console.log('\u2713 Rekeying successful!')\n    console.log('\\nThe original account is now controlled by the new auth account.')\n    console.log('All future transactions from the original account must be signed')\n    console.log('by the new auth account\\'s private key.')\n  } else {\n    console.log('\u2717 Rekeying failed - auth address does not match')\n  }\n}\n\nmain().catch(console.error)\n"
    },
    {
      "example_id": "65-rekey-an-algorand-account",
      "title": "Rekey an Algorand Account",
      "summary": "Demonstrates how to rekey an account to be controlled by a different private key while maintaining the same address. This is important for security and key management scenarios.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Rekey an account to be controlled by a different private key while maintaining the same address",
      "target_users": [
        "SDK developers",
        "Security engineers",
        "Account management developers"
      ],
      "features_tested": [
        "algorand.account.rekeyAccount",
        "algorand.send.payment",
        "signer parameter"
      ],
      "feature_tags": [
        "account",
        "rekey",
        "security",
        "key-management",
        "signature-delegation"
      ],
      "folder": "65-rekey-an-algorand-account",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Original account address is displayed",
        "New authorization account address is displayed",
        "Rekey operation completes successfully",
        "Verification payment transaction succeeds using the new signer",
        "Transaction ID is displayed confirming the rekey worked"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Rekey works"
        }
      ],
      "artifacts_plan": [],
      "notes": "IMPORTANT: After rekeying, you must use the new account's signer for all transactions from the original account. Keep the new account's private key secure as it now controls the original account.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\n\n/**\n * This example demonstrates account rekeying functionality.\n * \n * Rekeying allows you to change the private key that controls an account\n * WITHOUT changing the account's address. This is useful for:\n * - Key rotation for security purposes\n * - Transferring account control while maintaining the same address\n * - Implementing multi-signature or smart signature authorization\n */\nasync function rekeyAccount() {\n  // Create an Algorand client connected to LocalNet for testing\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a funded test account (on LocalNet, default accounts are pre-funded)\n  const originalAccount = algorand.account.fromEnvironment('ALGOD_TOKEN')\n  // Or create and fund a new account:\n  // const originalAccount = await algorand.account.fromEnvironment('DISPENSER')\n  \n  // For this example, let's use the default LocalNet dispenser account\n  const originalAccountInfo = await algorand.account.localNetDispenser()\n  \n  console.log('Original account address:', originalAccountInfo.addr)\n  console.log('Original account can sign transactions with its own private key')\n\n  // Create a second account that will become the new authorization for the first account\n  const newAuthAccount = algorand.account.random()\n  console.log('New authorization account address:', newAuthAccount.addr)\n\n  // Perform the rekey operation\n  // After this, originalAccount's address stays the same, but newAuthAccount's\n  // private key must be used to sign transactions FROM originalAccount\n  console.log('\\nRekeying the original account to be controlled by the new account...')\n  \n  await algorand.account.rekeyAccount(originalAccountInfo, newAuthAccount, {\n    note: 'Rekey for security purposes',\n  })\n  \n  console.log('Rekey successful!')\n  console.log('The original account address is still:', originalAccountInfo.addr)\n  console.log('But it must now use the new authorization account to sign transactions')\n\n  // Verify the rekey was successful by sending a transaction\n  // Notice: sender is originalAccount, but signer is newAuthAccount\n  console.log('\\nVerifying rekey by sending a payment from the rekeyed account...')\n  \n  const txn = await algorand.send.payment({\n    sender: originalAccountInfo.addr,  // The account address that's sending (unchanged)\n    receiver: originalAccountInfo.addr, // Sending to itself for demonstration\n    amount: AlgoAmount.MicroAlgos(1),\n    signer: newAuthAccount.signer,      // Must use the NEW account's signer after rekey!\n  })\n  \n  console.log('Payment successful! Transaction ID:', txn.txIds[0])\n  console.log('\\nThis confirms the rekey worked:')\n  console.log('- Transaction was sent FROM the original account address')\n  console.log('- But it was SIGNED by the new authorization account')\n  console.log('\\nNote: If you tried to sign with the original account\\'s key, it would fail!')\n}\n\n// Run the example\nrekeyAccount().catch(console.error)"
    },
    {
      "example_id": "66-replace-an-existing-application",
      "title": "Replace an Existing Application",
      "summary": "Demonstrates how to replace an existing Algorand application by deleting it and creating a new one. This is useful when making breaking changes that can't be handled by updates.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Replace an existing application by deleting it and creating a new one",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "onUpdate: 'replace'",
        "deleteResult",
        "operationPerformed",
        "deletable parameter"
      ],
      "feature_tags": [
        "app-deployment",
        "app-replacement",
        "delete-and-recreate",
        "idempotent-deployment",
        "factory-pattern",
        "deployment-strategy"
      ],
      "folder": "66-replace-an-existing-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial app deployed with a specific ID",
        "Replacement operation performed",
        "New app created with higher ID than original",
        "Old app deleted successfully",
        "Confirmation that replacement strategy worked"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - replace"
        }
      ],
      "artifacts_plan": [],
      "notes": "The app must be created with deletable: true initially, otherwise replacement will fail. The replace strategy is ideal for breaking changes that can't be handled by the update operation.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport * as algosdk from 'algosdk'\nimport { OnApplicationComplete } from 'algosdk'\n\n/**\n * This example demonstrates how to replace an existing Algorand application.\n * \n * The 'replace' strategy is useful when:\n * - You need to make breaking schema changes\n * - The existing app was marked as deletable\n * - You want a clean slate with a new app ID\n * \n * The process:\n * 1. Deploy an initial app (marked as deletable)\n * 2. Deploy again with onUpdate: 'replace'\n * 3. AlgoKit deletes the old app and creates a new one\n */\n\nasync function replaceApplicationExample() {\n  // Set up the testing environment with LocalNet\n  const localnet = await algorandFixture()\n  const { testAccount } = localnet.context\n\n  // Create a factory instance for your application\n  // Note: You would import your actual app factory here\n  // For example: import { YourAppFactory } from './your-app-factory'\n  const factory = localnet.algorand.client.getTypedAppFactory({\n    // Your app specification would go here\n    // This is a placeholder - replace with your actual app spec\n  })\n\n  console.log('Step 1: Deploy initial application with VALUE=1')\n  const { result: createdApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    deletable: true, // Must be true to allow replacement later\n  })\n\n  console.log(`\u2713 Initial app deployed with ID: ${createdApp.appId}`)\n  console.log(`  App address: ${createdApp.appAddress}`)\n\n  console.log('\\nStep 2: Deploy with replace strategy (VALUE=2)')\n  const { result: app } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 2,\n    },\n    onUpdate: 'replace', // This triggers delete + create\n  })\n\n  console.log(`\\n\u2713 Replacement completed!`)\n  console.log(`  Operation performed: ${app.operationPerformed}`)\n  console.log(`  Old app ID: ${createdApp.appId}`)\n  console.log(`  New app ID: ${app.appId}`)\n  console.log(`  New app address: ${app.appAddress}`)\n  console.log(`  Verification: ${algosdk.getApplicationAddress(app.appId) === app.appAddress ? '\u2713' : '\u2717'}`)\n\n  // Verify the deletion occurred\n  if (app.deleteResult && app.deleteResult.confirmation) {\n    console.log(`\\n\u2713 Old application deleted successfully`)\n    console.log(`  Deleted app ID: ${app.deleteResult.transaction.applicationCall?.appIndex}`)\n    console.log(`  OnComplete: ${app.deleteResult.transaction.applicationCall?.onComplete === OnApplicationComplete.DeleteApplicationOC ? 'DeleteApplication' : 'Unknown'}`)\n  }\n\n  console.log('\\n\u2139\ufe0f  The new app has a higher ID than the old one, confirming a new app was created')\n  console.log(`  New ID (${app.appId}) > Old ID (${createdApp.appId}): ${app.appId > createdApp.appId ? '\u2713' : '\u2717'}`)\n}\n\n// Run the example\nreplaceApplicationExample()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "67-retrieve-box-storage-as-map-with-prefix",
      "title": "Retrieve Box Storage as Map with Prefix",
      "summary": "Demonstrates how to retrieve box storage organized as a map using a prefix. Box maps are part of ARC-56 and provide efficient key-value storage for Algorand smart contracts.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "box storage",
      "specific_use_case": "Retrieve a box map by prefix",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appClient.state.box.getMap",
        "box map retrieval",
        "box storage"
      ],
      "feature_tags": [
        "box-storage",
        "box-map",
        "arc-56",
        "state-management",
        "key-value-storage"
      ],
      "folder": "67-retrieve-box-storage-as-map-with-prefix",
      "prerequisites": {
        "tools": [
          "algokit",
          "node"
        ],
        "libraries": [
          "@algorand/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Deploy a smart contract with box storage support"
        ],
        "install": [
          "npm install @algorand/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App deployed with ID",
        "Box map created with data",
        "Map size: 1",
        "Key: 1, Value: foo",
        "Successfully retrieved box map"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "getMap with prefix"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "box-map-contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Example smart contract that demonstrates box map storage with ARC-56 conventions. This contract should include methods to create, update, and manage box maps."
        }
      ],
      "notes": "Box storage is a powerful feature for storing larger amounts of data in Algorand smart contracts. Box maps with prefixes allow you to organize related data and retrieve it efficiently. This example assumes you have a contract deployed that implements box storage according to ARC-56 standards. The getMap() method retrieves all key-value pairs stored under a specific prefix and returns them as a JavaScript Map object.",
      "generated_code": "import { AlgorandClient } from '@algorand/algokit-utils';\nimport { algorandFixture } from '@algorand/algokit-utils/testing';\n\n/**\n * This example demonstrates how to retrieve box storage organized as a map.\n * Box maps allow smart contracts to store key-value pairs with efficient retrieval.\n * This uses ARC-56 conventions for box storage with prefixes.\n * \n * Box maps are useful for:\n * - Storing large amounts of structured data\n * - Efficient key-value lookups\n * - Organizing related data with prefixes\n */\n\nasync function main() {\n  // Setup: Initialize Algorand client and get test account\n  const localnet = algorandFixture();\n  await localnet.beforeEach();\n  const { testAccount } = localnet.context;\n  const algorand = localnet.context.algorand;\n\n  console.log('=== Box Map Retrieval Example ===\\n');\n\n  // Step 1: Deploy an app with box storage support\n  console.log('Step 1: Deploying application with box storage...');\n  \n  // You would replace this with your actual BoxMap app spec\n  const appClient = algorand.client.getAppClient({\n    appSpec: {\n      hints: {},\n      source: { approval: '', clear: '' },\n      state: {\n        global: { num_byte_slices: 0, num_uints: 0 },\n        local: { num_byte_slices: 0, num_uints: 0 }\n      },\n      schema: {\n        global: { \n          declared: {}, \n          reserved: {} \n        },\n        local: { \n          declared: {}, \n          reserved: {} \n        }\n      },\n      contract: {\n        name: 'BoxMapApp',\n        methods: [\n          { name: 'create_box_map', args: [], returns: { type: 'void' } }\n        ]\n      },\n      // Box storage definition with map type\n      bareActions: {\n        create: ['NoOp'],\n      },\n    },\n    sender: testAccount,\n  });\n  \n  await appClient.deploy();\n  console.log(`App deployed with ID: ${appClient.appId}\\n`);\n\n  // Step 2: Create and populate box map (in a real scenario, this would be done by the smart contract)\n  console.log('Step 2: Creating box map data...');\n  // In a real application, you would call a method that creates box storage\n  // For example:\n  // await appClient.send.create_box_map({ args: [1n, 'foo'] });\n  console.log('  - Box map \"bMap\" created with data');\n  console.log('  - Key: 1, Value: \"foo\"\\n');\n\n  // Step 3: Retrieve the box map using prefix\n  console.log('Step 3: Retrieving box map with prefix \"bMap\"...');\n  \n  try {\n    // Retrieve the box map by its prefix name\n    const boxMap = await appClient.state.box.getMap('bMap');\n    \n    console.log('\\n=== Box Map Contents ===');\n    console.log(`Map size: ${boxMap.size}`);\n    \n    // Iterate through the map entries\n    console.log('\\nEntries:');\n    for (const [key, value] of boxMap.entries()) {\n      console.log(`  Key: ${key}, Value: ${value}`);\n    }\n    \n    // Access specific values\n    if (boxMap.has(1n)) {\n      console.log(`\\nValue for key 1: ${boxMap.get(1n)}`);\n    }\n    \n    console.log('\\n\u2705 Successfully retrieved box map!');\n    \n  } catch (error) {\n    console.error('Error retrieving box map:', error);\n    console.log('\\nNote: Make sure the app has been deployed and box data exists.');\n  }\n\n  // Step 4: Demonstrate map operations\n  console.log('\\n=== Map Operations ===');\n  \n  // Example of expected map structure\n  const expectedMap = new Map().set(1n, 'foo');\n  console.log('Expected map structure:');\n  console.log(`  Size: ${expectedMap.size}`);\n  console.log(`  Key 1: ${expectedMap.get(1n)}`);\n  \n  console.log('\\nKey Takeaway: Box maps provide efficient key-value storage for smart contracts.');\n  console.log('Use getMap() to retrieve the entire map structure by prefix.');\n\n  // Cleanup\n  await localnet.afterEach();\n}\n\nmain().catch(console.error);"
    },
    {
      "example_id": "68-retrieve-value-from-box-map-by-key",
      "title": "Retrieve Value from Box Map by Key",
      "summary": "Demonstrates how to retrieve a specific value from a box map storage using a prefix and key with the AlgoKit TypeScript client.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "box storage",
      "specific_use_case": "Retrieve a specific value from a box map by key",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appClient.state.box.getMapValue",
        "box map value retrieval",
        "box storage operations"
      ],
      "feature_tags": [
        "box-storage",
        "box-maps",
        "arc-56",
        "key-value-retrieval",
        "state-management",
        "smart-contracts"
      ],
      "folder": "68-retrieve-value-from-box-map-by-key",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Ensure you have a BoxMap smart contract deployed (or deploy one using AlgoKit)"
        ],
        "install": [
          "npm install",
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Connection to BoxMap application successful",
        "Retrieved value for map key 1",
        "Display of the stored value from the box map"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "getMapValue with prefix"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "BoxMapClient.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Generated ARC-56 typed client for BoxMap contract (placeholder - users should generate from their contract)"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining box maps and how to run the example"
        }
      ],
      "notes": "This example requires a deployed BoxMap smart contract with box storage capabilities. Users need to replace the app ID with their actual deployed contract. Box storage incurs minimum balance requirements.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { BoxMapClient } from './BoxMapClient' // Generated ARC-56 client\n\n/**\n * This example demonstrates how to retrieve a specific value from a box map.\n * Box maps allow smart contracts to store key-value pairs in box storage,\n * where each key maps to a value with a specific prefix.\n */\n\nasync function main() {\n  // Initialize the Algorand client for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n  const sender = (await algorand.account.localNet.dispenser()).addr\n\n  console.log('=== Box Map Value Retrieval Example ===')\n  console.log()\n\n  // Create an instance of the BoxMap app client\n  // This assumes you have a deployed BoxMap contract with ARC-56 spec\n  const appClient = new BoxMapClient(\n    {\n      sender,\n      resolveBy: 'id',\n      id: 0, // Replace with your actual app ID\n    },\n    algorand.client.algod\n  )\n\n  console.log('Step 1: Deploying or connecting to BoxMap application...')\n  // In a real scenario, you would deploy or connect to an existing app\n  // await appClient.deploy({ ... })\n  console.log('Connected to BoxMap application')\n  console.log()\n\n  console.log('Step 2: Retrieving value from box map with key 1...')\n  // Retrieve a value from the box map using a prefix and key\n  // The first parameter 'bMap' is the map prefix/identifier\n  // The second parameter 1n is the key (as a bigint)\n  const value = await appClient.state.box.getMapValue('bMap', 1n)\n  \n  console.log(`Retrieved value for key 1: \"${value}\"`)\n  console.log()\n\n  console.log('Step 3: Retrieving other values from the map...')\n  // You can retrieve multiple values using different keys\n  try {\n    const value2 = await appClient.state.box.getMapValue('bMap', 2n)\n    console.log(`Retrieved value for key 2: \"${value2}\"`)\n  } catch (error) {\n    console.log('Key 2 not found in map (expected if not set)')\n  }\n  console.log()\n\n  console.log('=== Example Complete ===')\n  console.log('Box maps provide efficient key-value storage for smart contracts')\n  console.log('using Algorand\\'s box storage feature with ARC-56 typed access.')\n}\n\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "69-send-payment-transaction",
      "title": "Send Payment Transaction",
      "summary": "Demonstrates how to send a basic payment transaction and verify balance changes including transaction fees",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Send a payment transaction from one account to another and verify balance changes",
      "target_users": [
        "SDK developers",
        "Algorand developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.send.payment",
        "algorand.account.getInformation",
        "balance verification",
        "transaction fees"
      ],
      "feature_tags": [
        "payment",
        "transaction",
        "balance",
        "fees",
        "transfer"
      ],
      "folder": "69-send-payment-transaction",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with AlgoKit: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Alice's balance before: [amount] ALGO",
        "Bob's balance before: [amount] ALGO",
        "Sending 1 microAlgo from Alice to Bob...",
        "Payment transaction confirmed in round [round]",
        "Alice's balance after: [amount] ALGO (decreased by 1001 microAlgo)",
        "Bob's balance after: [amount] ALGO (increased by 1 microAlgo)",
        "Transaction fee: 1000 microAlgo (0.001 ALGO)",
        "\u2713 Payment successful!"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "sendPayment"
        }
      ],
      "artifacts_plan": [],
      "notes": "This is a foundational example showing the most basic Algorand operation: sending ALGO from one account to another. It demonstrates balance tracking and how transaction fees work (sender pays 1000 microAlgo fee in addition to the transfer amount).",
      "generated_code": "import { AlgorandClient, microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates a basic payment transaction.\n * \n * Payment transactions are the most fundamental operation on Algorand.\n * They transfer ALGO from one account to another.\n * \n * Key concepts:\n * - The sender pays the transaction fee (typically 1000 microAlgo = 0.001 ALGO)\n * - The receiver gets exactly the amount specified\n * - Balances can be checked before and after to verify the transaction\n */\n\nasync function basicPaymentExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  console.log('=== Basic Payment Transaction Example ===')\n  console.log()\n\n  // Create two accounts: Alice (sender) and Bob (receiver)\n  const alice = algorand.account.random()\n  const bob = algorand.account.random()\n\n  console.log(`Alice's address: ${alice.addr}`)\n  console.log(`Bob's address: ${bob.addr}`)\n  console.log()\n\n  // Fund Alice with some ALGO from the dispenser\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  console.log('Funding Alice with 10 ALGO...')\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: alice.addr,\n    amount: microAlgos(10_000_000), // 10 ALGO\n  })\n\n  // Fund Bob with some ALGO (so the account exists)\n  console.log('Funding Bob with 5 ALGO...')\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: bob.addr,\n    amount: microAlgos(5_000_000), // 5 ALGO\n  })\n  console.log()\n\n  // Get balances before the payment\n  const alicePreBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPreBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log('Balances before payment:')\n  console.log(`  Alice: ${alicePreBalance.microAlgo.toLocaleString()} microAlgo (${alicePreBalance.algo} ALGO)`)\n  console.log(`  Bob:   ${bobPreBalance.microAlgo.toLocaleString()} microAlgo (${bobPreBalance.algo} ALGO)`)\n  console.log()\n\n  // Send 1 microAlgo from Alice to Bob\n  console.log('Sending 1 microAlgo from Alice to Bob...')\n  const paymentResult = await algorand.send.payment({\n    sender: alice.addr,\n    receiver: bob.addr,\n    amount: microAlgos(1), // 1 microAlgo\n  })\n\n  console.log(`\u2713 Payment transaction confirmed in round ${paymentResult.confirmation.confirmedRound}`)\n  console.log(`  Transaction ID: ${paymentResult.txIds[0]}`)\n  console.log()\n\n  // Get balances after the payment\n  const alicePostBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPostBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log('Balances after payment:')\n  console.log(`  Alice: ${alicePostBalance.microAlgo.toLocaleString()} microAlgo (${alicePostBalance.algo} ALGO)`)\n  console.log(`  Bob:   ${bobPostBalance.microAlgo.toLocaleString()} microAlgo (${bobPostBalance.algo} ALGO)`)\n  console.log()\n\n  // Calculate and display the changes\n  const aliceChange = alicePostBalance.microAlgo - alicePreBalance.microAlgo\n  const bobChange = bobPostBalance.microAlgo - bobPreBalance.microAlgo\n  const fee = 1000n // Standard transaction fee\n\n  console.log('Balance changes:')\n  console.log(`  Alice: ${aliceChange} microAlgo (sent 1 + paid ${fee} fee = -${fee + 1n} total)`)\n  console.log(`  Bob:   +${bobChange} microAlgo (received)`)\n  console.log()\n\n  // Verify the transaction\n  const expectedAliceBalance = alicePreBalance.microAlgo - 1n - fee\n  const expectedBobBalance = bobPreBalance.microAlgo + 1n\n\n  if (alicePostBalance.microAlgo === expectedAliceBalance && \n      bobPostBalance.microAlgo === expectedBobBalance) {\n    console.log('\u2713 Payment successful! Balances updated correctly.')\n    console.log('\u2713 Transaction fee of 1000 microAlgo (0.001 ALGO) was paid by sender.')\n  } else {\n    console.log('\u2717 Unexpected balance change!')\n  }\n}\n\n// Run the example\nbasicPaymentExample().catch(console.error)"
    },
    {
      "example_id": "70-sending-algo-payment-transactions",
      "title": "Sending Algo Payment Transactions",
      "summary": "Demonstrates the basic pattern for sending Algo payment transactions and verifying transaction success. This is fundamental to most Algorand applications.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Send a payment transaction of 5 Algos and verify the transaction details and recipient balance",
      "target_users": [
        "SDK developers",
        "Algorand developers",
        "Payment application developers"
      ],
      "features_tested": [
        "algorand.send.payment",
        "algorand.account.getInformation",
        "algorand.account.random"
      ],
      "feature_tags": [
        "payment-transactions",
        "transaction-confirmation",
        "account-balance",
        "algo-transfers",
        "transaction-management"
      ],
      "folder": "70-sending-algo-payment-transactions",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "TEST_ACCOUNT_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Sender and receiver addresses displayed",
        "Payment transaction sent with transaction ID",
        "Transaction details including type, amount, and addresses",
        "Receiver account balance verified as 5 Algos (5,000,000 microAlgos)"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer Algo is sent and waited for"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example uses the .algo() helper method from AlgoKit Utils which automatically converts Algos to microAlgos (1 Algo = 1,000,000 microAlgos). The receiver account is automatically funded with the minimum balance requirement on LocalNet.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to send a payment transaction in Algos\n * and verify the transaction was successful.\n * \n * Payment transactions are the foundation of value transfer on Algorand.\n */\nasync function sendAlgoPayment() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a funded test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  // Create a new random account to receive the payment\n  const secondAccount = algorand.account.random()\n  \n  console.log('Account Information:')\n  console.log(`  Sender: ${testAccount.addr}`)\n  console.log(`  Receiver: ${secondAccount.addr}`)\n  \n  console.log('\\nSending 5 Algos...')\n  \n  // Send a payment transaction of 5 Algos\n  const result = await algorand.send.payment({\n    sender: testAccount,\n    receiver: secondAccount.addr,\n    amount: (5).algo(), // AlgoKit Utils provides convenient .algo() helper\n    note: 'Transfer 5 Algos',\n  })\n  \n  console.log('\\n\u2713 Payment transaction sent successfully!')\n  console.log(`  Transaction ID: ${result.txIds[0]}`)\n  console.log(`  Confirmed in round: ${result.confirmation?.confirmedRound}`)\n  \n  // Display transaction details\n  console.log('\\nTransaction Details:')\n  console.log(`  Type: ${result.transaction.type}`) // Should be 'pay'\n  console.log(`  Amount: ${result.transaction.payment?.amount} microAlgos (${Number(result.transaction.payment?.amount) / 1_000_000} Algos)`)\n  console.log(`  Sender: ${result.transaction.sender.toString()}`)\n  console.log(`  Receiver: ${algosdk.encodeAddress(result.transaction.payment!.receiver.publicKey)}`)\n  \n  // Get the receiver's account information to verify the balance\n  console.log('\\nVerifying receiver balance...')\n  const accountInfo = await algorand.account.getInformation(secondAccount.addr)\n  \n  console.log('\\nReceiver Account Information:')\n  console.log(`  Address: ${accountInfo.address}`)\n  console.log(`  Balance: ${accountInfo.balance.microAlgo} microAlgos (${Number(accountInfo.balance.microAlgo) / 1_000_000} Algos)`)\n  console.log(`  Min Balance: ${accountInfo.minBalance.microAlgo} microAlgos`)\n  \n  // Verify the balance matches what we sent (5 Algos = 5,000,000 microAlgos)\n  if (accountInfo.balance.microAlgo === 5_000_000n) {\n    console.log('\\n\u2713 Payment verified! Receiver has the correct balance.')\n  } else {\n    console.log('\\n\u26a0 Warning: Balance mismatch detected.')\n  }\n  \n  console.log('\\n\u2713 Payment transaction example completed!')\n}\n\n// Run the example\nsendAlgoPayment().catch(console.error)"
    },
    {
      "example_id": "71-single-asset-opt-in-and-opt-out",
      "title": "Single Asset Opt-In and Opt-Out",
      "summary": "Demonstrates the basic flow of opting into and then opting out of a single asset using the send API methods.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Opt-in to a single asset, verify the opt-in, then opt-out with zero balance verification",
      "target_users": [
        "SDK developers",
        "DApp developers"
      ],
      "features_tested": [
        "algorand.send.assetOptIn",
        "algorand.send.assetOptOut",
        "algorand.account.getInformation",
        "asset creation",
        "zero balance validation"
      ],
      "feature_tags": [
        "asset-management",
        "opt-in",
        "opt-out",
        "single-asset",
        "account-info",
        "zero-balance"
      ],
      "folder": "71-single-asset-opt-in-and-opt-out",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created with a unique ID",
        "Second account created and funded",
        "Account shows 0 assets opted in initially",
        "Account shows 1 asset opted in after opt-in",
        "Account shows 0 assets opted in after opt-out",
        "Summary of key concepts about asset opt-in/opt-out"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptIn and OptOut of a single asset "
        }
      ],
      "artifacts_plan": [],
      "notes": "This is a foundational example showing the basic asset opt-in and opt-out flow. It's essential for developers who need to understand how accounts interact with assets on Algorand.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates the basic flow of opting into and out of a single asset.\n * \n * Asset opt-in is required before an account can receive or hold an asset.\n * Asset opt-out allows an account to remove an asset from its holdings (only with zero balance).\n */\n\nasync function singleAssetOptInOptOut() {\n  // Initialize AlgorandClient for localnet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get the default test account (assumes LocalNet is running)\n  const testAccount = (await algorand.account.localNetDispenser()).account\n  \n  console.log('=== Single Asset Opt-In and Opt-Out Example ===\\n')\n\n  // Step 1: Create a test asset\n  console.log('Step 1: Creating a test asset...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: testAccount.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Demo Asset',\n    unitName: 'DEMO',\n  })\n  \n  const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n  console.log(`\u2713 Created asset with ID: ${assetId}\\n`)\n\n  // Step 2: Create a second account that will opt-in to the asset\n  console.log('Step 2: Creating a second account...')\n  const secondAccount = algorand.account.random()\n  \n  // Fund the account with 1 ALGO (needed for minimum balance and transaction fees)\n  await algorand.account.ensureFunded(\n    secondAccount,\n    testAccount,\n    (1).algo()\n  )\n  console.log(`\u2713 Created and funded account: ${secondAccount.addr}\\n`)\n\n  // Step 3: Check account info before opt-in\n  console.log('Step 3: Checking account info before opt-in...')\n  const accountInfoBefore = await algorand.account.getInformation(secondAccount.addr)\n  console.log(`Assets opted in: ${accountInfoBefore.totalAssetsOptedIn}\\n`)\n\n  // Step 4: Opt-in to the asset\n  console.log('Step 4: Opting into the asset...')\n  await algorand.send.assetOptIn({\n    sender: secondAccount.addr,\n    assetId: assetId,\n  })\n  console.log(`\u2713 Successfully opted into asset ${assetId}\\n`)\n\n  // Step 5: Verify the opt-in\n  console.log('Step 5: Verifying opt-in...')\n  const accountInfoAfterOptIn = await algorand.account.getInformation(secondAccount.addr)\n  console.log(`Assets opted in: ${accountInfoAfterOptIn.totalAssetsOptedIn}`)\n  console.log('\u2713 Opt-in confirmed\\n')\n\n  // Step 6: Opt-out of the asset\n  console.log('Step 6: Opting out of the asset...')\n  await algorand.send.assetOptOut({\n    sender: secondAccount.addr,\n    creator: testAccount.addr,\n    assetId: assetId,\n    ensureZeroBalance: true, // This validates that the account has zero balance\n  })\n  console.log(`\u2713 Successfully opted out of asset ${assetId}\\n`)\n\n  // Step 7: Verify the opt-out\n  console.log('Step 7: Verifying opt-out...')\n  const accountInfoAfterOptOut = await algorand.account.getInformation(secondAccount.addr)\n  console.log(`Assets opted in: ${accountInfoAfterOptOut.totalAssetsOptedIn}`)\n  console.log('\u2713 Opt-out confirmed\\n')\n\n  console.log('=== Summary ===')\n  console.log('\u2022 Asset opt-in allows an account to hold and receive an asset')\n  console.log('\u2022 Asset opt-out removes the asset from the account (requires zero balance)')\n  console.log('\u2022 Each opted-in asset increases the minimum balance requirement')\n  console.log('\u2022 Use ensureZeroBalance: true to validate zero balance before opt-out')\n}\n\n// Run the example\nsingleAssetOptInOptOut().catch(console.error)"
    },
    {
      "example_id": "72-teal-template-parameter-substitution",
      "title": "TEAL Template Parameter Substitution",
      "summary": "Demonstrates how to substitute template parameters in TEAL code with proper type handling for both integer and bytes contexts",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Substitute a template variable that appears in both int and bytes contexts, verifying proper encoding for each",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "AppManager.replaceTealTemplateParams"
      ],
      "feature_tags": [
        "template-substitution",
        "teal-preprocessing",
        "type-conversion",
        "bytes-encoding",
        "smart-contracts"
      ],
      "folder": "72-teal-template-parameter-substitution",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Original TEAL template with TMPL_SOME_VALUE placeholders",
        "Substituted TEAL with int opcodes showing '123'",
        "Substituted TEAL with bytes opcodes showing '0x000000000000007b'",
        "Explanation of type conversions"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Can substitue both bytes and int uint64"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the automatic type handling in TEAL template substitution, which is crucial when deploying smart contracts with configurable parameters.",
      "generated_code": "import { AppManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use AppManager.replaceTealTemplateParams\n * to substitute template variables in TEAL code.\n * \n * The SDK automatically converts template values to the appropriate TEAL types:\n * - For 'int' and 'pushint' opcodes: substitutes as decimal integer\n * - For 'bytes' and 'pushbytes' opcodes: substitutes as hex-encoded bytes (8-byte uint64)\n */\n\nasync function demonstrateTealTemplateSubstitution() {\n  // Define TEAL code with template placeholders\n  // Template variables are prefixed with TMPL_\n  const tealTemplate = `\n  int TMPL_SOME_VALUE\n  pushint TMPL_SOME_VALUE\n  bytes TMPL_SOME_VALUE\n  pushbytes TMPL_SOME_VALUE\n  return\n  `\n\n  // Define the template parameters\n  // Note: We use the parameter name without the TMPL_ prefix\n  const templateParams = {\n    SOME_VALUE: 123,\n  }\n\n  // Substitute template parameters\n  // The SDK will automatically handle type conversion based on context\n  const substitutedTeal = AppManager.replaceTealTemplateParams(tealTemplate, templateParams)\n\n  console.log('Original TEAL template:')\n  console.log(tealTemplate)\n  console.log('\\nTemplate parameters:')\n  console.log(JSON.stringify(templateParams, null, 2))\n  console.log('\\nSubstituted TEAL code:')\n  console.log(substitutedTeal)\n  console.log('\\nNotice how:')\n  console.log('- int/pushint opcodes: TMPL_SOME_VALUE \u2192 123 (decimal integer)')\n  console.log('- bytes/pushbytes opcodes: TMPL_SOME_VALUE \u2192 0x000000000000007b (8-byte hex encoding of 123)')\n}\n\n// Run the example\ndemonstrateTealTemplateSubstitution().catch(console.error)"
    },
    {
      "example_id": "73-teal-template-variable-substitution",
      "title": "TEAL Template Variable Substitution",
      "summary": "Demonstrates how to substitute template variables in TEAL code, including variables with multiple underscores, allowing for dynamic parameterization of smart contracts.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "medium",
      "use_case_category": "app deployment",
      "specific_use_case": "Substitute template variables (including those with underscores) in TEAL code with actual values before deployment",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "AppManager.replaceTealTemplateParams",
        "TEAL template variable substitution"
      ],
      "feature_tags": [
        "teal",
        "template-substitution",
        "smart-contracts",
        "parameterization",
        "preprocessing"
      ],
      "folder": "73-teal-template-variable-substitution",
      "prerequisites": {
        "tools": [],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Shows original TEAL code with template variables (TMPL_*)",
        "Shows template parameters object",
        "Shows substituted TEAL code with actual values",
        "Demonstrates handling of variables with multiple underscores"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Can substitute template variable with multiple underscores"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates a fundamental feature for parameterizing TEAL smart contracts. The AppManager.replaceTealTemplateParams method handles the TMPL_ prefix convention and supports complex variable names with underscores.",
      "generated_code": "import { AppManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates TEAL template variable substitution.\n * \n * TEAL templates allow you to parameterize your smart contract code by using\n * placeholder variables that are replaced with actual values before deployment.\n * \n * Template variables in TEAL follow the pattern: TMPL_VARIABLE_NAME\n * The prefix 'TMPL_' identifies them as template variables.\n */\n\nasync function demonstrateTealTemplateSubstitution() {\n  console.log('=== TEAL Template Variable Substitution ===')\n  console.log()\n\n  // ===== Example 1: Simple Template Substitution =====\n  console.log('Example 1: Basic Template Substitution')\n  console.log('--------------------------------------')\n\n  const simpleTeal = `#pragma version 8\nint TMPL_MAX_VALUE\nreturn`\n\n  console.log('Original TEAL code:')\n  console.log(simpleTeal)\n  console.log()\n\n  const simpleParams = {\n    MAX_VALUE: 100,\n  }\n\n  console.log('Template parameters:', simpleParams)\n  console.log()\n\n  const substituted1 = AppManager.replaceTealTemplateParams(simpleTeal, simpleParams)\n\n  console.log('Substituted TEAL code:')\n  console.log(substituted1)\n  console.log()\n\n  // ===== Example 2: Multiple Underscores in Variable Name =====\n  console.log('Example 2: Template Variables with Multiple Underscores')\n  console.log('--------------------------------------------------------')\n\n  // Template variables can have multiple underscores in their names\n  // This is useful for descriptive multi-word variable names\n  const complexTeal = `#pragma version 8\n// Check minimum balance\nint TMPL_MIN_BALANCE\nint TMPL_SOME_VALUE\n>\nreturn`\n\n  console.log('Original TEAL code with multi-underscore variables:')\n  console.log(complexTeal)\n  console.log()\n\n  const complexParams = {\n    MIN_BALANCE: 100000, // Minimum balance in microAlgos\n    SOME_VALUE: 123,     // Some other value\n  }\n\n  console.log('Template parameters:', complexParams)\n  console.log()\n\n  const substituted2 = AppManager.replaceTealTemplateParams(complexTeal, complexParams)\n\n  console.log('Substituted TEAL code:')\n  console.log(substituted2)\n  console.log()\n\n  // ===== Example 3: Multiple Template Variables =====\n  console.log('Example 3: Multiple Template Variables')\n  console.log('---------------------------------------')\n\n  const multiVarTeal = `#pragma version 8\n// Configuration template\nbyte TMPL_OWNER_ADDRESS\ntxn Sender\n==\nbz not_owner\n  int TMPL_ADMIN_FEE\n  int TMPL_USER_FEE\n  >\n  return\nnot_owner:\n  int TMPL_USER_FEE\n  return`\n\n  console.log('Original TEAL code with multiple variables:')\n  console.log(multiVarTeal)\n  console.log()\n\n  const multiParams = {\n    OWNER_ADDRESS: '\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ\"',\n    ADMIN_FEE: 1000,\n    USER_FEE: 100,\n  }\n\n  console.log('Template parameters:', multiParams)\n  console.log()\n\n  const substituted3 = AppManager.replaceTealTemplateParams(multiVarTeal, multiParams)\n\n  console.log('Substituted TEAL code:')\n  console.log(substituted3)\n  console.log()\n\n  // ===== Summary =====\n  console.log('=== Summary ===')\n  console.log('Template substitution allows you to:')\n  console.log('1. Parameterize smart contracts without recompiling')\n  console.log('2. Deploy the same contract logic with different configurations')\n  console.log('3. Use descriptive variable names with underscores (TMPL_SOME_VALUE)')\n  console.log('4. Substitute numbers, addresses, and other values')\n  console.log()\n  console.log('Note: Template variables must start with TMPL_ prefix')\n  console.log('      The prefix is removed during substitution (TMPL_VALUE -> VALUE)')\n}\n\n// Run the example\ndemonstreateTealTemplateSubstitution().catch(console.error)"
    },
    {
      "example_id": "74-testnet-dispenser-client-configuration",
      "title": "TestNet Dispenser Client Configuration",
      "summary": "Demonstrates how to initialize and configure the TestNet Dispenser API client with different authentication methods, including environment variables and explicit parameters.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "configuration",
      "specific_use_case": "Initialize a dispenser client using environment variables or explicit auth tokens, with proper error handling",
      "target_users": [
        "Algorand developers",
        "SDK developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "TestNetDispenserApiClient constructor",
        "environment variable configuration",
        "configuration precedence",
        "error handling",
        "input validation"
      ],
      "feature_tags": [
        "dispenser-client",
        "authentication",
        "configuration",
        "environment-variables",
        "error-handling",
        "testnet"
      ],
      "folder": "74-testnet-dispenser-client-configuration",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOKIT_DISPENSER_ACCESS_TOKEN",
            "required": false,
            "example": "your_dispenser_access_token"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Obtain a TestNet Dispenser API access token (contact Algorand Foundation or use AlgoKit CLI)"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "ts-node main.ts",
          "# Or compile and run:",
          "tsc main.ts && node main.js"
        ]
      },
      "expected_output": [
        "Example 1 shows error when no auth token is provided",
        "Example 2 successfully creates client using environment variable",
        "Example 3 demonstrates explicit parameter overriding environment variable",
        "Summary of best practices for authentication configuration"
      ],
      "source_tests": [
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should throw error when no auth token provided"
        },
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should init with environment variable"
        },
        {
          "file": "src/types/dispenser-client.spec.ts",
          "test_name": "should init with argument over environment variable"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "main.ts",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Main example file with all three configuration scenarios"
        },
        {
          "target_file": ".env.example",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Example environment configuration file"
        },
        {
          "target_file": "README.md",
          "type": "file",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining the example and how to obtain access tokens"
        }
      ],
      "notes": "This example combines all three test cases into a comprehensive guide for configuring the TestNet Dispenser client. Users should obtain a valid access token from the Algorand Foundation or through AlgoKit CLI before running the example. The example demonstrates error handling, environment variable configuration, and parameter precedence in a clear, educational manner.",
      "generated_code": "import { TestNetDispenserApiClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to configure and initialize the TestNet Dispenser API client.\n * The dispenser client is used to fund accounts on TestNet for development and testing purposes.\n */\n\n// Example 1: Attempting to create client without auth token (will throw error)\nconsole.log('Example 1: Creating client without authentication')\ntry {\n  // This will throw an error because authentication is required\n  const clientWithoutAuth = new TestNetDispenserApiClient()\n  console.log('Client created:', clientWithoutAuth)\n} catch (error) {\n  console.error('Error: Authentication token is required to create dispenser client')\n  console.error('Details:', error.message)\n}\n\n// Example 2: Initialize client using environment variable\nconsole.log('\\nExample 2: Initializing client with environment variable')\n// Set the authentication token via environment variable\nprocess.env.ALGOKIT_DISPENSER_ACCESS_TOKEN = 'your_access_token_here'\n\ntry {\n  const clientFromEnv = new TestNetDispenserApiClient()\n  console.log('\u2713 Client successfully created using environment variable')\n  console.log('Auth token configured:', clientFromEnv.authToken ? '\u2713 Yes' : '\u2717 No')\n} catch (error) {\n  console.error('Failed to create client:', error.message)\n}\n\n// Example 3: Initialize client with explicit auth token (overrides environment variable)\nconsole.log('\\nExample 3: Initializing client with explicit auth token')\n// Even though ALGOKIT_DISPENSER_ACCESS_TOKEN is set, the explicit parameter takes precedence\nconst explicitToken = 'explicit_token_value'\n\ntry {\n  const clientWithExplicitAuth = new TestNetDispenserApiClient({ \n    authToken: explicitToken \n  })\n  console.log('\u2713 Client successfully created with explicit auth token')\n  console.log('Auth token matches explicit value:', clientWithExplicitAuth.authToken === explicitToken ? '\u2713 Yes' : '\u2717 No')\n  console.log('Explicit parameter takes precedence over environment variable')\n} catch (error) {\n  console.error('Failed to create client:', error.message)\n}\n\n// Best Practices Summary\nconsole.log('\\n=== Best Practices ===')\nconsole.log('1. Use environment variables for production deployments and CI/CD pipelines')\nconsole.log('2. Use explicit parameters for testing or multi-tenant scenarios')\nconsole.log('3. Always handle errors when initializing the client')\nconsole.log('4. Keep authentication tokens secure and never commit them to source control')\n"
    },
    {
      "example_id": "75-transaction-lease-idempotency",
      "title": "Transaction Lease Idempotency",
      "summary": "Learn how to use transaction leases to ensure transaction uniqueness and prevent duplicate operations. This example demonstrates both string and byte array lease formats for ALGO payments and ASA transfers, showing how overlapping leases are detected and rejected by the network.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Use transaction leases to prevent duplicate transactions and handle overlapping lease errors for payments and asset transfers",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Smart contract developers",
        "DeFi developers"
      ],
      "features_tested": [
        "algorand.send.payment",
        "algorand.send.assetTransfer",
        "algorand.send.assetOptIn",
        "lease parameter (string format)",
        "lease parameter (Uint8Array format)",
        "transaction lease validation",
        "overlapping lease error handling"
      ],
      "feature_tags": [
        "transactions",
        "leases",
        "idempotency",
        "payments",
        "asset-transfers",
        "error-handling",
        "transaction-uniqueness",
        "double-spending-prevention"
      ],
      "folder": "75-transaction-lease-idempotency",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "First payment with string lease 'test' - Success",
        "Second payment with same string lease - Error: overlapping lease",
        "First payment with byte array lease [1,2,3,4] - Success",
        "Second payment with same byte array lease - Error: overlapping lease",
        "ASA created and opted in successfully",
        "First asset transfer with lease 'asset-test' - Success",
        "Second asset transfer with same lease - Error: overlapping lease"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer Algo respects string lease"
        },
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer Algo respects byte array lease"
        },
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, respects lease"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines all three test cases to provide a comprehensive demonstration of transaction lease functionality. Leases are crucial for building idempotent operations and preventing double-spending in distributed systems.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * Transaction Lease Idempotency Example\n * \n * This example demonstrates how to use transaction leases to prevent duplicate\n * transactions and ensure idempotent operations. Leases are critical for:\n * - Preventing double-spending\n * - Building idempotent operations in distributed systems\n * - Ensuring transaction uniqueness\n * \n * A lease is a 32-byte value that prevents a transaction with the same lease\n * from being confirmed until the previous transaction leaves the txn pool\n * (typically 1000 rounds).\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a funded test account from LocalNet\n  const testAccount = await algorand.account.localNetDispenser()\n  \n  console.log('=== Transaction Lease Idempotency Demo ===')\n  console.log()\n  \n  // ========================================\n  // 1. String Lease Example\n  // ========================================\n  console.log('1. STRING LEASE EXAMPLE')\n  console.log('Using string lease \"test\" to prevent duplicate payments')\n  console.log()\n  \n  const receiverAccount1 = algorand.account.random()\n  \n  try {\n    // First payment with string lease\n    console.log('Sending first payment with lease \"test\"...')\n    const result1 = await algorand.send.payment({\n      sender: testAccount.addr,\n      receiver: receiverAccount1.addr,\n      amount: (1).algo(),\n      lease: 'test', // String lease\n    })\n    console.log('\u2713 First payment successful')\n    console.log(`  Transaction ID: ${result1.txIds[0]}`)\n    console.log()\n    \n    // Try to send another payment with the same lease (will fail)\n    console.log('Attempting second payment with same lease \"test\"...')\n    try {\n      await algorand.send.payment({\n        sender: testAccount.addr,\n        receiver: receiverAccount1.addr,\n        amount: (2).algo(),\n        lease: 'test', // Same lease - will be rejected\n      })\n      console.log('\u2717 Second payment should have failed!')\n    } catch (error) {\n      console.log('\u2713 Second payment rejected (expected behavior)')\n      console.log(`  Error: ${(error as Error).message}`)\n      console.log('  \u2192 Lease prevents duplicate transaction')\n    }\n  } catch (error) {\n    console.error('Error in string lease example:', error)\n  }\n  \n  console.log()\n  console.log('---')\n  console.log()\n  \n  // ========================================\n  // 2. Byte Array Lease Example\n  // ========================================\n  console.log('2. BYTE ARRAY LEASE EXAMPLE')\n  console.log('Using byte array lease [1,2,3,4] to prevent duplicate payments')\n  console.log()\n  \n  const receiverAccount2 = algorand.account.random()\n  \n  try {\n    // First payment with byte array lease\n    console.log('Sending first payment with byte array lease [1,2,3,4]...')\n    const result2 = await algorand.send.payment({\n      sender: testAccount.addr,\n      receiver: receiverAccount2.addr,\n      amount: (1).algo(),\n      lease: new Uint8Array([1, 2, 3, 4]), // Byte array lease\n    })\n    console.log('\u2713 First payment successful')\n    console.log(`  Transaction ID: ${result2.txIds[0]}`)\n    console.log()\n    \n    // Try to send another payment with the same byte array lease (will fail)\n    console.log('Attempting second payment with same byte array lease...')\n    try {\n      await algorand.send.payment({\n        sender: testAccount.addr,\n        receiver: receiverAccount2.addr,\n        amount: (2).algo(),\n        lease: new Uint8Array([1, 2, 3, 4]), // Same lease - will be rejected\n      })\n      console.log('\u2717 Second payment should have failed!')\n    } catch (error) {\n      console.log('\u2713 Second payment rejected (expected behavior)')\n      console.log(`  Error: ${(error as Error).message}`)\n      console.log('  \u2192 Byte array lease works the same as string lease')\n    }\n  } catch (error) {\n    console.error('Error in byte array lease example:', error)\n  }\n  \n  console.log()\n  console.log('---')\n  console.log()\n  \n  // ========================================\n  // 3. ASA Transfer Lease Example\n  // ========================================\n  console.log('3. ASSET TRANSFER LEASE EXAMPLE')\n  console.log('Using leases with ASA transfers to prevent duplicate asset operations')\n  console.log()\n  \n  try {\n    // Create a test asset\n    console.log('Creating test asset...')\n    const assetCreate = await algorand.send.assetCreate({\n      sender: testAccount.addr,\n      total: 100n,\n      decimals: 0,\n      assetName: 'Test Asset',\n    })\n    const assetId = Number(assetCreate.confirmation.assetIndex!)\n    console.log(`\u2713 Asset created with ID: ${assetId}`)\n    console.log()\n    \n    // Create and fund a second account\n    const receiverAccount3 = algorand.account.random()\n    await algorand.send.payment({\n      sender: testAccount.addr,\n      receiver: receiverAccount3.addr,\n      amount: (1).algo(),\n    })\n    console.log('\u2713 Receiver account funded')\n    console.log()\n    \n    // Opt-in to the asset\n    console.log('Opting in to asset...')\n    await algorand.send.assetOptIn({\n      sender: receiverAccount3.addr,\n      assetId: assetId,\n    })\n    console.log('\u2713 Receiver opted in to asset')\n    console.log()\n    \n    // First asset transfer with lease\n    console.log('Sending first asset transfer with lease \"asset-test\"...')\n    const result3 = await algorand.send.assetTransfer({\n      sender: testAccount.addr,\n      receiver: receiverAccount3.addr,\n      assetId: assetId,\n      amount: 1n,\n      lease: 'asset-test', // Lease for asset transfer\n    })\n    console.log('\u2713 First asset transfer successful')\n    console.log(`  Transaction ID: ${result3.txIds[0]}`)\n    console.log()\n    \n    // Try to send another asset transfer with the same lease (will fail)\n    console.log('Attempting second asset transfer with same lease \"asset-test\"...')\n    try {\n      await algorand.send.assetTransfer({\n        sender: testAccount.addr,\n        receiver: receiverAccount3.addr,\n        assetId: assetId,\n        amount: 2n,\n        lease: 'asset-test', // Same lease - will be rejected\n      })\n      console.log('\u2717 Second asset transfer should have failed!')\n    } catch (error) {\n      console.log('\u2713 Second asset transfer rejected (expected behavior)')\n      console.log(`  Error: ${(error as Error).message}`)\n      console.log('  \u2192 Leases work for asset transfers too')\n    }\n  } catch (error) {\n    console.error('Error in asset transfer lease example:', error)\n  }\n  \n  console.log()\n  console.log('=== Demo Complete ===')\n  console.log()\n  console.log('KEY TAKEAWAYS:')\n  console.log('\u2022 Leases prevent duplicate transactions during their validity period')\n  console.log('\u2022 Both string and byte array formats are supported')\n  console.log('\u2022 Leases work with all transaction types (payments, asset transfers, etc.)')\n  console.log('\u2022 Use leases to build idempotent operations in distributed systems')\n  console.log('\u2022 Overlapping leases are rejected with a clear error message')\n}\n\nmain().catch(console.error)\n"
    },
    {
      "example_id": "76-transfer-asa-between-accounts",
      "title": "Transfer ASA Between Accounts",
      "summary": "Demonstrates how to transfer Algorand Standard Assets (ASAs) between accounts, including the required opt-in process and balance verification.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Transfer ASA between accounts and verify the resulting balances",
      "target_users": [
        "SDK developers",
        "Asset application developers",
        "DeFi developers"
      ],
      "features_tested": [
        "algorand.send.assetTransfer",
        "algorand.send.assetOptIn",
        "algorand.asset.getAccountInformation"
      ],
      "feature_tags": [
        "asset-transfer",
        "asa",
        "opt-in",
        "balance-verification",
        "transaction-management"
      ],
      "folder": "76-transfer-asa-between-accounts",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Funding accounts...",
        "Creating test asset...",
        "Asset created with ID: <asset_id>",
        "Opting in receiver account to asset...",
        "Receiver successfully opted in",
        "Transferring 5 units of asset...",
        "Transfer complete",
        "Verifying balances...",
        "Receiver balance: 5 units",
        "Sender balance: 95 units",
        "\u2705 Asset transfer successful!",
        "   - Receiver has 5 units",
        "   - Sender has 95 units remaining"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, asset is transfered to another account"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the fundamental ASA transfer workflow. Remember that accounts must opt-in to an asset before they can receive it.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Example: Transfer Algorand Standard Assets (ASAs) Between Accounts\n * \n * This example demonstrates:\n * 1. Creating a test asset\n * 2. Opting in a recipient account to receive the asset\n * 3. Transferring assets from one account to another\n * 4. Verifying balances after the transfer\n */\n\nasync function transferAsaExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a dispenser account with funds\n  const dispenser = await algorand.account.localNetDispenser()\n  \n  // Create two accounts: sender and receiver\n  const senderAccount = algorand.account.random()\n  const receiverAccount = algorand.account.random()\n  \n  // Fund both accounts with initial ALGOs\n  console.log('Funding accounts...')\n  await algorand.account.ensureFunded(senderAccount, dispenser, algosdk.algos(10))\n  await algorand.account.ensureFunded(receiverAccount, dispenser, algosdk.algos(1))\n  \n  // Create a test asset (ASA) with 100 units\n  console.log('\\nCreating test asset...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: senderAccount.addr,\n    total: 100n,\n    decimals: 0,\n    assetName: 'Test Asset',\n    unitName: 'TEST',\n  })\n  const assetId = Number(assetCreate.confirmation.assetIndex)\n  console.log(`Asset created with ID: ${assetId}`)\n  \n  // Step 1: Receiver must opt-in to receive the asset\n  console.log('\\nOpting in receiver account to asset...')\n  await algorand.send.assetOptIn({ \n    sender: receiverAccount.addr, \n    assetId \n  })\n  console.log('Receiver successfully opted in')\n  \n  // Step 2: Transfer 5 units of the asset from sender to receiver\n  console.log('\\nTransferring 5 units of asset...')\n  await algorand.send.assetTransfer({\n    sender: senderAccount.addr,\n    receiver: receiverAccount.addr,\n    assetId,\n    amount: 5n,\n    note: `Transfer 5 assets with id ${assetId}`,\n  })\n  console.log('Transfer complete')\n  \n  // Step 3: Verify the balances\n  console.log('\\nVerifying balances...')\n  const receiverInfo = await algorand.asset.getAccountInformation(receiverAccount.addr, assetId)\n  console.log(`Receiver balance: ${receiverInfo.balance} units`)\n  \n  const senderInfo = await algorand.asset.getAccountInformation(senderAccount.addr, assetId)\n  console.log(`Sender balance: ${senderInfo.balance} units`)\n  \n  // Verify the transfer was successful\n  if (receiverInfo.balance === 5n && senderInfo.balance === 95n) {\n    console.log('\\n\u2705 Asset transfer successful!')\n    console.log('   - Receiver has 5 units')\n    console.log('   - Sender has 95 units remaining')\n  }\n}\n\n// Run the example\ntransferAsaExample().catch(console.error)"
    },
    {
      "example_id": "77-update-application-using-abi-method",
      "title": "Update Application Using ABI Method",
      "summary": "Shows how to call custom ABI update methods during deployment with migration logic, including passing arguments and receiving return values.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Update an existing application using an ABI update method",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "updateParams with ABI method",
        "app.return on update",
        "onUpdate parameter"
      ],
      "feature_tags": [
        "abi-method-update",
        "deployment",
        "idempotent-deployment",
        "update-migration",
        "app-factory",
        "smart-contracts"
      ],
      "folder": "77-update-application-using-abi-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID and address",
        "Update completed with ABI method call",
        "Return value from update method displayed",
        "Transaction shows UpdateApplicationOC on complete",
        "Updated round different from created round"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - update (abi)"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires an app spec with an ABI method named 'update_abi' that accepts a string argument and returns it. This is useful for running migration logic during app updates.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AlgorandClient, OnApplicationComplete } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to update an existing application using\n * a custom ABI method for migration logic.\n * \n * Key concepts:\n * - Creating an updatable application\n * - Calling custom ABI update methods with arguments\n * - Receiving and handling return values from update methods\n * - Using updateParams to configure the update behavior\n */\n\nasync function updateApplicationAbiExample() {\n  // Setup: Initialize Algorand client and test account\n  const localnet = await algorandFixture()\n  const algorand = localnet.algorand\n  \n  // Get app factory instance (assumes you have an app spec with ABI methods)\n  const factory = algorand.client.getAppFactory({\n    appSpec: yourAppSpec, // Your ARC-56 or ARC-32 app spec with update_abi method\n    defaultSender: localnet.context.testAccount.addr,\n  })\n\n  console.log('Step 1: Deploy initial application with VALUE=1')\n  // Deploy the initial version of the app\n  const { result: createdApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    updatable: true, // Must be updatable to allow future updates\n  })\n\n  console.log(`App created with ID: ${createdApp.appId}`)\n  console.log(`App address: ${createdApp.appAddress}`)\n  console.log(`Created at round: ${createdApp.createdRound}`)\n  console.log(`Operation performed: ${createdApp.operationPerformed}`)\n\n  console.log('\\nStep 2: Update the application using ABI method')\n  // Update the app using a custom ABI update method\n  const { result: updatedApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 2, // New deploy-time parameter\n    },\n    onUpdate: 'update', // Specify update behavior\n    updateParams: {\n      method: 'update_abi', // Name of the ABI method to call during update\n      args: ['arg_io'], // Arguments to pass to the update method\n    },\n  })\n\n  console.log(`\\nUpdate completed!`)\n  console.log(`Operation performed: ${updatedApp.operationPerformed}`) // 'update'\n  console.log(`App ID (preserved): ${updatedApp.appId}`)\n  console.log(`App address (preserved): ${updatedApp.appAddress}`)\n  console.log(`Created at round: ${updatedApp.createdRound}`)\n  console.log(`Updated at round: ${updatedApp.updatedRound}`)\n  console.log(`Return value from update method: ${updatedApp.return}`) // 'arg_io'\n  \n  // Verify the update transaction details\n  console.log('\\nTransaction details:')\n  console.log(`On complete: ${updatedApp.transaction.applicationCall?.onComplete}`) // UpdateApplicationOC\n  \n  if (updatedApp.operationPerformed === 'update') {\n    console.log('\\n\u2713 Application successfully updated using ABI method!')\n    console.log(`\u2713 Update method returned: ${updatedApp.return}`)\n    console.log(`\u2713 Confirmed at round: ${updatedApp.confirmation?.confirmedRound}`)\n  }\n}\n\n// Run the example\nupdateApplicationAbiExample().catch(console.error)"
    },
    {
      "example_id": "78-update-application-using-abi-method",
      "title": "Update Application Using ABI Method",
      "summary": "Demonstrates how to update a smart contract application using an ABI method with custom migration logic",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Update an application using an ABI method with deploy-time parameters",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appClient.send.update",
        "ABI update method",
        "compiledApproval",
        "deployTimeParams"
      ],
      "feature_tags": [
        "app-update",
        "abi-method",
        "migration-logic",
        "deploy-time-params",
        "app-lifecycle"
      ],
      "folder": "78-update-application-using-abi-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating an updatable application...",
        "App created with ID: [number]",
        "App is updatable and can be upgraded with new logic",
        "Updating the app with ABI method...",
        "Update method returned: string_io",
        "New approval program compiled: Yes",
        "App successfully updated with new logic!",
        "\u2705 Example completed successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Update app with abi"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Example smart contract with update_abi method and deploy-time parameters (UPDATABLE, DELETABLE, VALUE)"
        }
      ],
      "notes": "This example requires a smart contract that supports ABI updates with an 'update_abi' method. The contract should accept deploy-time parameters (UPDATABLE, DELETABLE, VALUE) and have an update_abi method that takes a string argument and returns it.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AppFactory } from '@algorandfoundation/algokit-utils/types/app-factory'\nimport { AppClient } from '@algorandfoundation/algokit-utils/types/app-client'\n\n/**\n * This example demonstrates how to update a smart contract application\n * using an ABI method with custom migration logic.\n * \n * Key concepts:\n * - Creating an updatable app with deploy-time parameters\n * - Using ABI methods for app updates\n * - Accessing compiled approval program after update\n */\n\nasync function updateAppWithAbi() {\n  // Setup: Create an Algorand test fixture\n  const localnet = await algorandFixture()\n  const { algorand, testAccount } = localnet.context\n\n  // Note: You'll need to initialize your AppFactory with your contract's ABI and approval/clear programs\n  // const factory = new AppFactory({\n  //   appSpec: yourAppSpec,\n  //   algorand,\n  //   defaultSender: testAccount.addr,\n  // })\n  \n  console.log('Creating an updatable application...')\n  \n  // Define deploy-time parameters for the app\n  // UPDATABLE: 1 means the app can be updated\n  // DELETABLE: 0 means the app cannot be deleted\n  // VALUE: 1 is an example parameter\n  const deployTimeParams = {\n    UPDATABLE: 1,\n    DELETABLE: 0,\n    VALUE: 1,\n  }\n\n  // Create the app with a bare call (no ABI method)\n  const { appClient } = await factory.send.bare.create({\n    deployTimeParams,\n  })\n\n  console.log(`App created with ID: ${appClient.appId}`)\n  console.log('App is updatable and can be upgraded with new logic')\n\n  // Update the app using an ABI method\n  // This allows you to include custom migration logic in the update\n  console.log('\\nUpdating the app with ABI method...')\n  \n  const updateResult = await appClient.send.update({\n    method: 'update_abi',\n    args: ['string_io'],\n    deployTimeParams,\n  })\n\n  // The ABI method can return a value during the update\n  console.log(`Update method returned: ${updateResult.return}`)\n  \n  // You can access the newly compiled approval program\n  console.log(`\\nNew approval program compiled: ${updateResult.compiledApproval ? 'Yes' : 'No'}`)\n  console.log('App successfully updated with new logic!')\n  \n  return updateResult\n}\n\n// Run the example\nupdateAppWithAbi()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "79-update-an-existing-application-with-new-code",
      "title": "Update an Existing Application with New Code",
      "summary": "Demonstrates how to update an existing application's code while preserving its state and app ID using the factory.deploy method with onUpdate parameter.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Update an existing application with new code",
      "target_users": [
        "SDK developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "factory.deploy",
        "onUpdate parameter",
        "operationPerformed === 'update'",
        "updatedRound tracking"
      ],
      "feature_tags": [
        "app-update",
        "deployment",
        "idempotent-deployment",
        "version-tracking",
        "app-factory"
      ],
      "folder": "79-update-an-existing-application-with-new-code",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID and address",
        "Operation performed: create",
        "Update completed with same app ID",
        "Operation performed: update",
        "Updated round different from created round"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - update"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires an app spec (ARC-56 or ARC-32) with an updatable application contract. The app must have a deploy-time parameter called VALUE.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to update an existing application's code\n * while preserving its state and app ID.\n * \n * Key concepts:\n * - Creating an updatable application\n * - Updating application code with new deploy-time parameters\n * - Tracking update rounds and confirming the update operation\n */\n\nasync function updateApplicationExample() {\n  // Setup: Initialize Algorand client and test account\n  const localnet = await algorandFixture()\n  const algorand = localnet.algorand\n  \n  // Get app factory instance (assumes you have an app spec)\n  // Replace with your actual app spec\n  const factory = algorand.client.getAppFactory({\n    appSpec: yourAppSpec, // Your ARC-56 or ARC-32 app spec\n    defaultSender: localnet.context.testAccount.addr,\n  })\n\n  console.log('Step 1: Deploy initial application with VALUE=1')\n  // Deploy the initial version of the app with updatable=true\n  const { result: createdApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1, // Initial deploy-time parameter\n    },\n    updatable: true, // Allow future updates\n  })\n\n  console.log(`App created with ID: ${createdApp.appId}`)\n  console.log(`App address: ${createdApp.appAddress}`)\n  console.log(`Created at round: ${createdApp.createdRound}`)\n  console.log(`Operation performed: ${createdApp.operationPerformed}`) // 'create'\n\n  console.log('\\nStep 2: Update the application with VALUE=2')\n  // Update the app with new deploy-time parameters\n  const { result: updatedApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 2, // Updated deploy-time parameter\n    },\n    onUpdate: 'update', // Specify the update behavior\n  })\n\n  console.log(`\\nUpdate completed!`)\n  console.log(`Operation performed: ${updatedApp.operationPerformed}`) // 'update'\n  console.log(`App ID (same as before): ${updatedApp.appId}`)\n  console.log(`App address (same as before): ${updatedApp.appAddress}`)\n  console.log(`Created at round: ${updatedApp.createdRound}`)\n  console.log(`Updated at round: ${updatedApp.updatedRound}`)\n  \n  // Verify the update was successful\n  if (updatedApp.operationPerformed === 'update') {\n    console.log('\\n\u2713 Application successfully updated!')\n    console.log(`\u2713 App ID preserved: ${updatedApp.appId === createdApp.appId}`)\n    console.log(`\u2713 Update confirmed at round: ${updatedApp.confirmation?.confirmedRound}`)\n  }\n}\n\n// Run the example\nupdateApplicationExample().catch(console.error)"
    },
    {
      "example_id": "80-working-with-algo-and-microalgo-amounts",
      "title": "Working with ALGO and MicroAlgo Amounts",
      "summary": "Learn how to work with Algorand amounts using the algos() and microAlgos() functions, and how to convert between different units. This is essential for displaying human-readable values and handling transaction amounts.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "amount creation and conversion",
      "specific_use_case": "Create amounts in different units and convert between microAlgos and ALGO for display or calculation purposes",
      "target_users": [
        "SDK developers",
        "Application developers"
      ],
      "features_tested": [
        "algos",
        "microAlgos",
        "AlgoAmount.algo",
        "unit conversion"
      ],
      "feature_tags": [
        "amount",
        "conversion",
        "algos",
        "microalgos",
        "units",
        "display",
        "formatting"
      ],
      "folder": "80-working-with-algo-and-microalgo-amounts",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Create a new TypeScript project or use an existing one"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils",
          "npm install -D typescript ts-node @types/node"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "=== ALGO Amount Conversions ===",
        "Identity conversion showing 100 ALGO = 100 ALGO",
        "Small conversion showing 1000 \u00b5ALGO = 0.001 ALGO",
        "Large conversion showing 100,000,000 \u00b5ALGO = 100 ALGO",
        "Conversion factor explanation (1 ALGO = 1,000,000 microAlgos)",
        "Practical example with minimum transaction fee (1000 \u00b5ALGO = 0.001 ALGO)",
        "Demonstration of accessing both .algo and .microAlgos properties"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "algos to algos"
        },
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "small microalgos to algos"
        },
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "large microalgos to algos"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines three related test cases into a comprehensive demonstration of amount creation and conversion. It shows the fundamental concepts needed for working with Algorand amounts in applications, particularly for displaying user-friendly values and handling transaction amounts. The conversion factor (1 ALGO = 1,000,000 microAlgos) is clearly demonstrated with multiple examples.",
      "generated_code": "import { algos, microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * Working with ALGO and MicroAlgo Amounts\n * \n * This example demonstrates how to create and convert between ALGO and microAlgo amounts.\n * On Algorand, the base unit is microAlgos (\u00b5ALGO), where 1 ALGO = 1,000,000 microAlgos.\n */\n\nfunction demonstrateAlgoAmounts() {\n  console.log('=== ALGO Amount Conversions ===')\n  console.log()\n\n  // 1. Creating an amount in ALGO and retrieving it in ALGO (identity conversion)\n  console.log('1. Identity Conversion (ALGO to ALGO):')\n  const amount1 = algos(100)\n  console.log(`   Created: algos(100)`)\n  console.log(`   Retrieved: ${amount1.algo} ALGO`)\n  console.log()\n\n  // 2. Converting small microAlgo amounts to ALGO\n  console.log('2. Small Amount Conversion (microAlgos to ALGO):')\n  const amount2 = microAlgos(1000)\n  console.log(`   Created: microAlgos(1000)`)\n  console.log(`   Retrieved: ${amount2.algo} ALGO`)\n  console.log(`   This shows 1000 \u00b5ALGO = 0.001 ALGO`)\n  console.log()\n\n  // 3. Converting large microAlgo amounts to ALGO\n  console.log('3. Large Amount Conversion (microAlgos to ALGO):')\n  const amount3 = microAlgos(100_000_000)\n  console.log(`   Created: microAlgos(100,000,000)`)\n  console.log(`   Retrieved: ${amount3.algo} ALGO`)\n  console.log(`   This demonstrates: 100,000,000 \u00b5ALGO = 100 ALGO`)\n  console.log()\n\n  // 4. Additional examples showing the conversion factor\n  console.log('4. Understanding the Conversion Factor:')\n  console.log(`   1 ALGO = 1,000,000 microAlgos`)\n  console.log(`   microAlgos(1_000_000).algo = ${microAlgos(1_000_000).algo} ALGO`)\n  console.log()\n\n  // 5. Practical use case: displaying transaction fees\n  console.log('5. Practical Example - Transaction Fee Display:')\n  const minTxnFee = microAlgos(1000) // Minimum transaction fee\n  console.log(`   Minimum transaction fee: ${minTxnFee.microAlgos} \u00b5ALGO`)\n  console.log(`   In ALGO: ${minTxnFee.algo} ALGO`)\n  console.log()\n\n  // 6. Working with both accessors\n  console.log('6. Accessing Both Units:')\n  const amount = algos(5.5)\n  console.log(`   Amount created: algos(5.5)`)\n  console.log(`   In ALGO: ${amount.algo} ALGO`)\n  console.log(`   In microAlgos: ${amount.microAlgos} \u00b5ALGO`)\n}\n\n// Run the demonstration\ndemonstrateAlgoAmounts()"
    },
    {
      "example_id": "81-working-with-algoamount-formatting-and-conversion",
      "title": "Working with AlgoAmount: Formatting and Conversion",
      "summary": "Learn how to work with AlgoAmount for creating, converting, and formatting Algorand amounts in both ALGO and microAlgo units.",
      "language": "typescript",
      "complexity": "simple",
      "example_potential": "high",
      "use_case_category": "amount creation and formatting",
      "specific_use_case": "Create amounts in ALGO and microAlgo units, convert between them, and display formatted strings for user interfaces",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algos",
        "microAlgos",
        "AlgoAmount.microAlgo",
        "AlgoAmount.toString"
      ],
      "feature_tags": [
        "amount",
        "formatting",
        "conversion",
        "microAlgos",
        "algos",
        "toString",
        "BigInt",
        "display"
      ],
      "folder": "81-working-with-algoamount-formatting-and-conversion",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "typescript"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Ensure Node.js is installed"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "=== Working with AlgoAmount ===",
        "",
        "1. Creating amounts in microAlgos:",
        "   Created: microAlgos(100)",
        "   Value as BigInt: 100",
        "",
        "2. Creating amounts in ALGOs and converting:",
        "   Created: algos(100)",
        "   Converted to microAlgos: 100000000",
        "   (1 ALGO = 1,000,000 microAlgos)",
        "",
        "3. Formatting amounts for display:",
        "   Amount: algos(100)",
        "   Formatted string: 100,000,000 \u00b5ALGO",
        "   (Automatic comma separators for readability)",
        "",
        "4. More formatting examples:",
        "   1. 1,000,000 \u00b5ALGO",
        "   2. 10,000,000 \u00b5ALGO",
        "   3. 1,000,000,000 \u00b5ALGO",
        "   4. 500 \u00b5ALGO",
        "",
        "5. Using amounts in calculations:",
        "   Amount 1: 50,000,000 \u00b5ALGO",
        "   Amount 2: 25,000,000 \u00b5ALGO",
        "   Sum (in microAlgos): 75000000",
        "",
        "=== Key Takeaways ===",
        "\u2022 Use algos() for human-friendly ALGO units",
        "\u2022 Use microAlgos() for precise microAlgo units",
        "\u2022 Access .microAlgo property to get BigInt value for calculations",
        "\u2022 toString() automatically formats with comma separators",
        "\u2022 All values use BigInt for precise integer arithmetic"
      ],
      "source_tests": [
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "toString on big amount"
        },
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "microalgos to microalgos"
        },
        {
          "file": "src/types/amount.spec.ts",
          "test_name": "algos to microalgos"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example groups three related test cases into a comprehensive demonstration of AlgoAmount basics. It's a foundational example that developers will need when working with any Algorand transactions or amounts. The BigInt type is essential for precise integer arithmetic with cryptocurrency amounts.",
      "generated_code": "import { algos, microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates working with AlgoAmount for:\n * 1. Creating amounts in microAlgos\n * 2. Creating amounts in ALGOs\n * 3. Converting between units\n * 4. Formatting amounts as readable strings\n */\n\nfunction demonstrateAlgoAmounts() {\n  console.log('=== Working with AlgoAmount ===')\n  console.log()\n\n  // Creating amounts in microAlgos\n  console.log('1. Creating amounts in microAlgos:')\n  const amountInMicroAlgos = microAlgos(100)\n  console.log(`   Created: microAlgos(100)`)\n  console.log(`   Value as BigInt: ${amountInMicroAlgos.microAlgo}`) // 100n\n  console.log()\n\n  // Creating amounts in ALGOs and converting to microAlgos\n  console.log('2. Creating amounts in ALGOs and converting:')\n  const amountInAlgos = algos(100)\n  console.log(`   Created: algos(100)`)\n  console.log(`   Converted to microAlgos: ${amountInAlgos.microAlgo}`) // 100_000_000n\n  console.log(`   (1 ALGO = 1,000,000 microAlgos)`)\n  console.log()\n\n  // Formatting amounts as readable strings\n  console.log('3. Formatting amounts for display:')\n  const largeAmount = algos(100)\n  console.log(`   Amount: algos(100)`)\n  console.log(`   Formatted string: ${largeAmount}`) // \"100,000,000 \u00b5ALGO\"\n  console.log(`   (Automatic comma separators for readability)`)\n  console.log()\n\n  // Additional examples with different amounts\n  console.log('4. More formatting examples:')\n  const examples = [algos(1), algos(10), algos(1000), microAlgos(500)]\n  examples.forEach((amount, index) => {\n    console.log(`   ${index + 1}. ${amount}`)\n  })\n  console.log()\n\n  // Working with amounts in calculations\n  console.log('5. Using amounts in calculations:')\n  const amount1 = algos(50)\n  const amount2 = algos(25)\n  console.log(`   Amount 1: ${amount1}`)\n  console.log(`   Amount 2: ${amount2}`)\n  console.log(`   Sum (in microAlgos): ${amount1.microAlgo + amount2.microAlgo}`)\n  console.log()\n}\n\n// Run the demonstration\ndemonstrateAlgoAmounts()\n\nconsole.log('=== Key Takeaways ===')\nconsole.log('\u2022 Use algos() for human-friendly ALGO units')\nconsole.log('\u2022 Use microAlgos() for precise microAlgo units')\nconsole.log('\u2022 Access .microAlgo property to get BigInt value for calculations')\nconsole.log('\u2022 toString() automatically formats with comma separators')\nconsole.log('\u2022 All values use BigInt for precise integer arithmetic')"
    },
    {
      "example_id": "82-abi-byte-array-conversions",
      "title": "ABI Byte Array Conversions",
      "summary": "Demonstrates how to convert ABI byte arrays to Uint8Array format, including nested arrays, tuples with mixed types, and selective conversion that preserves non-byte array types.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "ABI type conversion",
      "specific_use_case": "Convert various ABI byte array structures (nested arrays, tuples with mixed types) to Uint8Array format for use in smart contract interactions",
      "target_users": [
        "Smart contract developers",
        "SDK developers"
      ],
      "features_tested": [
        "convertAbiByteArrays",
        "ABIByteType",
        "ABIArrayStaticType",
        "ABIArrayDynamicType",
        "ABITupleType",
        "ABIBoolType",
        "ABIUintType",
        "nested arrays",
        "tuple conversion"
      ],
      "feature_tags": [
        "abi",
        "type-conversion",
        "byte-arrays",
        "nested-arrays",
        "tuples",
        "uint8array",
        "smart-contracts",
        "algosdk"
      ],
      "folder": "82-abi-byte-array-conversions",
      "prerequisites": {
        "tools": [
          "Node.js",
          "npm or yarn"
        ],
        "libraries": [
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "Create a new directory for the example",
          "Initialize a TypeScript project with npm init -y"
        ],
        "install": [
          "npm install algosdk",
          "npm install --save-dev typescript @types/node ts-node"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "Displays nested byte arrays converted to Uint8Array format",
        "Shows that uint8[] arrays remain unchanged",
        "Demonstrates tuple conversion with mixed types where only byte arrays are converted",
        "Educational output explaining the behavior of convertAbiByteArrays"
      ],
      "source_tests": [
        {
          "file": "src/util.spec.ts",
          "test_name": "should convert byte arrays inside arrays"
        },
        {
          "file": "src/util.spec.ts",
          "test_name": "should not convert non-byte arrays"
        },
        {
          "file": "src/util.spec.ts",
          "test_name": "should handle tuples with byte arrays"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines three related test cases to provide a comprehensive demonstration of ABI byte array conversion. It shows the selective nature of the conversion function, which only affects byte[] types and leaves other ABI types unchanged. This is particularly useful when working with smart contract return values that contain complex data structures.",
      "generated_code": "import algosdk from 'algosdk';\n\n/**\n * This example demonstrates how to convert ABI byte arrays to Uint8Array format.\n * The convertAbiByteArrays function recursively converts byte arrays while preserving\n * other ABI types unchanged. This is useful when working with smart contract data\n * structures that include byte arrays.\n */\n\n// Import the conversion utility from algosdk\nconst { convertAbiByteArrays } = algosdk;\nconst {\n  ABIByteType,\n  ABIArrayStaticType,\n  ABIArrayDynamicType,\n  ABITupleType,\n  ABIBoolType,\n  ABIUintType,\n} = algosdk;\n\nconsole.log('=== ABI Byte Array Conversions Demo ===\\n');\n\n// Example 1: Convert nested byte arrays (byte[2][])\nconsole.log('Example 1: Converting nested byte arrays (byte[2][])');\nconsole.log('---------------------------------------------------');\n\n// Define the ABI type: byte[2][] (dynamic array of static byte arrays)\nconst byteType = new ABIByteType();\nconst innerArrayType = new ABIArrayStaticType(byteType, 2);\nconst outerArrayType = new ABIArrayDynamicType(innerArrayType);\n\n// Input: nested JavaScript arrays\nconst nestedValue = [\n  [1, 2],\n  [3, 4],\n  [5, 6],\n];\n\nconsole.log('Input:', JSON.stringify(nestedValue));\n\n// Convert to Uint8Array format\nconst nestedResult = convertAbiByteArrays(nestedValue, outerArrayType);\n\nconsole.log('Output: Array of Uint8Array instances');\nnestedResult.forEach((item, index) => {\n  console.log(`  [${index}]:`, Array.from(item as Uint8Array));\n});\nconsole.log();\n\n// Example 2: Non-byte arrays remain unchanged\nconsole.log('Example 2: Non-byte arrays (uint8[3]) are not converted');\nconsole.log('--------------------------------------------------------');\n\n// Define the ABI type: uint8[3] (NOT a byte array)\nconst uintType = new ABIUintType(8);\nconst uintArrayType = new ABIArrayStaticType(uintType, 3);\n\n// Input: regular number array\nconst uintValue = [1, 2, 3];\n\nconsole.log('Input:', JSON.stringify(uintValue));\n\n// Convert - should remain unchanged because it's not a byte array\nconst uintResult = convertAbiByteArrays(uintValue, uintArrayType);\n\nconsole.log('Output:', JSON.stringify(uintResult));\nconsole.log('Note: The array remains unchanged because uint8[] is not a byte[] type');\nconsole.log();\n\n// Example 3: Tuples with mixed types including byte arrays\nconsole.log('Example 3: Converting tuples with byte arrays (byte[2],bool,byte[3])');\nconsole.log('---------------------------------------------------------------------');\n\n// Define the ABI type: (byte[2], bool, byte[3])\nconst byteArray2Type = new ABIArrayStaticType(byteType, 2);\nconst byteArray3Type = new ABIArrayStaticType(byteType, 3);\nconst boolType = new ABIBoolType();\nconst tupleType = new ABITupleType([byteArray2Type, boolType, byteArray3Type]);\n\n// Input: tuple with byte arrays and a boolean\nconst tupleValue = [[1, 2], true, [3, 4, 5]];\n\nconsole.log('Input:', JSON.stringify(tupleValue));\n\n// Convert - only byte arrays are converted to Uint8Array\nconst tupleResult = convertAbiByteArrays(tupleValue, tupleType);\n\nconsole.log('Output:');\nconsole.log('  [0] (byte[2]):', Array.from(tupleResult[0] as Uint8Array));\nconsole.log('  [1] (bool):', tupleResult[1]);\nconsole.log('  [2] (byte[3]):', Array.from(tupleResult[2] as Uint8Array));\nconsole.log('Note: Only the byte arrays are converted; the boolean remains unchanged');\nconsole.log();\n\nconsole.log('=== Key Takeaways ===');\nconsole.log('1. convertAbiByteArrays() recursively converts byte[] types to Uint8Array');\nconsole.log('2. Other ABI types (uint, bool, etc.) remain unchanged');\nconsole.log('3. Works with nested structures (arrays of arrays, tuples)');\nconsole.log('4. Useful for preparing data for smart contract interactions');"
    },
    {
      "example_id": "83-abi-method-calls-with-default-arguments-from-state",
      "title": "ABI Method Calls with Default Arguments from State",
      "summary": "Demonstrates how to call ABI methods that use default arguments sourced from the application's global state and user's local state. Shows how smart contracts can use stored state values as default parameters for method calls.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "ABI method calls",
      "specific_use_case": "Call ABI methods with default arguments from global and local state",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ABI default arguments",
        "default value from global state",
        "default value from local state",
        "app.optIn",
        "app.call with method arguments"
      ],
      "feature_tags": [
        "abi",
        "default-arguments",
        "global-state",
        "local-state",
        "method-calls",
        "opt-in",
        "app-client"
      ],
      "folder": "83-abi-method-calls-with-default-arguments-from-state",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "App deployed with ID: <app-id>",
        "Global state value set and retrieved successfully",
        "Local state value set and retrieved successfully",
        "Method calls with both explicit and default arguments work correctly"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "from global state"
        },
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "from local state"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "artifacts/TestingApp/",
          "type": "contract",
          "action": "copy",
          "source_path": "tests/example-contracts/testing-app/",
          "note": "TestingApp contract artifacts including client and approval/clear programs"
        }
      ],
      "notes": "This example requires the TestingApp smart contract which includes methods that demonstrate default arguments from global and local state. The contract must have methods: set_global, set_local, default_value_from_global_state, default_value_from_local_state, opt_in, and create.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { TestingAppClient } from './artifacts/TestingApp/client'\n\n/**\n * This example demonstrates how to call ABI methods that have default arguments\n * sourced from the application's global state and user's local state.\n * \n * Default arguments allow smart contracts to use stored state values as method parameters,\n * reducing the need to pass the same values repeatedly and simplifying contract interactions.\n */\n\nasync function main() {\n  // Setup: Initialize test environment and deploy the app\n  const localnet = await algorandFixture()\n  const { algod, indexer, testAccount } = localnet.context\n  \n  const algorand = AlgorandClient.fromClients({ algod, indexer })\n  algorand.setDefaultSigner(testAccount.signer)\n\n  console.log('Deploying TestingApp...')\n  const appClient = algorand.client.getTypedAppClientById(TestingAppClient, {\n    id: 0, // Will be set after deployment\n    defaultSender: testAccount.addr,\n  })\n\n  // Deploy the application\n  await appClient.create({ method: 'create', methodArgs: [] })\n  console.log(`App deployed with ID: ${appClient.appId}\\n`)\n\n  // ===================================================================\n  // Example 1: Default Argument from Global State\n  // ===================================================================\n  console.log('--- Example 1: Default Argument from Global State ---')\n  \n  // First, set a value in global state that will be used as a default argument\n  const globalInt1 = 456n\n  console.log(`Setting global state value to: ${globalInt1}`)\n  \n  await appClient.call({\n    method: 'set_global',\n    methodArgs: [globalInt1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])]\n  })\n  console.log('Global state updated successfully')\n\n  // Now call a method that uses the global state value as a default argument\n  // When we don't provide the argument, it will use the value from global state\n  console.log('Calling method that uses default value from global state...')\n  const resultFromGlobal = await appClient.call({\n    method: 'default_value_from_global_state',\n    methodArgs: [123n] // Only providing the first arg, second arg will default to global state value\n  })\n  \n  console.log(`Result: ${resultFromGlobal.return}`)\n  console.log(`Expected: ${globalInt1} (value from global state)\\n`)\n\n  // ===================================================================\n  // Example 2: Default Argument from Local State\n  // ===================================================================\n  console.log('--- Example 2: Default Argument from Local State ---')\n  \n  // First, opt into the application to enable local state\n  console.log('Opting in to enable local state...')\n  await appClient.optIn({\n    method: 'opt_in',\n    methodArgs: []\n  })\n  console.log('Opted in successfully')\n\n  // Set a value in local state that will be used as a default argument\n  const localBytes1 = 'bananas'\n  console.log(`Setting local state value to: \"${localBytes1}\"`)\n  \n  await appClient.call({\n    method: 'set_local',\n    methodArgs: [1, 2, localBytes1, new Uint8Array([1, 2, 3, 4])]\n  })\n  console.log('Local state updated successfully')\n\n  // Call a method with an explicit value (overrides the default)\n  console.log('Calling method with explicit argument (overrides default)...')\n  const resultWithExplicit = await appClient.call({\n    method: 'default_value_from_local_state',\n    methodArgs: ['defined value']\n  })\n  console.log(`Result: \"${resultWithExplicit.return}\"`)\n  console.log('Expected: \"Local state, defined value\"\\n')\n\n  // Call the same method without providing the argument\n  // It will use the value from local state as the default\n  console.log('Calling method that uses default value from local state...')\n  const resultFromLocal = await appClient.call({\n    method: 'default_value_from_local_state',\n    methodArgs: [] // No args provided, will use local state value\n  })\n  console.log(`Result: \"${resultFromLocal.return}\"`)\n  console.log(`Expected: \"Local state, ${localBytes1}\"\\n`)\n\n  console.log('\u2705 All examples completed successfully!')\n  console.log('\\nKey Takeaways:')\n  console.log('- ABI methods can have default arguments sourced from global or local state')\n  console.log('- Global state defaults are shared across all users of the app')\n  console.log('- Local state defaults are specific to each opted-in user')\n  console.log('- Explicit arguments always override default values')\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "84-abi-methods-with-default-arguments-from-various-sources",
      "title": "ABI Methods with Default Arguments from Various Sources",
      "summary": "Demonstrates how to call ABI methods with default argument values computed from different sources: other ABI methods, global state, and local state.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call ABI methods with default arguments sourced from methods, global state, and local state",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ABI methods with default arguments",
        "default value from ABI method",
        "default value from global state",
        "default value from local state",
        "opt-in to application",
        "state management"
      ],
      "feature_tags": [
        "abi",
        "default-arguments",
        "global-state",
        "local-state",
        "method-calls",
        "smart-contracts",
        "state-management",
        "opt-in"
      ],
      "folder": "84-abi-methods-with-default-arguments-from-various-sources",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Deploy your smart contract with the required ABI methods"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Successful ABI method call with explicit argument value",
        "Successful ABI method call using default from another method",
        "Global state set successfully",
        "Successful method call using global state as default",
        "Account opted into application",
        "Local state set successfully",
        "Successful method call using local state as default"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "from abi method"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "from global state"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "from local state"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract implementing ABI methods with default arguments from various sources"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining default argument behavior and sources"
        }
      ],
      "notes": "This example combines three related test cases into a comprehensive demonstration of ABI default arguments. It requires a smart contract that implements methods with default argument specifications in the ABI. The contract should have methods that read defaults from: another method call, global state, and local state. Users should deploy their contract before running this example.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to work with ABI methods that have default arguments\n * sourced from different locations:\n * 1. Default values computed by another ABI method\n * 2. Default values read from global state\n * 3. Default values read from local state\n */\n\nasync function demonstrateAbiDefaultArguments() {\n  // Setup: Create a local Algorand testing environment\n  const localnet = await algorandFixture()\n  const algorand = localnet.context.algorand\n  const testAccount = localnet.context.testAccount\n\n  // Deploy the smart contract (assuming you have a factory for your contract)\n  // This would typically be generated from your TEAL contract\n  // For this example, we'll assume the contract is already deployed\n  // const appClient = await factory.deploy({ ... })\n  \n  console.log('=== ABI Methods with Default Arguments ===')\n  console.log('\\n1. Default Value from ABI Method')\n  console.log('   Calling method where default is computed by another method...')\n  \n  // Example 1: Default value from another ABI method\n  // When you don't provide the argument, the contract calls another method to get the default\n  const resultFromAbi = await appClient.send.call({\n    method: 'default_value_from_abi',\n    args: ['defined value'], // Providing explicit value\n  })\n  console.log('   With explicit value:', resultFromAbi.return?.value)\n  \n  // Call without the optional argument to use the default\n  const resultFromAbiDefault = await appClient.send.call({\n    method: 'default_value_from_abi',\n    args: [], // Omitting argument triggers default from ABI method\n  })\n  console.log('   With default value:', resultFromAbiDefault.return?.value)\n\n  console.log('\\n2. Default Value from Global State')\n  console.log('   Setting global state and using it as default...')\n  \n  // Example 2: Default value from global state\n  // First, set the global state value\n  const globalInt1 = 456n\n  await appClient.send.call({\n    method: 'set_global',\n    args: [globalInt1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])],\n  })\n  console.log('   Global state set to:', globalInt1)\n  \n  // Call with explicit value\n  const resultFromGlobal = await appClient.send.call({\n    method: 'default_value_from_global_state',\n    args: [123], // Providing explicit value\n  })\n  console.log('   With explicit value:', resultFromGlobal.return?.value)\n  \n  // Call without argument to use global state as default\n  const resultFromGlobalDefault = await appClient.send.call({\n    method: 'default_value_from_global_state',\n    args: [], // Omitting argument uses global state value\n  })\n  console.log('   With default from global state:', resultFromGlobalDefault.return?.value)\n\n  console.log('\\n3. Default Value from Local State')\n  console.log('   Opting in, setting local state, and using it as default...')\n  \n  // Example 3: Default value from local state\n  // First, opt into the application\n  await appClient.send.optIn({\n    method: 'opt_in',\n  })\n  console.log('   Account opted in to application')\n  \n  // Set the local state value\n  const localBytes1 = 'bananas'\n  await appClient.send.call({\n    method: 'set_local',\n    args: [1, 2, localBytes1, new Uint8Array([1, 2, 3, 4])],\n  })\n  console.log('   Local state set to:', localBytes1)\n  \n  // Call with explicit value\n  const resultFromLocal = await appClient.send.call({\n    method: 'default_value_from_local_state',\n    args: ['defined value'], // Providing explicit value\n  })\n  console.log('   With explicit value:', resultFromLocal.return?.value)\n  \n  // Call without argument to use local state as default\n  const resultFromLocalDefault = await appClient.send.call({\n    method: 'default_value_from_local_state',\n    args: [], // Omitting argument uses local state value\n  })\n  console.log('   With default from local state:', resultFromLocalDefault.return?.value)\n\n  console.log('\\n=== Example Complete ===')\n}\n\n// Run the example\ndemonstrateAbiDefaultArguments().catch(console.error)"
    },
    {
      "example_id": "85-arc56-error-debugging-without-source-maps",
      "title": "ARC56 Error Debugging Without Source Maps",
      "summary": "Demonstrates how ARC56 error messages provide useful debugging information even when source maps are not available, particularly when template variables affect code offsets.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Debug application errors without source maps when template variables affect offsets",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ARC56 error handling without source maps",
        "template variables in contracts",
        "error debugging with stack traces",
        "app client initialization",
        "method calls"
      ],
      "feature_tags": [
        "error-handling",
        "arc56",
        "debugging",
        "template-variables",
        "stack-traces",
        "app-client"
      ],
      "folder": "85-arc56-error-debugging-without-source-maps",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed with template variables",
        "Error caught with detailed stack trace",
        "Stack trace shows TEAL code location and failed assertion",
        "Template variable offset information visible in error"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "ARC56 undefined error message with dynamic template vars (cblock offset)"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "arc56_app.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 contract specification with template variables - would need to be copied from test fixtures"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        }
      ],
      "notes": "This example requires an ARC56 contract specification with template variables. The contract should have a 'tmpl' method that asserts on a uint64 template variable. The actual arc56_app.json artifact would need to be sourced from the test fixtures.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppFactory, AppClient } from '@algorandfoundation/algokit-utils/types/app'\nimport arc56AppSpec from './arc56_app.json' assert { type: 'json' }\n\n/**\n * Demonstrates ARC56 error debugging without source maps.\n * \n * This example shows how error messages still provide useful debugging information\n * even when source maps are not available. This is particularly important when\n * template variables affect code offsets (cblock offsets) in the compiled TEAL.\n */\nasync function main() {\n  console.log('=== ARC56 Error Debugging Without Source Maps ===')\n  console.log()\n\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.localNet.dispenser()\n\n  console.log('Step 1: Deploy application with template variables')\n  console.log('Template variables affect code offsets in the compiled TEAL')\n  \n  // Create app factory with ARC56 spec\n  const factory = algorand.client.getAppFactory({\n    appSpec: arc56AppSpec,\n    defaultSender: account.addr,\n  })\n\n  // Deploy the application with template variable values\n  const deployResult = await factory.deploy({\n    createParams: {\n      method: 'createApplication',\n    },\n    deployTimeParams: {\n      bytes64TmplVar: '0'.repeat(64),\n      uint64TmplVar: 0,\n      bytes32TmplVar: '0'.repeat(32),\n      bytesTmplVar: 'foo',\n    },\n  })\n\n  const appId = deployResult.result.appId\n  console.log(`\u2713 Application deployed with ID: ${appId}`)\n  console.log()\n\n  console.log('Step 2: Create new app client without source maps')\n  console.log('This simulates a scenario where source maps are not available')\n  \n  // Create a new client that won't have the source map from compilation\n  // This simulates connecting to an already-deployed app\n  const appClient = algorand.client.getAppClientById({\n    appId,\n    defaultSender: account.addr,\n    appSpec: arc56AppSpec,\n  })\n  console.log('\u2713 App client created')\n  console.log()\n\n  console.log('Step 3: Call method that will fail')\n  console.log('The method will assert on a template variable value')\n  console.log()\n\n  try {\n    // This call will fail because uint64TmplVar is 0\n    await appClient.send.call({ method: 'tmpl' })\n    console.log('\u274c Unexpected: call should have failed')\n  } catch (e: any) {\n    console.log('\u2713 Error caught as expected')\n    console.log()\n    console.log('Step 4: Examine error stack trace')\n    console.log('Even without source maps, the error provides useful debugging info:')\n    console.log()\n    console.log('--- Error Stack Trace ---')\n    \n    // Format and display the stack trace\n    const formattedStack = e.stack\n      .split('\\n')\n      .map((l: string) => l.trim())\n      .join('\\n')\n    \n    console.log(formattedStack)\n    console.log('--- End Stack Trace ---')\n    console.log()\n    \n    console.log('Key information in the error:')\n    console.log('- Source file location: tests/example-contracts/arc56_templates/templates.algo.ts:14')\n    console.log('- Failed assertion: assert(this.uint64TmplVar)')\n    console.log('- TEAL instruction: intc 1 // TMPL_uint64TmplVar')\n    console.log('- Template variable reference preserved in error output')\n    console.log()\n    console.log('This shows that even without source maps, ARC56 provides:')\n    console.log('  \u2022 Original source file references')\n    console.log('  \u2022 Template variable names')\n    console.log('  \u2022 TEAL instruction context')\n    console.log('  \u2022 Exact location of the failure')\n  }\n\n  console.log()\n  console.log('=== Example Complete ===')\n}\n\nmain().catch((error) => {\n  console.error('Unexpected error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "86-asa-clawback-and-asset-revocation",
      "title": "ASA Clawback and Asset Revocation",
      "summary": "Demonstrates how to use the clawback feature to revoke assets from one account and transfer them to another, essential for regulated assets and compliance use cases.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Use clawback functionality to transfer assets from a third-party account (revocationTarget) to another account",
      "target_users": [
        "Asset managers",
        "Compliance developers",
        "DeFi developers",
        "Regulated asset developers"
      ],
      "features_tested": [
        "algorand.send.assetTransfer",
        "clawbackTarget parameter",
        "algorand.send.assetOptIn",
        "algorand.asset.getAccountInformation"
      ],
      "feature_tags": [
        "asset-clawback",
        "asset-revocation",
        "asa",
        "compliance",
        "regulated-assets",
        "opt-in",
        "balance-verification"
      ],
      "folder": "86-asa-clawback-and-asset-revocation",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Funding accounts...",
        "Creating asset with clawback capability...",
        "Asset created with ID: <asset_id>",
        "Clawback address: <creator_address>",
        "Opting in accounts to asset...",
        "Both accounts opted in",
        "Transferring 5 units to clawbackFrom account...",
        "ClawbackFrom account balance: 5 units",
        "Executing clawback: revoking 5 units from clawbackFrom account...",
        "Clawback executed",
        "Verifying final balances...",
        "Receiver balance: 5 units",
        "ClawbackFrom balance: 0 units",
        "Creator balance: 95 units",
        "\u2705 Clawback successful!",
        "   - 5 units revoked from clawbackFrom account",
        "   - 5 units transferred to receiver account",
        "   - Creator retains 95 units"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.transfer.spec.ts",
          "test_name": "Transfer ASA, asset is transfered to another account from revocationTarget"
        }
      ],
      "artifacts_plan": [],
      "notes": "Clawback functionality must be specified when creating the asset. Only the designated clawback address can execute clawback operations. This is critical for regulated assets and compliance scenarios.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Example: ASA Clawback and Asset Revocation\n * \n * This example demonstrates:\n * 1. Creating an asset with clawback capability\n * 2. Distributing assets to accounts\n * 3. Using clawback to revoke assets from one account and send to another\n * 4. Verifying balances throughout the process\n * \n * Clawback is essential for:\n * - Regulated assets (securities tokens)\n * - Compliance requirements\n * - Asset recovery scenarios\n * - Correcting erroneous transfers\n */\n\nasync function asaClawbackExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a dispenser account with funds\n  const dispenser = await algorand.account.localNetDispenser()\n  \n  // Create three accounts:\n  // 1. Asset creator (also the clawback address)\n  // 2. Account to have assets clawed back from\n  // 3. Account to receive the clawed back assets\n  const creatorAccount = algorand.account.random()\n  const clawbackFromAccount = algorand.account.random()\n  const receiverAccount = algorand.account.random()\n  \n  // Fund all accounts\n  console.log('Funding accounts...')\n  await algorand.account.ensureFunded(creatorAccount, dispenser, algosdk.algos(10))\n  await algorand.account.ensureFunded(clawbackFromAccount, dispenser, algosdk.algos(1))\n  await algorand.account.ensureFunded(receiverAccount, dispenser, algosdk.algos(1))\n  \n  // Create an asset with clawback capability\n  // The creator account is set as the clawback address\n  console.log('\\nCreating asset with clawback capability...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: creatorAccount.addr,\n    total: 100n,\n    decimals: 0,\n    assetName: 'Regulated Asset',\n    unitName: 'REG',\n    clawback: creatorAccount.addr, // Enable clawback with creator as clawback address\n  })\n  const assetId = Number(assetCreate.confirmation.assetIndex)\n  console.log(`Asset created with ID: ${assetId}`)\n  console.log(`Clawback address: ${creatorAccount.addr}`)\n  \n  // Both accounts must opt-in to receive the asset\n  console.log('\\nOpting in accounts to asset...')\n  await algorand.send.assetOptIn({ \n    sender: clawbackFromAccount.addr, \n    assetId \n  })\n  await algorand.send.assetOptIn({ \n    sender: receiverAccount.addr, \n    assetId \n  })\n  console.log('Both accounts opted in')\n  \n  // Transfer 5 units to the clawbackFrom account\n  console.log('\\nTransferring 5 units to clawbackFrom account...')\n  await algorand.send.assetTransfer({\n    sender: creatorAccount.addr,\n    receiver: clawbackFromAccount.addr,\n    assetId,\n    amount: 5n,\n    note: `Transfer 5 assets with id ${assetId}`,\n  })\n  \n  const clawbackFromInfoBefore = await algorand.asset.getAccountInformation(clawbackFromAccount.addr, assetId)\n  console.log(`ClawbackFrom account balance: ${clawbackFromInfoBefore.balance} units`)\n  \n  // Now use clawback to revoke assets from clawbackFromAccount and send to receiverAccount\n  console.log('\\nExecuting clawback: revoking 5 units from clawbackFrom account...')\n  await algorand.send.assetTransfer({\n    sender: creatorAccount.addr,        // Clawback address (asset creator)\n    receiver: receiverAccount.addr,     // Where the clawed back assets go\n    assetId,\n    amount: 5n,\n    note: `Clawback 5 assets with id ${assetId}`,\n    clawbackTarget: clawbackFromAccount.addr, // Account to clawback from\n  })\n  console.log('Clawback executed')\n  \n  // Verify final balances\n  console.log('\\nVerifying final balances...')\n  const receiverInfo = await algorand.asset.getAccountInformation(receiverAccount.addr, assetId)\n  console.log(`Receiver balance: ${receiverInfo.balance} units`)\n  \n  const clawbackFromInfo = await algorand.asset.getAccountInformation(clawbackFromAccount.addr, assetId)\n  console.log(`ClawbackFrom balance: ${clawbackFromInfo.balance} units`)\n  \n  const creatorInfo = await algorand.asset.getAccountInformation(creatorAccount.addr, assetId)\n  console.log(`Creator balance: ${creatorInfo.balance} units`)\n  \n  // Verify the clawback was successful\n  if (receiverInfo.balance === 5n && clawbackFromInfo.balance === 0n && creatorInfo.balance === 95n) {\n    console.log('\\n\u2705 Clawback successful!')\n    console.log('   - 5 units revoked from clawbackFrom account')\n    console.log('   - 5 units transferred to receiver account')\n    console.log('   - Creator retains 95 units')\n  }\n}\n\n// Run the example\nasaClawbackExample().catch(console.error)"
    },
    {
      "example_id": "87-account-rekeying-with-application-opt-in",
      "title": "Account Rekeying with Application Opt-In",
      "summary": "Demonstrates how to rekey an account during an application transaction, useful for security management and key rotation strategies.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Rekey an account while opting into an application",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appClient.send.optIn",
        "rekeyTo parameter",
        "algorand.account.rekeyed",
        "account security"
      ],
      "feature_tags": [
        "account-rekeying",
        "opt-in",
        "transaction-management",
        "account-security",
        "app-client"
      ],
      "folder": "87-account-rekeying-with-application-opt-in",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded account configured"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "Account opted in and rekeyed",
        "Payment transaction succeeds using rekeyed account",
        "Confirmation that rekeying is working correctly"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Call app with rekey"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Standard TypeScript project configuration"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript compiler configuration"
        },
        {
          "target_file": "app-spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Application specification with opt_in method"
        }
      ],
      "notes": "This example demonstrates a powerful security feature. Account rekeying is useful for key rotation, multi-sig setups, and advanced account management scenarios. The example requires a smart contract with an opt_in method.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { consoleLogger } from '@algorandfoundation/algokit-utils/types/logging'\nimport { microAlgos } from '@algorandfoundation/algokit-utils/amount'\n\n/**\n * This example demonstrates account rekeying during an application opt-in.\n * \n * Account rekeying allows you to change the private key that has signing\n * authority for an account, which is useful for:\n * - Security rotation\n * - Multi-sig setups\n * - Key management strategies\n * \n * This example shows how to:\n * 1. Create and deploy an application\n * 2. Opt into the application while rekeying to a different account\n * 3. Use the rekeyed account to sign transactions\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get the main test account\n  const testAccount = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Main account address:', testAccount.addr)\n\n  // Create a random account to rekey to\n  // This account will gain signing authority over the main account\n  const rekeyTo = algorand.account.random()\n  console.log('Rekey target address:', rekeyTo.addr)\n\n  // Create an app factory (replace with your actual app spec)\n  const factory = algorand.client.getTypedAppFactory(/* Your app spec here */)\n\n  // Deploy the application\n  console.log('\\nDeploying application...')\n  const { appClient } = await factory.send.bare.create({\n    deployTimeParams: {\n      UPDATABLE: 0,\n      DELETABLE: 0,\n      VALUE: 1,\n    },\n  })\n  console.log('Application deployed with ID:', appClient.appId)\n\n  // Opt into the application AND rekey the account in a single transaction\n  console.log('\\nOpting into application and rekeying account...')\n  await appClient.send.optIn({\n    method: 'opt_in',\n    rekeyTo: rekeyTo, // Rekey to the new account during opt-in\n  })\n  console.log('\u2713 Account opted in and rekeyed successfully')\n  console.log('  The testAccount is now controlled by rekeyTo\\'s private key')\n\n  // Create a rekeyed account object\n  // This represents the original account (testAccount) but uses\n  // the private key from rekeyTo for signing\n  const rekeyedAccount = algorand.account.rekeyed(testAccount, rekeyTo)\n  console.log('\\nRekeyed account created:')\n  console.log('  Address:', rekeyedAccount.addr, '(original address)')\n  console.log('  Signer:', 'rekeyTo private key')\n\n  // Test the rekey by sending a transaction\n  // If the rekey didn't work, this will fail\n  console.log('\\nTesting rekeyed account by sending a payment...')\n  const result = await algorand.send.payment({\n    amount: microAlgos(0), // Zero-amount payment to test signing\n    sender: rekeyedAccount,\n    receiver: testAccount.addr,\n  })\n  console.log('\u2713 Payment successful with transaction ID:', result.txIds[0])\n  console.log('\\n\u2713 Account rekeying confirmed working!')\n  console.log('The rekeyed account can now sign transactions for the original address.')\n\n  // Important notes\n  console.log('\\n\ud83d\udcdd Important Notes:')\n  console.log('  - The account address never changes (still testAccount.addr)')\n  console.log('  - Only the signing authority changes (now rekeyTo\\'s key)')\n  console.log('  - All assets and apps remain at the original address')\n  console.log('  - To rekey back, use the rekeyTo account to sign a rekey transaction')\n}\n\nmain().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "88-asset-opt-out-bulk-operations",
      "title": "Asset Opt-Out Bulk Operations",
      "summary": "Shows how to remove assets from an account when they have zero balance, freeing up minimum balance requirements. Demonstrates the full lifecycle of opt-in and opt-out.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Opt-out of multiple assets from an account with zero balances",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.asset.bulkOptIn",
        "algorand.asset.bulkOptOut",
        "algorand.account.getInformation"
      ],
      "feature_tags": [
        "asset-opt-out",
        "bulk-operations",
        "account-state-management",
        "minimum-balance",
        "asset-management"
      ],
      "folder": "88-asset-opt-out-bulk-operations",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating test assets...",
        "Created assets with IDs: [asset_id_1], [asset_id_2]",
        "Account assets opted in before: 0",
        "Opting into 2 assets...",
        "Account assets opted in after opt-in: 2",
        "Opting out of 2 assets...",
        "Account assets opted in after opt-out: 0",
        "Successfully freed up minimum balance by opting out"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptOut of an asset to an account succeed"
        }
      ],
      "artifacts_plan": [],
      "notes": "Asset opt-out is only possible when the account has zero balance of that asset. Each asset opted into an account increases the minimum balance requirement by 0.1 ALGO.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to opt out of assets to free up minimum balance.\n * Opt-out is only possible when the account has zero balance of the asset.\n * Each asset opt-in increases minimum balance requirement by 0.1 ALGO.\n */\nasync function optOutOfAssets() {\n  // Initialize Algorand client for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get default accounts from LocalNet\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  const creator = await algorand.account.fromEnvironment('DISPENSER')\n\n  // Create a new account\n  const account = algorand.account.random()\n  \n  // Fund the account\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: account.addr,\n    amount: algosdk.algos(1),\n  })\n\n  // Step 1: Create two test assets (with 0 initial supply to ensure account has 0 balance)\n  console.log('Creating test assets...')\n  const assetCreate1 = await algorand.send.assetCreate({\n    sender: creator.addr,\n    total: 0n, // Zero total means no one will have any balance\n    decimals: 0,\n    assetName: 'Test Asset 1',\n  })\n  const assetId1 = BigInt(assetCreate1.confirmation.assetIndex!)\n\n  const assetCreate2 = await algorand.send.assetCreate({\n    sender: creator.addr,\n    total: 0n,\n    decimals: 0,\n    assetName: 'Test Asset 2',\n  })\n  const assetId2 = BigInt(assetCreate2.confirmation.assetIndex!)\n  \n  const assetIds = [assetId1, assetId2]\n  console.log(`Created assets with IDs: ${assetId1}, ${assetId2}`)\n\n  // Step 2: Check account state before opt-in\n  const accountInfoBefore = await algorand.account.getInformation(account.addr)\n  console.log(`\\nAccount assets opted in before: ${accountInfoBefore.totalAssetsOptedIn}`)\n\n  // Step 3: Opt into both assets\n  console.log(`\\nOpting into ${assetIds.length} assets...`)\n  await algorand.asset.bulkOptIn(account, assetIds, { validityWindow: 100 })\n  \n  const accountInfoAfterOptIn = await algorand.account.getInformation(account.addr)\n  console.log(`Account assets opted in after opt-in: ${accountInfoAfterOptIn.totalAssetsOptedIn}`)\n\n  // Step 4: Opt out of both assets (freeing up minimum balance)\n  console.log(`\\nOpting out of ${assetIds.length} assets...`)\n  await algorand.asset.bulkOptOut(account, assetIds, { validityWindow: 100 })\n  \n  // Step 5: Verify opt-out was successful\n  const accountInfoAfterOptOut = await algorand.account.getInformation(account.addr)\n  console.log(`Account assets opted in after opt-out: ${accountInfoAfterOptOut.totalAssetsOptedIn}`)\n\n  if (accountInfoAfterOptOut.totalAssetsOptedIn === 0) {\n    console.log('\\n\u2705 Successfully freed up minimum balance by opting out!')\n    console.log(`The account no longer holds any asset opt-ins.`)\n    console.log(`Each opt-out freed 0.1 ALGO from the minimum balance requirement.`)\n  } else {\n    console.log('\\n\u274c Opt-out incomplete')\n  }\n}\n\n// Run the example\noptOutOfAssets().catch(console.error)\n"
    },
    {
      "example_id": "89-asset-opt-out-error-handling",
      "title": "Asset Opt-Out Error Handling",
      "summary": "Demonstrates proper error handling when attempting to opt-out of assets, including validation for assets not opted into and assets with non-zero balances.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset management and error handling",
      "specific_use_case": "Handle errors when attempting to opt-out of assets that the account is not opted into or has non-zero balances",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.asset.bulkOptIn",
        "algorand.asset.bulkOptOut",
        "algorand.send.assetTransfer",
        "algorand.account.getInformation",
        "error handling for invalid opt-out operations"
      ],
      "feature_tags": [
        "asset-management",
        "opt-out",
        "error-handling",
        "validation",
        "bulk-operations",
        "asset-transfer"
      ],
      "folder": "89-asset-opt-out-error-handling",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Created test assets with unique IDs",
        "Error message when attempting to opt-out of non-opted-in assets",
        "Error message when attempting to opt-out of assets with non-zero balance",
        "Account information showing assets remain opted in after failed operations",
        "Key takeaways about opt-out validation rules"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptOut of an not opt-in asset to an account failed"
        },
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "Bulk OptOut of an non-zero balance asset to an account failed "
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines two error handling scenarios to demonstrate the validation rules for asset opt-out operations. It's important for developers to understand these constraints to build robust applications.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Account } from 'algosdk'\n\n/**\n * This example demonstrates error handling for asset opt-out operations.\n * It shows two common error scenarios:\n * 1. Attempting to opt-out of assets that the account is not opted into\n * 2. Attempting to opt-out of assets with non-zero balances\n */\n\nasync function assetOptOutErrorHandling() {\n  // Initialize AlgorandClient for localnet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get the default test account (assumes LocalNet is running)\n  const testAccount = (await algorand.account.localNetDispenser()).account\n  \n  console.log('=== Asset Opt-Out Error Handling Example ===\\n')\n\n  // Scenario 1: Attempting to opt-out of assets not opted into\n  console.log('--- Scenario 1: Opt-out of non-opted-in assets ---')\n  \n  // Create a test asset\n  const assetCreate1 = await algorand.send.assetCreate({\n    sender: testAccount.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Test Asset 1',\n  })\n  const asset1Id = BigInt(assetCreate1.confirmation.assetIndex!)\n  console.log(`Created test asset with ID: ${asset1Id}`)\n  \n  // Create a second account\n  const account1 = algorand.account.random()\n  await algorand.account.ensureFunded(account1, testAccount, (1).algo())\n  console.log(`Created account: ${account1.addr}\\n`)\n  \n  // Opt the account into the first asset\n  await algorand.asset.bulkOptIn(account1.addr, [asset1Id], { validityWindow: 100 })\n  \n  const accountInfo1 = await algorand.account.getInformation(account1.addr)\n  console.log(`Account opted into ${accountInfo1.totalAssetsOptedIn} asset(s)\\n`)\n  \n  // Try to opt-out of assets the account is NOT opted into\n  const invalidAssetIds = [asset1Id, 1234567n, 999999n]\n  console.log(`Attempting to opt-out of assets: ${invalidAssetIds.join(', ')}`)\n  \n  try {\n    await algorand.asset.bulkOptOut(account1.addr, invalidAssetIds, { validityWindow: 100 })\n    console.log('Opt-out succeeded (unexpected)')\n  } catch (error) {\n    console.log('\u2713 Expected error caught:')\n    console.log(`  ${(error as Error).message}\\n`)\n  }\n  \n  const accountInfoAfter1 = await algorand.account.getInformation(account1.addr)\n  console.log(`Account still opted into ${accountInfoAfter1.totalAssetsOptedIn} asset(s)\\n`)\n\n  // Scenario 2: Attempting to opt-out of assets with non-zero balance\n  console.log('--- Scenario 2: Opt-out of asset with non-zero balance ---')\n  \n  // Create two test assets\n  const assetCreate2 = await algorand.send.assetCreate({\n    sender: testAccount.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Test Asset 2',\n  })\n  const asset2Id = BigInt(assetCreate2.confirmation.assetIndex!)\n  \n  const assetCreate3 = await algorand.send.assetCreate({\n    sender: testAccount.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Test Asset 3',\n  })\n  const asset3Id = BigInt(assetCreate3.confirmation.assetIndex!)\n  console.log(`Created test assets with IDs: ${asset2Id}, ${asset3Id}`)\n  \n  // Create another account\n  const account2 = algorand.account.random()\n  await algorand.account.ensureFunded(account2, testAccount, (1).algo())\n  console.log(`Created account: ${account2.addr}\\n`)\n  \n  // Opt the account into both assets\n  await algorand.asset.bulkOptIn(account2.addr, [asset2Id, asset3Id], { validityWindow: 100 })\n  \n  const accountInfo2 = await algorand.account.getInformation(account2.addr)\n  console.log(`Account opted into ${accountInfo2.totalAssetsOptedIn} asset(s)\\n`)\n  \n  // Transfer some of the first asset to the account (giving it a non-zero balance)\n  await algorand.send.assetTransfer({\n    sender: testAccount.addr,\n    receiver: account2.addr,\n    assetId: asset2Id,\n    amount: 5n,\n  })\n  console.log(`Transferred 5 units of asset ${asset2Id} to account\\n`)\n  \n  // Try to opt-out of both assets (should fail because one has non-zero balance)\n  console.log(`Attempting to opt-out of assets: ${asset2Id}, ${asset3Id}`)\n  \n  try {\n    await algorand.asset.bulkOptOut(account2.addr, [asset2Id, asset3Id], { validityWindow: 100 })\n    console.log('Opt-out succeeded (unexpected)')\n  } catch (error) {\n    console.log('\u2713 Expected error caught:')\n    console.log(`  ${(error as Error).message}\\n`)\n  }\n  \n  const accountInfoAfter2 = await algorand.account.getInformation(account2.addr)\n  console.log(`Account still opted into ${accountInfoAfter2.totalAssetsOptedIn} asset(s)`)\n  console.log('(Both assets remain opted in due to validation failure)\\n')\n  \n  console.log('=== Key Takeaways ===')\n  console.log('1. You cannot opt-out of assets you have not opted into')\n  console.log('2. You cannot opt-out of assets with non-zero balances')\n  console.log('3. bulkOptOut validates all assets before processing')\n  console.log('4. If any asset fails validation, the entire operation is rejected')\n}\n\n// Run the example\nassetOptOutErrorHandling().catch(console.error)"
    },
    {
      "example_id": "90-asset-opt-out-with-balance-validation",
      "title": "Asset Opt-Out with Balance Validation",
      "summary": "Demonstrates how to safely opt-out of an asset with balance validation to prevent accidental loss of assets",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Attempt to opt-out of a single asset with non-zero balance when ensureZeroBalance is true",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.send.assetOptOut",
        "algorand.send.assetTransfer",
        "algorand.send.assetOptIn",
        "algorand.account.getInformation",
        "error handling for non-zero balance opt-out"
      ],
      "feature_tags": [
        "asset-management",
        "opt-out",
        "balance-validation",
        "error-handling",
        "asset-transfer"
      ],
      "folder": "90-asset-opt-out-with-balance-validation",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with AlgoKit: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Asset created with ID: [asset_id]",
        "Second account created and funded",
        "Second account opted into asset [asset_id]",
        "Transferred 5 units of asset to second account",
        "Second account asset balance: 5",
        "Attempting to opt-out with ensureZeroBalance=true...",
        "Error caught (expected): Account does not have a zero balance for Asset; can't opt-out",
        "Account still opted into 1 asset (opt-out prevented)"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptOut of non-zero balance single asset to an account fails by default"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows the safety mechanism of the ensureZeroBalance parameter, which prevents users from accidentally opting out of assets they still hold, which would result in permanent loss of those assets.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates asset opt-out validation.\n * \n * When opting out of an asset, you can use the ensureZeroBalance parameter\n * to prevent accidental loss of assets. If the account still holds any amount\n * of the asset, the opt-out will fail with a clear error message.\n */\n\nasync function assetOptOutValidationExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  console.log('=== Asset Opt-Out Validation Example ===')\n  console.log()\n\n  // Get default accounts from LocalNet\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  const creator = await algorand.account.fromEnvironment('ACCOUNT_1')\n  \n  // Create a second account to receive and hold the asset\n  const secondAccount = algorand.account.random()\n  console.log('Creating and funding second account...')\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: secondAccount.addr,\n    amount: microAlgos(1_000_000), // 1 ALGO\n  })\n  console.log(`Second account created: ${secondAccount.addr}`)\n  console.log()\n\n  // Create a test asset (fungible token with 0 decimals)\n  console.log('Creating test asset...')\n  const assetCreate = await algorand.send.assetCreate({\n    sender: creator.addr,\n    total: 1000n,\n    decimals: 0,\n    assetName: 'Test Token',\n  })\n  const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n  console.log(`Asset created with ID: ${assetId}`)\n  console.log()\n\n  // Second account opts into the asset\n  console.log('Second account opting into asset...')\n  await algorand.send.assetOptIn({\n    sender: secondAccount.addr,\n    assetId: assetId,\n  })\n  console.log(`Second account opted into asset ${assetId}`)\n  console.log()\n\n  // Transfer 5 units of the asset to the second account\n  console.log('Transferring 5 units of asset to second account...')\n  await algorand.send.assetTransfer({\n    sender: creator.addr,\n    receiver: secondAccount.addr,\n    assetId: assetId,\n    amount: 5n,\n  })\n  console.log(`Transferred 5 units of asset ${assetId} to second account`)\n  console.log()\n\n  // Verify the second account has the asset\n  const accountInfo = await algorand.account.getInformation(secondAccount.addr)\n  const assetHolding = accountInfo.assets?.find(a => a['asset-id'] === Number(assetId))\n  console.log(`Second account asset balance: ${assetHolding?.amount || 0}`)\n  console.log(`Total assets opted in: ${accountInfo.totalAssetsOptedIn}`)\n  console.log()\n\n  // Attempt to opt-out with ensureZeroBalance=true (should fail)\n  console.log('Attempting to opt-out with ensureZeroBalance=true...')\n  try {\n    await algorand.send.assetOptOut({\n      sender: secondAccount.addr,\n      creator: creator.addr,\n      assetId: assetId,\n      ensureZeroBalance: true, // This will prevent opt-out if balance > 0\n    })\n    console.log('ERROR: Opt-out should have failed but succeeded!')\n  } catch (error) {\n    console.log('\u2713 Error caught (expected):', (error as Error).message)\n    console.log()\n  }\n\n  // Verify the account is still opted into the asset\n  const accountInfoAfter = await algorand.account.getInformation(secondAccount.addr)\n  console.log(`Account still opted into ${accountInfoAfter.totalAssetsOptedIn} asset(s)`)\n  console.log('\u2713 Opt-out prevented successfully - assets are safe!')\n  console.log()\n\n  // To successfully opt-out, you would need to:\n  // 1. Transfer the assets back to the creator or another holder\n  // 2. Then call assetOptOut with ensureZeroBalance=true (or false)\n  console.log('To opt-out successfully, you must first transfer all assets back:')\n  console.log('1. Transfer assets: algorand.send.assetTransfer({ amount: 5n, ... })')\n  console.log('2. Then opt-out: algorand.send.assetOptOut({ ensureZeroBalance: true })')\n}\n\n// Run the example\nassetOptOutValidationExample().catch(console.error)"
    },
    {
      "example_id": "91-atomic-transaction-group-with-abi-method-call",
      "title": "Atomic Transaction Group with ABI Method Call",
      "summary": "Demonstrates how to create an atomic transaction group with a payment and an ABI method call to a smart contract, showing how to pass typed arguments and access return values.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Create an atomic transaction group with a payment and an ABI method call to a smart contract",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup.addAppCallMethodCall",
        "ABI method calls",
        "transaction groups"
      ],
      "feature_tags": [
        "atomic-transactions",
        "transaction-groups",
        "abi",
        "app-call",
        "payment",
        "method-call",
        "return-values"
      ],
      "folder": "91-atomic-transaction-group-with-abi-method-call",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALICE_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here..."
          },
          {
            "name": "BOB_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Generate typed client for TestContract using algokit generate client",
          "Ensure the smart contract is compiled and available"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Atomic transaction group executed with both payment and ABI method call",
        "Alice's balance decreased by 1 microAlgo (payment) + fees (approximately 2001 microAlgos total)",
        "Bob's balance increased by 1 microAlgo",
        "Smart contract method returns 3 (1 + 2)",
        "Transaction IDs for all transactions in the atomic group"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "addAppCallMethodCall"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "TestContract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple smart contract with a doMath ABI method that takes two numbers (uint64) and an operation (string) and returns the result (uint64)"
        }
      ],
      "notes": "This example demonstrates the addAppCallMethodCall method which provides a more direct way to call ABI methods compared to using compose().atc(). The method automatically handles ABI encoding/decoding and return value parsing.",
      "generated_code": "import { AlgorandClient, AlgoAmount } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils'\nimport { TestContractClient } from './contracts/TestContract' // Generated typed client\n\n// Configure AlgoKit\nConfig.configure({ debug: true })\n\nasync function atomicGroupWithMethodCall() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get funded accounts\n  const alice = await algorand.account.fromEnvironment('ALICE')\n  const bob = await algorand.account.fromEnvironment('BOB')\n\n  console.log('Setting up accounts...')\n  console.log(`Alice: ${alice.addr}`)\n  console.log(`Bob: ${bob.addr}`)\n\n  // Deploy the test contract (or use an existing one)\n  const appClient = new TestContractClient(\n    {\n      sender: alice,\n      resolveBy: 'id',\n      id: 0, // Will be set after deployment\n    },\n    algorand.client.algod\n  )\n\n  // Deploy the contract\n  await appClient.deploy({\n    onSchemaBreak: 'append',\n    onUpdate: 'append',\n  })\n  const appId = appClient.appId\n  console.log(`\\nContract deployed with App ID: ${appId}`)\n\n  // Get account balances before the transaction\n  const alicePreBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPreBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`\\nBalances before transaction:`)\n  console.log(`Alice: ${alicePreBalance.microAlgo} microAlgos`)\n  console.log(`Bob: ${bobPreBalance.microAlgo} microAlgos`)\n\n  // Get the ABI method definition from the app client\n  const doMathMethod = appClient.appClient.getABIMethod('doMath')!\n\n  console.log(`\\nBuilding atomic transaction group...`)\n  console.log(`Payment: Alice \u2192 Bob (1 microAlgo)`)\n  console.log(`App call: doMath(1, 2, 'sum')`)\n\n  // Create an atomic group with a payment and an ABI method call\n  const methodRes = await algorand\n    .newGroup()\n    .addPayment({\n      sender: alice.addr,\n      receiver: bob.addr,\n      amount: AlgoAmount.MicroAlgo(1), // Send 1 microAlgo to Bob\n      note: new Uint8Array([1]), // Optional note\n    })\n    .addAppCallMethodCall({\n      sender: alice.addr,\n      appId: appId,\n      method: doMathMethod, // ABI method from the contract\n      args: [1, 2, 'sum'], // Typed arguments: a=1, b=2, operation='sum'\n      note: 'addAppCallMethodCall', // Optional note\n    })\n    .send()\n\n  console.log(`\\n\u2713 Atomic transaction group executed successfully!`)\n  console.log(`Transaction IDs: ${methodRes.txIds.join(', ')}`)\n\n  // Get account balances after the transaction\n  const alicePostBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPostBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`\\nBalances after transaction:`)\n  console.log(`Alice: ${alicePostBalance.microAlgo} microAlgos (spent ${alicePreBalance.microAlgo - alicePostBalance.microAlgo} microAlgos including fees)`)\n  console.log(`Bob: ${bobPostBalance.microAlgo} microAlgos (received ${bobPostBalance.microAlgo - bobPreBalance.microAlgo} microAlgos)`)\n\n  // Access the return value from the ABI method call\n  const returnValue = methodRes.returns?.[0].returnValue?.valueOf()\n  console.log(`\\nSmart contract method result: ${returnValue} (1 + 2 = 3)`)\n\n  return methodRes\n}\n\n// Run the example\natomicGroupWithMethodCall().catch(console.error)"
    },
    {
      "example_id": "92-atomic-transaction-group-with-payment-and-app-call",
      "title": "Atomic Transaction Group with Payment and App Call",
      "summary": "Demonstrates how to create an atomic transaction group that combines a payment transaction with a smart contract method call using an AtomicTransactionComposer (ATC) from a generated typed client.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Create an atomic transaction group combining a payment and an app method call using an AtomicTransactionComposer from a generated client",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup",
        "algorand.newGroup.addPayment",
        "algorand.newGroup.addAtc",
        "generated client compose",
        "atomic transaction composer"
      ],
      "feature_tags": [
        "atomic-transactions",
        "transaction-groups",
        "atc",
        "app-call",
        "payment",
        "typed-client",
        "compose"
      ],
      "folder": "92-atomic-transaction-group-with-payment-and-app-call",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALICE_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here..."
          },
          {
            "name": "BOB_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start",
          "Generate typed client for TestContract using algokit generate client",
          "Ensure the smart contract is compiled and available"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Atomic transaction group executed with both payment and app call",
        "Alice's balance decreased by 1 microAlgo (payment) + fees (approximately 2001 microAlgos total)",
        "Bob's balance increased by 1 microAlgo",
        "Smart contract method returns 3 (1 + 2)",
        "Transaction IDs for all transactions in the atomic group"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "addAtc from generated client"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "TestContract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple smart contract with a doMath method that takes two numbers and an operation and returns the result"
        }
      ],
      "notes": "This example shows how to integrate a generated typed client's compose() method with the AlgorandClient's transaction group builder. The AtomicTransactionComposer (ATC) pattern is useful for complex transaction sequences.",
      "generated_code": "import { AlgorandClient, AlgoAmount } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils'\nimport { TestContractClient } from './contracts/TestContract' // Generated typed client\n\n// Configure AlgoKit\nConfig.configure({ debug: true })\n\nasync function atomicGroupWithAtc() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get funded accounts\n  const alice = await algorand.account.fromEnvironment('ALICE')\n  const bob = await algorand.account.fromEnvironment('BOB')\n\n  console.log('Setting up accounts...')\n  console.log(`Alice: ${alice.addr}`)\n  console.log(`Bob: ${bob.addr}`)\n\n  // Deploy the test contract (or use an existing one)\n  const appClient = new TestContractClient(\n    {\n      sender: alice,\n      resolveBy: 'id',\n      id: 0, // Will be set after deployment\n    },\n    algorand.client.algod\n  )\n\n  // Deploy the contract\n  await appClient.deploy({\n    onSchemaBreak: 'append',\n    onUpdate: 'append',\n  })\n  console.log(`\\nContract deployed with App ID: ${appClient.appId}`)\n\n  // Get account balances before the transaction\n  const alicePreBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPreBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`\\nBalances before transaction:`)\n  console.log(`Alice: ${alicePreBalance.microAlgo} microAlgos`)\n  console.log(`Bob: ${bobPreBalance.microAlgo} microAlgos`)\n\n  // Create an AtomicTransactionComposer using the generated client's compose method\n  console.log(`\\nBuilding atomic transaction group...`)\n  const doMathAtc = await appClient.compose().doMath({ a: 1, b: 2, operation: 'sum' }).atc()\n\n  // Create an atomic group with a payment and the ATC from the generated client\n  const result = await algorand\n    .newGroup()\n    .addPayment({\n      sender: alice.addr,\n      receiver: bob.addr,\n      amount: AlgoAmount.MicroAlgo(1), // Send 1 microAlgo to Bob\n    })\n    .addAtc(doMathAtc) // Add the app call from the generated client\n    .send()\n\n  console.log(`\\n\u2713 Atomic transaction group executed successfully!`)\n  console.log(`Transaction IDs: ${result.txIds.join(', ')}`)\n\n  // Get account balances after the transaction\n  const alicePostBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPostBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`\\nBalances after transaction:`)\n  console.log(`Alice: ${alicePostBalance.microAlgo} microAlgos (spent ${alicePreBalance.microAlgo - alicePostBalance.microAlgo} microAlgos including fees)`)\n  console.log(`Bob: ${bobPostBalance.microAlgo} microAlgos (received ${bobPostBalance.microAlgo - bobPreBalance.microAlgo} microAlgos)`)\n\n  // Check the return value from the smart contract method call\n  const returnValue = result.returns?.[0].returnValue?.valueOf()\n  console.log(`\\nSmart contract method result: ${returnValue} (1 + 2 = 3)`)\n\n  return result\n}\n\n// Run the example\natomicGroupWithAtc().catch(console.error)"
    },
    {
      "example_id": "93-automatic-retry-on-rate-limiting",
      "title": "Automatic Retry on Rate Limiting",
      "summary": "Demonstrates how AlgoKit Utils automatically retries requests when encountering HTTP 429 rate limit errors from Algorand nodes, ensuring reliable communication even under heavy load.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Handle automatic retries when algod or indexer clients encounter rate limiting",
      "target_users": [
        "SDK developers",
        "Backend developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "ClientManager.getAlgodClient",
        "ClientManager.getIndexerClient",
        "ClientManager.getAlgoNodeConfig",
        "algod.accountInformation",
        "indexer.lookupAccountByID",
        "retry mechanism"
      ],
      "feature_tags": [
        "retry",
        "rate-limiting",
        "error-handling",
        "algod",
        "indexer",
        "client-manager",
        "concurrent-requests",
        "resilience"
      ],
      "folder": "93-automatic-retry-on-rate-limiting",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "This example connects to Algorand TestNet",
          "No local node or environment variables required"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Starting concurrent requests to demonstrate retry mechanism...",
        "Making 150 concurrent algod requests...",
        "Successfully completed 150 algod requests",
        "Making 150 concurrent indexer requests...",
        "Successfully completed 150 indexer requests",
        "Note: If rate limits are hit, the SDK automatically retries the requests",
        "All requests completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Retries algod calls"
        },
        {
          "file": "src/types/client-manager.spec.ts",
          "test_name": "Retries indexer calls"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates the SDK's built-in resilience features. When making many concurrent requests, rate limits (HTTP 429) may be encountered. The SDK automatically retries these requests with exponential backoff, making your application more robust without requiring manual retry logic.",
      "generated_code": "import { ClientManager } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how AlgoKit Utils automatically retries requests\n * when encountering HTTP 429 (Too Many Requests) rate limit errors.\n * \n * The SDK includes built-in retry logic with exponential backoff, which makes\n * your application more resilient when dealing with API rate limits from\n * Algorand nodes.\n */\n\nasync function main() {\n  console.log('Starting concurrent requests to demonstrate retry mechanism...')\n  console.log()\n\n  // Example 1: Algod client with automatic retries\n  console.log('Making 150 concurrent algod requests...')\n  \n  // Get an algod client configured for TestNet\n  const algod = ClientManager.getAlgodClient(\n    ClientManager.getAlgoNodeConfig('testnet', 'algod')\n  )\n\n  // Make many concurrent requests to potentially trigger rate limiting\n  // The SDK will automatically retry any failed requests due to rate limits\n  const testAccount = 'XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA'\n  \n  try {\n    const algodResponses = await Promise.all(\n      new Array(150).fill(0).map(async () => {\n        // Each request gets account information\n        // If rate limited, the SDK will automatically retry\n        return await algod.accountInformation(testAccount).do()\n      })\n    )\n    \n    console.log(`Successfully completed ${algodResponses.length} algod requests`)\n    console.log(`Account balance: ${algodResponses[0].amount} microAlgos`)\n  } catch (error) {\n    console.error('Error with algod requests:', error)\n  }\n\n  console.log()\n\n  // Example 2: Indexer client with automatic retries\n  console.log('Making 150 concurrent indexer requests...')\n  \n  // Get an indexer client configured for TestNet\n  const indexer = ClientManager.getIndexerClient(\n    ClientManager.getAlgoNodeConfig('testnet', 'indexer')\n  )\n\n  try {\n    const indexerResponses = await Promise.all(\n      new Array(150).fill(0).map(async () => {\n        // Each request looks up account information via indexer\n        // If rate limited, the SDK will automatically retry\n        return await indexer.lookupAccountByID(testAccount).do()\n      })\n    )\n    \n    console.log(`Successfully completed ${indexerResponses.length} indexer requests`)\n    console.log(`Account address: ${indexerResponses[0].account.address}`)\n  } catch (error) {\n    console.error('Error with indexer requests:', error)\n  }\n\n  console.log()\n  console.log('Note: If rate limits are hit, the SDK automatically retries the requests')\n  console.log('You may see warning messages in the logs indicating retries are occurring')\n  console.log('All requests completed successfully!')\n}\n\n// Run the example\nmain().catch((error) => {\n  console.error('Fatal error:', error)\n  process.exit(1)\n})\n"
    },
    {
      "example_id": "94-bulk-asset-opt-in-multiple-assets",
      "title": "Bulk Asset Opt-In Multiple Assets",
      "summary": "Demonstrates how to efficiently opt into multiple assets at once, which is useful for accounts that need to hold many different assets. Shows batch processing of asset opt-ins.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Opt-in multiple assets (20 total) to an account in batches using bulk opt-in",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.asset.bulkOptIn",
        "algorand.account.getInformation",
        "multiple asset creation"
      ],
      "feature_tags": [
        "bulk-opt-in",
        "multiple-assets",
        "batch-processing",
        "asset-management",
        "account-state"
      ],
      "folder": "94-bulk-asset-opt-in-multiple-assets",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating 20 test assets...",
        "Created asset [n] with ID: [asset_id]",
        "Opting account into 20 assets...",
        "Successfully opted into 20 assets",
        "Account total assets opted in: 20"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptIn two batches of asset to an account succeed"
        }
      ],
      "artifacts_plan": [],
      "notes": "The bulk opt-in method automatically handles batching when the number of assets exceeds transaction limits. This is more efficient than individual opt-in transactions.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to opt an account into multiple assets at once\n * using the bulk opt-in method. This is much more efficient than individual opt-ins.\n */\nasync function bulkOptInToAssets() {\n  // Initialize Algorand client for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get default accounts from LocalNet\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  const creator = await algorand.account.fromEnvironment('DISPENSER')\n\n  // Create a new account that will opt into multiple assets\n  const account = algorand.account.random()\n  \n  // Fund the account with enough ALGOs for multiple opt-ins\n  // Each asset opt-in requires 0.1 ALGO minimum balance increase\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: account.addr,\n    amount: algosdk.algos(3),\n  })\n\n  // Step 1: Create 20 test assets\n  console.log('Creating 20 test assets...')\n  const assetIds: bigint[] = []\n  \n  for (let i = 0; i < 20; i++) {\n    const assetCreate = await algorand.send.assetCreate({\n      sender: creator.addr,\n      total: 1000n,\n      decimals: 0,\n      assetName: `Test Asset ${i + 1}`,\n    })\n    const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n    assetIds.push(assetId)\n    console.log(`Created asset ${i + 1} with ID: ${assetId}`)\n  }\n\n  // Step 2: Check account info before opt-in\n  const accountInfoBefore = await algorand.account.getInformation(account.addr)\n  console.log(`\\nAccount assets opted in before: ${accountInfoBefore.totalAssetsOptedIn}`)\n\n  // Step 3: Bulk opt-in to all 20 assets at once\n  console.log(`\\nOpting account into ${assetIds.length} assets...`)\n  await algorand.asset.bulkOptIn(account, assetIds, { validityWindow: 100 })\n  console.log(`Successfully opted into ${assetIds.length} assets`)\n\n  // Step 4: Verify all opt-ins were successful\n  const accountInfoAfter = await algorand.account.getInformation(account.addr)\n  console.log(`Account total assets opted in: ${accountInfoAfter.totalAssetsOptedIn}`)\n\n  if (accountInfoAfter.totalAssetsOptedIn === 20) {\n    console.log('\\n\u2705 Bulk asset opt-in successful!')\n    console.log(`The account is now opted into all ${assetIds.length} assets and can receive them.`)\n  } else {\n    console.log('\\n\u274c Bulk asset opt-in incomplete')\n  }\n}\n\n// Run the example\nbulkOptInToAssets().catch(console.error)\n"
    },
    {
      "example_id": "95-bulk-asset-opt-in-and-opt-out",
      "title": "Bulk Asset Opt-In and Opt-Out",
      "summary": "Demonstrates how to efficiently opt-in and opt-out of multiple assets in batches to manage account state",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset management",
      "specific_use_case": "Opt-in to 20 assets in bulk and then opt-out of all of them to reclaim minimum balance",
      "target_users": [
        "SDK developers",
        "DApp developers",
        "Asset managers"
      ],
      "features_tested": [
        "algorand.asset.bulkOptIn",
        "algorand.asset.bulkOptOut",
        "algorand.account.getInformation",
        "batch asset operations"
      ],
      "feature_tags": [
        "asset-management",
        "bulk-operations",
        "opt-in",
        "opt-out",
        "batch-processing",
        "account-cleanup"
      ],
      "folder": "95-bulk-asset-opt-in-and-opt-out",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with AlgoKit: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating 20 test assets...",
        "Created asset 1 with ID: [asset_id_1]",
        "...",
        "Created asset 20 with ID: [asset_id_20]",
        "Performing bulk opt-in for 20 assets...",
        "Account info after bulk opt-in:",
        "Total assets opted in: 20",
        "Performing bulk opt-out for 20 assets...",
        "Account info after bulk opt-out:",
        "Total assets opted in: 0",
        "\u2713 Successfully cleaned up all asset holdings and reclaimed minimum balance!"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "OptOut of two batches of asset to an account succeed"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example is useful for scenarios where accounts need to clean up multiple asset holdings at once. Each asset opt-in requires 0.1 ALGO minimum balance, so opting out of many assets can reclaim significant funds. The bulk operations automatically handle batching to stay within transaction group limits.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates bulk asset operations.\n * \n * Bulk opt-in and opt-out operations allow you to efficiently manage\n * multiple asset holdings at once. This is useful for:\n * - Setting up accounts to receive multiple tokens\n * - Cleaning up account state to reclaim minimum balance\n * - Managing portfolios of assets\n * \n * Each asset holding requires 0.1 ALGO minimum balance, so bulk opt-out\n * can reclaim significant funds when cleaning up many assets.\n */\n\nasync function bulkAssetOperationsExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  console.log('=== Bulk Asset Opt-In and Opt-Out Example ===')\n  console.log()\n\n  // Get default accounts from LocalNet\n  const dispenser = await algorand.account.dispenserFromEnvironment()\n  const creator = await algorand.account.fromEnvironment('ACCOUNT_1')\n  \n  // Create an account that will opt-in to multiple assets\n  const assetHolder = algorand.account.random()\n  console.log('Creating and funding asset holder account...')\n  // Fund with 3 ALGO to cover minimum balance for 20 assets + transaction fees\n  // Each asset requires 0.1 ALGO minimum balance\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: assetHolder.addr,\n    amount: microAlgos(3_000_000), // 3 ALGO\n  })\n  console.log(`Asset holder account created: ${assetHolder.addr}`)\n  console.log()\n\n  // Create 20 test assets\n  console.log('Creating 20 test assets...')\n  const assetIds: bigint[] = []\n  \n  for (let i = 1; i <= 20; i++) {\n    const assetCreate = await algorand.send.assetCreate({\n      sender: creator.addr,\n      total: 1000n,\n      decimals: 0,\n      assetName: `Test Token ${i}`,\n      unitName: `TT${i}`,\n    })\n    const assetId = BigInt(assetCreate.confirmation.assetIndex!)\n    assetIds.push(assetId)\n    console.log(`Created asset ${i} with ID: ${assetId}`)\n  }\n  console.log()\n  console.log(`Total assets created: ${assetIds.length}`)\n  console.log()\n\n  // Perform bulk opt-in\n  console.log('Performing bulk opt-in for 20 assets...')\n  console.log('(This automatically batches transactions into groups as needed)')\n  await algorand.asset.bulkOptIn(\n    assetHolder.addr,\n    assetIds,\n    { validityWindow: 100 }\n  )\n  console.log('\u2713 Bulk opt-in completed successfully!')\n  console.log()\n\n  // Check account info after opt-in\n  const accountInfoAfterOptIn = await algorand.account.getInformation(assetHolder.addr)\n  console.log('Account info after bulk opt-in:')\n  console.log(`  Address: ${accountInfoAfterOptIn.address}`)\n  console.log(`  Balance: ${accountInfoAfterOptIn.balance.microAlgo / 1_000_000} ALGO`)\n  console.log(`  Total assets opted in: ${accountInfoAfterOptIn.totalAssetsOptedIn}`)\n  console.log(`  Min balance: ${accountInfoAfterOptIn.minBalance.microAlgo / 1_000_000} ALGO`)\n  console.log()\n\n  // Perform bulk opt-out\n  console.log('Performing bulk opt-out for 20 assets...')\n  console.log('(This will reclaim the minimum balance held by asset holdings)')\n  await algorand.asset.bulkOptOut(\n    assetHolder.addr,\n    assetIds,\n    { validityWindow: 100 }\n  )\n  console.log('\u2713 Bulk opt-out completed successfully!')\n  console.log()\n\n  // Check account info after opt-out\n  const accountInfoAfterOptOut = await algorand.account.getInformation(assetHolder.addr)\n  console.log('Account info after bulk opt-out:')\n  console.log(`  Address: ${accountInfoAfterOptOut.address}`)\n  console.log(`  Balance: ${accountInfoAfterOptOut.balance.microAlgo / 1_000_000} ALGO`)\n  console.log(`  Total assets opted in: ${accountInfoAfterOptOut.totalAssetsOptedIn}`)\n  console.log(`  Min balance: ${accountInfoAfterOptOut.minBalance.microAlgo / 1_000_000} ALGO`)\n  console.log()\n\n  // Calculate reclaimed balance\n  const balanceChange = accountInfoAfterOptOut.balance.microAlgo - accountInfoAfterOptIn.balance.microAlgo\n  console.log(`Balance change: +${balanceChange / 1_000_000} ALGO (reclaimed minimum balance minus fees)`)\n  console.log('\u2713 Successfully cleaned up all asset holdings!')\n}\n\n// Run the example\nbulkAssetOperationsExample().catch(console.error)"
    },
    {
      "example_id": "96-call-abi-method-with-foreign-references",
      "title": "Call ABI Method with Foreign References",
      "summary": "Demonstrates how to call an ABI method with explicit foreign references including apps, accounts, and assets without automatic resource population.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call an ABI method with foreign references (apps, accounts, assets)",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "appReferences",
        "accountReferences",
        "assetReferences",
        "populateAppCallResources",
        "ABI method calls with foreign references"
      ],
      "feature_tags": [
        "abi",
        "foreign-references",
        "cross-app-call",
        "transaction-resources",
        "app-references",
        "account-references",
        "asset-references"
      ],
      "folder": "96-call-abi-method-with-foreign-references",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'",
          "Ensure you have a deployed smart contract with an ABI method that accepts foreign references"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction confirmed with return value showing referenced app, asset, and account details",
        "Example: 'App: 345, Asset: 567, Account: 123:456'"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Construct transaction with abi encoding including foreign references not in signature"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows how to manually specify foreign references when calling an ABI method. Setting populateAppCallResources to false means you must explicitly provide all app, account, and asset references needed by the contract.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Account } from 'algosdk'\n\n/**\n * This example demonstrates how to call an ABI method with explicit foreign references.\n * Foreign references allow your smart contract to interact with other apps, accounts, and assets.\n * \n * Key concepts:\n * - appReferences: Array of app IDs that the contract will reference\n * - accountReferences: Array of accounts that the contract will access\n * - assetReferences: Array of asset IDs that the contract will use\n * - populateAppCallResources: When false, you must explicitly provide all references\n */\n\nasync function callAbiWithForeignReferences() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create a test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('Test account address:', testAccount.addr)\n  \n  // Get the app client for your deployed contract\n  // Replace with your actual app ID and app spec\n  const appId = 123n // Replace with your deployed app ID\n  const client = algorand.client.getAppClientById({\n    appId: appId,\n    defaultSender: testAccount.addr,\n    // Add your app spec here\n  })\n  \n  console.log('\\nCalling ABI method with foreign references...')\n  \n  // Define the foreign references\n  const appReference = 345n // App ID to reference\n  const assetReference = 567n // Asset ID to reference\n  const accountReference = testAccount.addr // Account to reference\n  \n  try {\n    // Call the ABI method with explicit foreign references\n    const result = await client.send.call({\n      method: 'call_abi_foreign_refs',\n      // Explicitly specify foreign app references\n      appReferences: [appReference],\n      // Explicitly specify foreign account references\n      accountReferences: [accountReference],\n      // Explicitly specify foreign asset references\n      assetReferences: [assetReference],\n      // Disable automatic resource population - we're providing everything explicitly\n      populateAppCallResources: false,\n    })\n    \n    console.log('\\n\u2705 Transaction successful!')\n    console.log('Transaction ID:', result.transactions[0].txID())\n    console.log('Return value:', result.return)\n    console.log('\\nThe contract successfully accessed:')\n    console.log(`  - App ID: ${appReference}`)\n    console.log(`  - Asset ID: ${assetReference}`)\n    console.log(`  - Account: ${accountReference}`)\n    \n    // The return value shows how the contract used these references\n    console.log('\\nFull result:', JSON.stringify(result.return, null, 2))\n    \n  } catch (error) {\n    console.error('\\n\u274c Error calling method with foreign references:')\n    console.error(error)\n    throw error\n  }\n}\n\n// Run the example\ncallAbiWithForeignReferences()\n  .then(() => {\n    console.log('\\n\u2728 Example completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Example failed:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "97-call-abi-method-with-transaction-as-argument",
      "title": "Call ABI Method with Transaction as Argument",
      "summary": "Demonstrates how to call an ABI method that accepts a transaction as an argument, enabling complex multi-step operations and transaction composition.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction composition",
      "specific_use_case": "Call an ABI method that accepts a transaction as an argument",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.call",
        "ABI method with transaction argument",
        "AppManager.getABIReturn",
        "transaction groups",
        "createTransaction.payment"
      ],
      "feature_tags": [
        "abi-method",
        "transaction-argument",
        "transaction-composition",
        "atomic-transactions",
        "multi-transaction",
        "payment"
      ],
      "folder": "97-call-abi-method-with-transaction-as-argument",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost:4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID: <app_id>",
        "Creating payment transaction for <amount> microAlgos",
        "Calling ABI method with transaction argument...",
        "Transaction group sent successfully",
        "Number of transactions in group: 2",
        "Return value: Sent <amount>. test"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Construct transaction with abi encoding including transaction"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample ARC-32 app spec with call_abi_txn method that accepts transaction"
        }
      ],
      "notes": "This example demonstrates transaction composition where an ABI method accepts a transaction as an argument. This is useful for complex operations like verifying a payment was made before performing an action, or coordinating multiple transactions atomically.",
      "generated_code": "import { AlgorandClient, AppManager } from '@algorandfoundation/algokit-utils'\nimport { microAlgo } from '@algorandfoundation/algokit-utils/amount'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to call an ABI method that accepts a transaction\n * as one of its arguments. This enables powerful transaction composition patterns\n * where the smart contract can verify and react to other transactions in the same\n * atomic group.\n */\n\n// Sample app spec with call_abi_txn method that accepts a transaction argument\nconst appSpec = {\n  hints: {\n    call_abi_txn: {\n      call_config: {\n        no_op: 'CALL',\n      },\n    },\n  },\n  contract: {\n    name: 'TransactionCompositionApp',\n    methods: [\n      {\n        name: 'call_abi_txn',\n        args: [\n          { type: 'txn', name: 'payment_txn' },  // Transaction argument\n          { type: 'string', name: 'message' },\n        ],\n        returns: { type: 'string' },\n      },\n    ],\n  },\n  state: {\n    global: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n    local: {\n      num_byte_slices: 0,\n      num_uints: 0,\n    },\n  },\n  schema: {\n    global: {\n      declared: {},\n      reserved: {},\n    },\n    local: {\n      declared: {},\n      reserved: {},\n    },\n  },\n  source: {\n    approval: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n    clear: 'I3ByYWdtYSB2ZXJzaW9uIDEw',\n  },\n  bare_call_config: {\n    no_op: 'CREATE',\n    opt_in: 'NEVER',\n    close_out: 'NEVER',\n    update_application: 'NEVER',\n    delete_application: 'NEVER',\n  },\n  template_variables: {\n    UPDATABLE: { type: 'uint64' },\n    DELETABLE: { type: 'uint64' },\n    VALUE: { type: 'uint64' },\n  },\n}\n\nasync function callABIMethodWithTransactionArgument() {\n  // Initialize AlgorandClient for LocalNet\n  const algod = new algosdk.Algodv2('a' + 'a'.repeat(63), 'http://localhost', 4001)\n  const algorand = AlgorandClient.fromClients({ algod })\n\n  // Get a test account from the LocalNet dispenser\n  const testAccount = await algorand.account.fromEnvironment('LOCALNET')\n  console.log(`Using account: ${testAccount.addr}`)\n\n  // Step 1: Create and deploy the app\n  console.log('\\nCreating app...')\n  const appClient = algorand.client.getAppClient({\n    resolveBy: 'id',\n    app: appSpec,\n    sender: testAccount,\n    id: 0,\n  })\n\n  const createResult = await appClient.create({\n    deployTimeParams: {\n      UPDATABLE: 1,\n      DELETABLE: 1,\n      VALUE: 1,\n    },\n  })\n\n  console.log(`App created with ID: ${createResult.appId}`)\n\n  // Step 2: Create a payment transaction to pass as an argument\n  const paymentAmount = microAlgo(Math.ceil(Math.random() * 10000))\n  console.log(`\\nCreating payment transaction for ${paymentAmount.microAlgo} microAlgos`)\n  \n  const paymentTxn = await algorand.createTransaction.payment({\n    sender: testAccount.addr,\n    receiver: testAccount.addr,\n    amount: paymentAmount,\n  })\n\n  // Step 3: Call the ABI method with the transaction as an argument\n  console.log('\\nCalling ABI method with transaction argument...')\n  \n  /**\n   * When you pass a transaction as a methodArg, AlgoKit Utils will:\n   * 1. Automatically group the transactions together atomically\n   * 2. Handle the ABI encoding for the transaction reference\n   * 3. Sign and send both transactions as a group\n   */\n  const result = await appClient.call({\n    method: 'call_abi_txn',\n    methodArgs: [\n      paymentTxn,  // Pass the payment transaction as the first argument\n      'test',      // String message as second argument\n    ],\n  })\n\n  // Step 4: Process the results\n  console.log('Transaction group sent successfully!')\n  console.log(`Number of transactions in group: ${result.transactions.length}`)\n  console.log(`Transaction IDs: ${result.txIds.join(', ')}`)\n\n  // Step 5: Extract and display the ABI return value\n  if (result.confirmations && result.confirmations[1]) {\n    const abiMethod = appClient.getABIMethod('call_abi_txn')\n    if (abiMethod) {\n      const returnValue = AppManager.getABIReturn(\n        result.confirmations[1],\n        abiMethod\n      )\n      \n      if (returnValue?.returnValue) {\n        console.log(`\\nReturn value: ${returnValue.returnValue}`)\n        console.log(`Expected format: \"Sent ${paymentAmount.microAlgo}. test\"`)\n      }\n    }\n  }\n\n  console.log('\\n\u2705 Example completed successfully!')\n}\n\n// Run the example\ncallABIMethodWithTransactionArgument().catch(console.error)\n"
    },
    {
      "example_id": "98-create-algorand-application-with-deploy-time-parameters",
      "title": "Create Algorand Application with Deploy-Time Parameters",
      "summary": "Demonstrates how to create a new Algorand application using AppClient with deploy-time parameters and verify the creation result",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create a new application with deploy-time parameters and verify creation",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algokit.getAppClient",
        "client.create",
        "getApplicationAddress",
        "constructor deployTimeParams"
      ],
      "feature_tags": [
        "app-deployment",
        "app-creation",
        "deploy-time-parameters",
        "app-client",
        "smart-contracts"
      ],
      "folder": "98-create-algorand-application-with-deploy-time-parameters",
      "prerequisites": {
        "tools": [
          "AlgoKit",
          "Docker (for LocalNet)",
          "Node.js"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk",
          "typescript"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "INDEXER_PORT",
            "required": false,
            "example": "8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk typescript ts-node"
        ],
        "execute": [
          "npx ts-node main.ts"
        ]
      },
      "expected_output": [
        "=== Approach 1: Deploy-time parameters in create() method ===",
        "App created successfully!",
        "- App ID: <positive integer>",
        "- App Address: <58-character address>",
        "- Expected Address: <matching address>",
        "- Application Index: <matching app ID>",
        "- Compiled Approval Program: Present",
        "",
        "=== Approach 2: Deploy-time parameters in constructor ===",
        "App created with constructor params!",
        "- App ID: <positive integer>",
        "- App Address: <58-character address>",
        "",
        "=== Summary ===",
        "Both approaches successfully created apps with deploy-time parameters."
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Create app"
        },
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Create app with constructor deployTimeParams"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample app spec file for demonstration purposes. Replace with your actual compiled smart contract specification."
        }
      ],
      "notes": "This example combines two related test cases that demonstrate different ways to pass deploy-time parameters. Users will need to replace the appSpec with their actual compiled smart contract specification. Deploy-time parameters are template variables that get substituted into the TEAL code during compilation, allowing for customization of immutable contract parameters.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport { getApplicationAddress } from 'algosdk'\n\n/**\n * Demonstrates creating an Algorand application with deploy-time parameters.\n * \n * This example shows two approaches:\n * 1. Passing deploy-time parameters in the create() method\n * 2. Passing deploy-time parameters in the client constructor\n */\nasync function main() {\n  // Initialize AlgoKit with LocalNet\n  const localnet = await algokit.getLocalNetDispenserAccount(\n    algokit.getAlgoClient(),\n    algokit.getAlgoIndexerClient()\n  )\n  const algod = algokit.getAlgoClient()\n  const indexer = algokit.getAlgoIndexerClient()\n  const testAccount = localnet\n\n  // Load your app spec (replace with your actual app spec)\n  // This should be imported from your contract's artifacts\n  const appSpec = {\n    // Your app specification here\n    // Typically generated from your smart contract\n  } as algokit.AppSpec\n\n  console.log('\\n=== Approach 1: Deploy-time parameters in create() method ===')\n  \n  // Create an app client that resolves by creator and name\n  const client1 = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: testAccount,\n      creatorAddress: testAccount.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  // Create the app with deploy-time parameters\n  // Deploy-time parameters are template variables that get substituted during compilation\n  const app1 = await client1.create({\n    deployTimeParams: {\n      // The TMPL_ prefix is automatically stripped\n      TMPL_UPDATABLE: 0,  // Set if the app can be updated\n      DELETABLE: 0,       // Set if the app can be deleted\n      VALUE: 1,           // Custom app parameter\n    },\n  })\n\n  console.log('App created successfully!')\n  console.log('- App ID:', app1.appId)\n  console.log('- App Address:', app1.appAddress)\n  console.log('- Expected Address:', getApplicationAddress(app1.appId).toString())\n  console.log('- Application Index:', app1.confirmation?.applicationIndex?.toString())\n  console.log('- Compiled Approval Program:', app1.compiledApproval ? 'Present' : 'Missing')\n\n  console.log('\\n=== Approach 2: Deploy-time parameters in constructor ===')\n  \n  // Alternative approach: set deploy-time params in the constructor\n  const client2 = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      app: appSpec,\n      sender: testAccount,\n      id: 0,  // 0 means create a new app\n      deployTimeParams: {\n        UPDATABLE: 0,\n        DELETABLE: 0,\n        VALUE: 1,\n      },\n    },\n    algod,\n  )\n\n  // Create the app without needing to pass params again\n  const app2 = await client2.create()\n\n  console.log('App created with constructor params!')\n  console.log('- App ID:', app2.appId)\n  console.log('- App Address:', app2.appAddress)\n\n  console.log('\\n=== Summary ===')\n  console.log('Both approaches successfully created apps with deploy-time parameters.')\n  console.log('Choose the approach that best fits your application architecture:')\n  console.log('- Method params: Better for dynamic parameters')\n  console.log('- Constructor params: Better for consistent parameters across operations')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "99-create-app-with-deployment-metadata-and-retrieve-by-name",
      "title": "Create App with Deployment Metadata and Retrieve by Name",
      "summary": "Demonstrates how to create an Algorand application with deployment metadata (name, version, updatable, deletable) and retrieve it by name using the app deployer",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create an app with metadata and retrieve it by name to verify all metadata fields are correctly stored and returned",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.send.appCreate",
        "algorand.appDeployer.getCreatorAppsByName"
      ],
      "feature_tags": [
        "app-creation",
        "deployment-metadata",
        "app-retrieval",
        "metadata-storage",
        "app-deployer"
      ],
      "folder": "99-create-app-with-deployment-metadata-and-retrieve-by-name",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App created with ID and metadata",
        "Retrieved app information showing name, version, updatable, deletable flags",
        "Confirmation that metadata matches creation parameters"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Created app is retrieved by name with deployment metadata"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires LocalNet to be running and shows the fundamental pattern for creating apps with metadata that can be tracked and retrieved by name.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to:\n * 1. Create an Algorand application with deployment metadata\n * 2. Retrieve the app by creator address and name\n * 3. Verify all metadata fields are correctly stored\n */\n\nasync function main() {\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.fromEnvironment('ACCOUNT1')\n  console.log(`Using account: ${testAccount.addr}\\n`)\n\n  // Define deployment metadata\n  const appName = 'MY_APP'\n  const creationMetadata = {\n    name: appName,\n    version: '1.0',\n    updatable: true,\n    deletable: false\n  }\n\n  console.log('Creating app with metadata:')\n  console.log(JSON.stringify(creationMetadata, null, 2))\n  console.log()\n\n  // Create a simple app (using approval and clear programs)\n  // In production, replace these with your actual TEAL programs\n  const approvalProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n  const clearProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n\n  // Create the app with metadata\n  const appCreateResult = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    // Include metadata in the transaction note\n    note: new TextEncoder().encode(JSON.stringify(creationMetadata))\n  })\n\n  console.log(`\u2705 App created successfully!`)\n  console.log(`App ID: ${appCreateResult.appId}`)\n  console.log(`App Address: ${appCreateResult.appAddress}`)\n  console.log(`Confirmed in round: ${appCreateResult.confirmation.confirmedRound}\\n`)\n\n  // Wait for indexer to catch up (important for LocalNet)\n  console.log('Waiting for indexer to index the transaction...')\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  // Retrieve apps by name for this creator\n  const apps = await algorand.appDeployer.getCreatorAppsByName(testAccount.addr)\n\n  console.log('\\n\ud83d\udccb Retrieved apps by name:')\n  console.log(`Creator: ${apps.creator}`)\n  console.log(`Apps found: ${Object.keys(apps.apps).join(', ')}\\n`)\n\n  // Get the specific app we just created\n  const retrievedApp = apps.apps[appName]\n  \n  if (retrievedApp) {\n    console.log('\u2705 App metadata verification:')\n    console.log(`  App ID: ${retrievedApp.appId}`)\n    console.log(`  App Address: ${retrievedApp.appAddress}`)\n    console.log(`  Name: ${retrievedApp.name}`)\n    console.log(`  Version: ${retrievedApp.version}`)\n    console.log(`  Updatable: ${retrievedApp.updatable}`)\n    console.log(`  Deletable: ${retrievedApp.deletable}`)\n    console.log(`  Created Round: ${retrievedApp.createdRound}`)\n    console.log(`  Updated Round: ${retrievedApp.updatedRound}`)\n    console.log(`\\n  Created Metadata:`, retrievedApp.createdMetadata)\n    \n    // Verify the data matches\n    const isValid = \n      retrievedApp.appId === appCreateResult.appId &&\n      retrievedApp.name === creationMetadata.name &&\n      retrievedApp.version === creationMetadata.version &&\n      retrievedApp.updatable === creationMetadata.updatable &&\n      retrievedApp.deletable === creationMetadata.deletable\n    \n    console.log(`\\n${isValid ? '\u2705' : '\u274c'} Metadata verification: ${isValid ? 'PASSED' : 'FAILED'}`)\n  } else {\n    console.log(`\u274c App '${appName}' not found in retrieved apps`)\n  }\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "100-create-application-with-account-rekeying",
      "title": "Create Application with Account Rekeying",
      "summary": "Demonstrates how to create an application while simultaneously rekeying the sender account, and how to use the rekeyed account for subsequent transactions",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "account management",
      "specific_use_case": "Create an application while simultaneously rekeying the sender account to a different authority",
      "target_users": [
        "Smart contract developers",
        "SDK developers",
        "Security-focused developers",
        "Algorand developers"
      ],
      "features_tested": [
        "algorand.send.appCreate",
        "algorand.account.random",
        "algorand.account.rekeyed",
        "algorand.send.payment"
      ],
      "feature_tags": [
        "account-rekeying",
        "app-creation",
        "security",
        "authorization-delegation",
        "rekeyed-account",
        "smart-contracts"
      ],
      "folder": "100-create-application-with-account-rekeying",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [
          "algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Original account address displayed",
        "New authority address displayed",
        "Application created successfully",
        "Account rekeyed confirmation",
        "Rekeyed account object created",
        "Payment transaction from rekeyed account succeeds",
        "Explanation of how the rekey works"
      ],
      "source_tests": [
        {
          "file": "src/app.spec.ts",
          "test_name": "appCreate with rekey performs rekey"
        }
      ],
      "artifacts_plan": [],
      "notes": "Account rekeying is a powerful security feature. Be careful when using it, as the original private key will no longer be able to authorize transactions. Always ensure you have access to the new authority's private key before rekeying.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates account rekeying during application creation.\n * \n * Account rekeying allows you to delegate signing authority from one account\n * to another. This is useful for:\n * - Security: Rotating keys without changing the account address\n * - Multisig: Delegating authority to a multisig account\n * - Smart contracts: Allowing a contract to control an account\n * \n * This example shows:\n * 1. Creating an application with a rekey operation\n * 2. Using the rekeyed account for subsequent transactions\n */\n\nasync function createAppWithRekey() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a funded test account from the LocalNet dispenser\n  const originalAccount = await algorand.account.localNet.dispenser()\n  console.log('Original account address:', originalAccount.addr)\n\n  // Create a new random account that will become the signing authority\n  const newAuthority = algorand.account.random()\n  console.log('New authority address:', newAuthority.addr)\n  console.log('\\n\u2139\ufe0f  After rekeying, transactions from', originalAccount.addr)\n  console.log('   must be signed by', newAuthority.addr)\n\n  // For this example, we'll use simple TEAL programs\n  const approvalProgram = `\n#pragma version 8\nint 1\nreturn\n  `\n\n  const clearStateProgram = `\n#pragma version 8\nint 1\nreturn\n  `\n\n  // Compile the programs\n  const approvalCompiled = await algorand.app.compileTeal(approvalProgram)\n  const clearCompiled = await algorand.app.compileTeal(clearStateProgram)\n\n  // Define the state schema\n  const schema = {\n    globalUints: 1,\n    globalByteSlices: 1,\n    localUints: 0,\n    localByteSlices: 0,\n  }\n\n  console.log('\\nCreating application and rekeying account...')\n\n  // Create the application with a rekey operation\n  // The rekeyTo parameter delegates signing authority to the new account\n  const app = await algorand.send.appCreate({\n    approvalProgram: approvalCompiled,\n    clearStateProgram: clearCompiled,\n    schema: schema,\n    sender: originalAccount,\n    rekeyTo: newAuthority, // This is the key parameter for rekeying\n  })\n\n  console.log('\\n\u2705 Application created and account rekeyed!')\n  console.log('App ID:', app.appId.toString())\n  console.log('Transaction ID:', app.txIds[0])\n\n  // Now the originalAccount is rekeyed to newAuthority\n  // To use the original account, we need to create a rekeyed account object\n  console.log('\\nTesting rekeyed account...')\n  const rekeyedAccount = algorand.account.rekeyed(originalAccount, newAuthority)\n  console.log('Rekeyed account created - it uses:')\n  console.log('  - Address:', originalAccount.addr, '(for sender/from)')\n  console.log('  - Signing key:', newAuthority.addr, '(for authorization)')\n\n  // Send a payment transaction using the rekeyed account\n  // This transaction is FROM the original account address\n  // but SIGNED by the new authority\n  console.log('\\nSending transaction from rekeyed account...')\n  const payment = await algorand.send.payment({\n    amount: (0).algo(), // Zero-amount payment for demonstration\n    sender: rekeyedAccount,\n    receiver: originalAccount.addr,\n  })\n\n  console.log('\\n\u2705 Payment transaction successful!')\n  console.log('Transaction ID:', payment.txIds[0])\n  console.log('\\n\u2713 This proves the rekey worked - the transaction was:')\n  console.log('  - Sent FROM:', originalAccount.addr)\n  console.log('  - Signed BY:', newAuthority.addr)\n\n  console.log('\\n\u26a0\ufe0f  Important: From now on, all transactions from', originalAccount.addr)\n  console.log('   must be signed using', newAuthority.addr)\n  console.log('   The original signing key can no longer authorize transactions.')\n}\n\n// Run the example\ncreateAppWithRekey()\n  .then(() => console.log('\\nExample completed successfully'))\n  .catch((error) => {\n    console.error('Error:', error.message)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "101-create-an-asset-with-full-configuration",
      "title": "Create an Asset with Full Configuration",
      "summary": "Demonstrates how to create an Algorand Standard Asset (ASA) with all possible configuration options including metadata, role accounts (manager, reserve, freeze, clawback), and default frozen state.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "asset creation",
      "specific_use_case": "Create a new asset with full configuration including metadata, role accounts, and default frozen state",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "Asset creators"
      ],
      "features_tested": [
        "algorand.send.assetCreate",
        "algorand.asset.getById",
        "algorand.account.random"
      ],
      "feature_tags": [
        "asset-creation",
        "asa",
        "metadata",
        "role-accounts",
        "manager",
        "reserve",
        "freeze",
        "clawback",
        "asset-configuration"
      ],
      "folder": "101-create-an-asset-with-full-configuration",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run build",
          "node dist/main.js"
        ]
      },
      "expected_output": [
        "Creating asset with full configuration...",
        "Asset created successfully!",
        "Asset ID: <asset-id>",
        "Asset Details:",
        "- Creator: <creator-address>",
        "- Total supply: 1000",
        "- Decimals: 0",
        "- Unit name: TEST",
        "- Asset name: Test Asset",
        "- URL: https://example.com",
        "- Metadata hash: <hash>",
        "- Manager: <manager-address>",
        "- Reserve: <reserve-address>",
        "- Freeze: <freeze-address>",
        "- Clawback: <clawback-address>",
        "- Default frozen: true"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.asset.spec.ts",
          "test_name": "Create an asset succeeds"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example shows all configuration options available when creating an Algorand Standard Asset. Role accounts provide fine-grained control over asset management, and the default frozen state can prevent transfers until accounts are unfrozen.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to create an Algorand Standard Asset (ASA)\n * with all possible configuration options.\n * \n * Key concepts:\n * - Asset creation with metadata (name, unit name, URL, metadata hash)\n * - Role accounts for asset management:\n *   - Manager: Can reconfigure the asset's role accounts\n *   - Reserve: Account holding non-minted assets (informational)\n *   - Freeze: Can freeze/unfreeze asset holdings in accounts\n *   - Clawback: Can revoke assets from accounts\n * - Default frozen state: If true, accounts must be unfrozen before transfers\n * - Total supply and decimals configuration\n */\n\nasync function main() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n\n  // Get a funded test account to create the asset\n  const creator = algorand.account.localNet().dispenser\n\n  console.log('Creating asset with full configuration...\\n')\n\n  // Step 1: Generate accounts for each role\n  // These accounts will have different management capabilities for the asset\n  const managerAccount = algorand.account.random()\n  const reserveAccount = algorand.account.random()\n  const freezeAccount = algorand.account.random()\n  const clawbackAccount = algorand.account.random()\n\n  console.log('Role accounts:')\n  console.log(`- Manager: ${managerAccount.addr}`)\n  console.log(`- Reserve: ${reserveAccount.addr}`)\n  console.log(`- Freeze: ${freezeAccount.addr}`)\n  console.log(`- Clawback: ${clawbackAccount.addr}\\n`)\n\n  // Step 2: Create metadata hash (32 bytes)\n  // In production, this would typically be a hash of asset metadata stored off-chain\n  const metadataHash = new Uint8Array(32).fill(1)\n\n  // Step 3: Create the asset with full configuration\n  const result = await algorand.send.assetCreate({\n    sender: creator,\n    total: 1000n, // Total supply of 1000 units\n    decimals: 0, // No decimal places (whole units only)\n    assetName: 'Test Asset', // Full asset name (up to 32 bytes)\n    unitName: 'TEST', // Short ticker symbol (up to 8 bytes)\n    url: 'https://example.com', // URL with more info about the asset\n    metadataHash: metadataHash, // 32-byte hash of asset metadata\n    manager: managerAccount, // Can change role addresses\n    reserve: reserveAccount, // Holds non-minted assets (informational)\n    freeze: freezeAccount, // Can freeze/unfreeze holdings\n    clawback: clawbackAccount, // Can revoke assets from accounts\n    defaultFrozen: true, // Accounts must be unfrozen before transfers\n  })\n\n  console.log('Asset created successfully!')\n  console.log(`Asset ID: ${result.assetId}\\n`)\n\n  // Step 4: Retrieve and display the asset information\n  const assetData = await algorand.asset.getById(result.assetId)\n\n  console.log('Asset Details:')\n  console.log(`- Creator: ${assetData.creator}`)\n  console.log(`- Total supply: ${assetData.total}`)\n  console.log(`- Decimals: ${assetData.decimals}`)\n  console.log(`- Unit name: ${assetData.unitName}`)\n  console.log(`- Asset name: ${assetData.assetName}`)\n  console.log(`- URL: ${assetData.url}`)\n  console.log(`- Metadata hash: ${Buffer.from(assetData.metadataHash || []).toString('hex')}`)\n  console.log(`- Manager: ${assetData.manager}`)\n  console.log(`- Reserve: ${assetData.reserve}`)\n  console.log(`- Freeze: ${assetData.freeze}`)\n  console.log(`- Clawback: ${assetData.clawback}`)\n  console.log(`- Default frozen: ${assetData.defaultFrozen}\\n`)\n\n  console.log('\u2713 Asset created with all configuration options!')\n  console.log('\\nRole account capabilities:')\n  console.log('- Manager can update the manager, reserve, freeze, and clawback addresses')\n  console.log('- Reserve address is purely informational (no special permissions)')\n  console.log('- Freeze can freeze/unfreeze asset holdings in specific accounts')\n  console.log('- Clawback can revoke assets from accounts and send to another account')\n  console.log('- Default frozen means new opt-ins start frozen until explicitly unfrozen')\n}\n\nmain().catch(console.error)\n"
    },
    {
      "example_id": "102-custom-transaction-signer-for-group-signing",
      "title": "Custom Transaction Signer for Group Signing",
      "summary": "Demonstrates how to implement a custom TransactionSigner to control signing logic for transaction groups, including tracking which transaction indexes are signed.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "transaction signing",
      "specific_use_case": "Use a custom signer to sign all transactions in a group with an ABI call",
      "target_users": [
        "SDK developers",
        "Wallet developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "custom TransactionSigner",
        "transaction group signing",
        "sender parameter with custom signer",
        "ABI method calls with transaction arguments"
      ],
      "feature_tags": [
        "transaction-signing",
        "custom-signer",
        "transaction-groups",
        "abi-calls",
        "wallet-integration"
      ],
      "folder": "102-custom-transaction-signer-for-group-signing",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Custom signer called to sign transactions at indexes: 0,1",
        "Transaction group signed successfully",
        "Signed transaction indexes showing all group members were signed"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Sign all transactions in group with abi call with transaction arg"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample contract with call_abi_txn method that accepts a transaction and string argument"
        }
      ],
      "notes": "This example shows custom signer implementation which is crucial for wallet developers. The custom signer can be extended to include UI prompts, signing policies, hardware wallet integration, etc.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { TransactionSigner } from 'algosdk'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to implement a custom TransactionSigner\n * to control signing logic for transaction groups. This is useful for:\n * - Wallet integrations that need custom signing workflows\n * - Tracking which transactions are being signed\n * - Implementing conditional signing logic\n */\n\nasync function customTransactionSignerExample() {\n  // Initialize AlgoKit and get clients\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n\n  // Get a test account\n  const testAccount = await algorand.account.localNetDispenser()\n\n  console.log('Setting up application client...')\n  \n  // Deploy or get an existing application that has a method accepting transaction arguments\n  // For this example, assume we have a client for an app with 'call_abi_txn' method\n  // Replace this with your actual app deployment/client creation\n  const { client } = await deployYourApp(testAccount, algod, indexer)\n\n  // Create a payment transaction to pass as an argument\n  const txn = await algorand.createTransaction.payment({\n    sender: testAccount.addr,\n    receiver: testAccount.addr,\n    amount: algokit.microAlgo(5000),\n  })\n\n  console.log('Created payment transaction to use as method argument')\n\n  // Track which transaction indexes are being signed\n  let signedIndexes: number[] = []\n\n  // Implement a custom TransactionSigner\n  // This signer wraps the default signer but tracks which indexes are signed\n  const customSigner: TransactionSigner = (txnGroup, indexesToSign) => {\n    console.log(`Custom signer called to sign transactions at indexes: ${indexesToSign}`)\n    \n    // Store the indexes for logging/tracking\n    signedIndexes = indexesToSign\n    \n    // Delegate to the default signer for actual signing\n    // In a real wallet, you might show UI prompts, apply policies, etc.\n    return algokit.getSenderTransactionSigner(testAccount)(txnGroup, indexesToSign)\n  }\n\n  console.log('Calling ABI method with custom signer...')\n\n  // Call the ABI method with transaction argument and custom signer\n  const result = await client.call({\n    method: 'call_abi_txn',\n    methodArgs: [txn, 'test'],\n    sender: { addr: testAccount.addr, signer: customSigner },\n  })\n\n  console.log('\\nTransaction group signed successfully!')\n  console.log(`Signed transaction indexes: ${signedIndexes}`)\n  console.log(`Total transactions in group: ${result.transactions.length}`)\n  console.log(`Transaction IDs: ${result.transactions.map(t => t.txID()).join(', ')}`)\n\n  // The custom signer signed all transactions in the group (indexes [0, 1])\n  // Index 0: The ABI call transaction\n  // Index 1: The payment transaction passed as an argument\n  console.log('\\nCustom signer successfully tracked and signed all transactions in the group')\n}\n\n// Helper function placeholder - replace with your actual app deployment\nasync function deployYourApp(account: any, algod: any, indexer: any) {\n  // This is a placeholder - implement your actual app deployment logic\n  // The app should have a method like:\n  // call_abi_txn(txn: Transaction, note: string) -> void\n  throw new Error('Implement your app deployment logic here')\n}\n\n// Run the example\ncustomTransactionSignerExample().catch(console.error)"
    },
    {
      "example_id": "103-debug-smart-contract-logic-errors",
      "title": "Debug Smart Contract Logic Errors",
      "summary": "Demonstrates how to handle and debug logic errors in smart contracts with detailed error information including program counter, stack traces, and source code context.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Handle and debug logic errors in smart contracts",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "error handling",
        "logic error details",
        "error traces",
        "program counter tracking",
        "stack traces with source context"
      ],
      "feature_tags": [
        "error-handling",
        "debugging",
        "logic-errors",
        "stack-trace",
        "program-counter",
        "teal-debugging",
        "developer-experience"
      ],
      "folder": "103-debug-smart-contract-logic-errors",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'",
          "Deploy a smart contract with a method that contains a logic error (e.g., failed assert)"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Detailed error information including program counter (PC)",
        "Transaction ID of the failed transaction",
        "Stack trace showing exact TEAL source code with error location marked",
        "Error traces for debugging",
        "Pretty-printed error context"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Display nice error messages when there is a logic error"
        }
      ],
      "artifacts_plan": [],
      "notes": "AlgoKit Utils automatically provides enhanced error messages for logic errors. The 'led' (Logic Error Details) object contains comprehensive debugging information including PC, transaction ID, traces, and source code context when source maps are available.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to handle and debug logic errors in smart contracts.\n * \n * When a smart contract encounters a logic error (like a failed assert), AlgoKit Utils\n * provides detailed debugging information including:\n * - Program Counter (PC): The exact bytecode position where the error occurred\n * - Transaction ID: The ID of the failed transaction\n * - Stack trace: TEAL source code with the error location marked\n * - Traces: Execution traces for step-by-step debugging\n * - LED (Logic Error Details): Comprehensive error metadata\n * \n * This makes debugging smart contracts much easier compared to raw Algorand errors.\n */\n\nasync function demonstrateLogicErrorDebugging() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create a test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('Test account address:', testAccount.addr)\n  console.log('\\nThis example will intentionally trigger a logic error to demonstrate debugging features.\\n')\n  \n  // Get the app client for your deployed contract\n  // This should be a contract with an 'error' method that fails\n  const appId = 123n // Replace with your deployed app ID\n  const appSpec = {} // Replace with your app spec\n  \n  const client = algorand.client.getAppClientById({\n    appId: appId,\n    defaultSender: testAccount.addr,\n    appSpec: appSpec,\n  })\n  \n  console.log('Calling smart contract method that will fail...')\n  \n  try {\n    // Call a method that intentionally fails (e.g., has a failed assert)\n    await client.send.call({\n      method: 'error',\n    })\n    \n    // This line should never be reached\n    console.log('\u274c ERROR: Method should have failed but succeeded!')\n    \n  } catch (error: any) {\n    console.log('\\n\u2705 Logic error caught as expected!\\n')\n    \n    // The error object contains rich debugging information\n    console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550')\n    console.log('\ud83d\udcca LOGIC ERROR DETAILS (LED)')\n    console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n')\n    \n    if (error.led) {\n      // Program Counter: The exact position in the bytecode where the error occurred\n      console.log('\ud83c\udfaf Program Counter (PC):', error.led.pc)\n      console.log('   This is the bytecode position of the failing instruction\\n')\n      \n      // Error message from the blockchain\n      console.log('\ud83d\udcac Error Message:', error.led.msg)\n      console.log('   Raw error message from the Algorand node\\n')\n      \n      // Transaction ID of the failed transaction\n      console.log('\ud83d\udd17 Transaction ID:', error.led.txId)\n      console.log('   Use this to look up the transaction on AlgoExplorer\\n')\n      \n      // Execution traces (if available)\n      if (error.led.traces && error.led.traces.length > 0) {\n        console.log('\ud83d\udccb Execution Traces:', error.led.traces.length, 'trace(s) available')\n        console.log('   Traces show the execution path leading to the error\\n')\n      }\n    } else {\n      console.log('\u26a0\ufe0f  No LED information available (source maps may be missing)\\n')\n    }\n    \n    // Stack trace with source code context (when source maps are available)\n    if (error.stack) {\n      console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550')\n      console.log('\ud83d\udcc4 STACK TRACE WITH SOURCE CODE')\n      console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n')\n      \n      console.log(error.stack)\n      \n      console.log('\\n\u2728 The stack trace shows:')\n      console.log('   - The actual TEAL source code')\n      console.log('   - The exact line where the error occurred (marked with \"<--- Error\")')\n      console.log('   - Surrounding code context for better understanding')\n    } else {\n      console.log('\u26a0\ufe0f  No stack trace available\\n')\n    }\n    \n    console.log('\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550')\n    console.log('\ud83d\udca1 DEBUGGING TIPS')\n    console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n')\n    \n    console.log('1. Program Counter (PC):')\n    console.log('   - Shows exactly where in the bytecode the error occurred')\n    console.log('   - Useful for pinpointing issues in compiled code\\n')\n    \n    console.log('2. Source Maps:')\n    console.log('   - Enable source maps during compilation for better errors')\n    console.log('   - AlgoKit automatically includes source maps in debug builds\\n')\n    \n    console.log('3. Stack Traces:')\n    console.log('   - Read the marked line (\"<--- Error\") to see the failing instruction')\n    console.log('   - Review surrounding code to understand the context\\n')\n    \n    console.log('4. Traces:')\n    console.log('   - Use traces to follow the execution path')\n    console.log('   - Helpful for understanding how the contract reached the error\\n')\n    \n    console.log('5. Transaction ID:')\n    console.log('   - Look up on AlgoExplorer for additional details')\n    console.log('   - Can view full transaction state and inner transactions\\n')\n  }\n}\n\n// Run the example\ndemonstratLogicErrorDebugging()\n  .then(() => {\n    console.log('\\n\u2728 Example completed successfully!')\n    console.log('\\nYou now know how to debug logic errors in Algorand smart contracts!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Example failed:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "104-debug-teal-logic-errors-with-enhanced-error-messages",
      "title": "Debug TEAL Logic Errors with Enhanced Error Messages",
      "summary": "Demonstrates how AlgoKit Utils SDK automatically provides enhanced error messages when TEAL logic errors occur, including detailed stack traces, program counter information, and transaction traces.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Handle and debug a TEAL logic error with enhanced error messages",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "error handling",
        "logic error debugging",
        "error.led",
        "error traces",
        "TEAL stack traces"
      ],
      "feature_tags": [
        "error-handling",
        "debugging",
        "teal",
        "logic-errors",
        "app-client",
        "error-traces"
      ],
      "folder": "104-debug-teal-logic-errors-with-enhanced-error-messages",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application deployed with ID",
        "Logic error caught with enhanced debugging information",
        "Program counter (PC) location",
        "Detailed TEAL stack trace",
        "Transaction ID and error message",
        "Number of traces available"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Display nice error messages when there is a logic error"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple contract with an error method that demonstrates TEAL logic errors"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        }
      ],
      "notes": "This example requires a smart contract with an 'error' method that intentionally fails with an assert. The enhanced error messages are automatically provided by the AlgoKit Utils SDK.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how AlgoKit Utils SDK provides enhanced error messages\n * when TEAL logic errors occur during smart contract execution.\n * \n * The SDK automatically:\n * - Captures the TEAL stack trace\n * - Provides the program counter (PC) where the error occurred\n * - Shows the exact TEAL instruction that failed\n * - Includes transaction traces for debugging\n */\n\nasync function debugLogicErrors() {\n  // Initialize the AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.localNet.dispenser()\n  \n  console.log('Deploying application with intentional error...')\n  \n  // Deploy your application (replace with your app spec)\n  // This example assumes you have an appSpec with an 'error' method\n  const appClient = algorand.client.getTypedAppClient({\n    sender: testAccount,\n    // Your app spec here\n  })\n  \n  await appClient.create.bare()\n  const app = await appClient.appClient.getAppReference()\n  \n  console.log(`Application deployed with ID: ${app.appId}`)\n  console.log(`Application address: ${app.appAddress}`)\n  \n  // Call a method that will cause a TEAL logic error\n  console.log('\\nCalling method that will trigger a logic error...')\n  \n  try {\n    await appClient.call({\n      method: 'error',\n      methodArgs: [],\n    })\n    \n    // This line should never be reached\n    console.log('No error occurred (unexpected!)')\n    \n  } catch (e: any) {\n    console.log('\\n\u274c Logic error caught! Here\\'s the enhanced debugging information:\\n')\n    \n    // The SDK provides a 'led' (Logic Error Details) object\n    console.log('=== Logic Error Details (e.led) ===')\n    console.log(`Program Counter: ${e.led.pc}`)\n    console.log(`Error Message: ${e.led.msg}`)\n    console.log(`Transaction ID: ${e.led.txId}`)\n    console.log(`Number of traces: ${e.led.traces.length}`)\n    \n    // The stack trace shows exactly where in the TEAL code the error occurred\n    console.log('\\n=== TEAL Stack Trace ===')\n    console.log(e.stack)\n    \n    // Additional information available in the error object\n    console.log('\\n=== Additional Debug Info ===')\n    console.log(`Transaction confirmed: ${e.led.txId.length === 52}`)\n    console.log(`Error type: TEAL logic error (assert failed)`)\n    \n    // The error details help you:\n    // 1. Find the exact line in your TEAL code that failed\n    // 2. Understand why the assertion failed\n    // 3. Access transaction traces for step-by-step debugging\n    \n    console.log('\\n\u2705 Error debugging information successfully captured')\n    console.log('\\nKey features demonstrated:')\n    console.log('- Detailed TEAL stack traces showing the error location')\n    console.log('- Program counter (PC) for pinpointing the instruction')\n    console.log('- Transaction ID for looking up details on the blockchain')\n    console.log('- Error traces for step-by-step debugging')\n    console.log('\\nThis makes debugging TEAL logic errors much easier!')\n  }\n}\n\ndebugLogicErrors().catch(console.error)"
    },
    {
      "example_id": "105-decode-abi-uint-types-with-number-and-bigint-handling",
      "title": "Decode ABI Uint Types with Number and BigInt Handling",
      "summary": "Demonstrates how to decode all valid ABI uint types (uint8 through uint512) and understand when values are returned as number vs bigint based on bit length.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "ABI decoding",
      "specific_use_case": "Decode all valid uint types with proper type mapping (number vs bigint)",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "getABIDecodedValue",
        "uint decoding",
        "ARC-56",
        "ABIUintType",
        "number vs bigint conversion"
      ],
      "feature_tags": [
        "abi-decoding",
        "uint-types",
        "number-vs-bigint",
        "arc-56",
        "type-safety",
        "data-encoding",
        "smart-contracts"
      ],
      "folder": "105-decode-abi-uint-types-with-number-and-bigint-handling",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install",
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Complete list of all uint types (uint8 through uint512)",
        "Decoded values with their JavaScript types",
        "Clear indication of the number/bigint boundary at 53 bits",
        "Detailed examples showing arithmetic operations with both types",
        "Boundary case comparison between uint48 and uint56"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "correctly decodes a uint%i"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining uint types and the number/bigint distinction"
        }
      ],
      "notes": "This example is crucial for developers to understand type handling when working with smart contracts. The 53-bit boundary (Number.MAX_SAFE_INTEGER) is a JavaScript limitation that affects how uint values are returned.",
      "generated_code": "import { getABIDecodedValue } from '@algorandfoundation/algokit-utils/types/app-arc56'\nimport { ABIUintType } from 'algosdk'\n\n/**\n * This example demonstrates how to decode ABI uint types and understand\n * the automatic type conversion between JavaScript number and bigint.\n * \n * Key insight: JavaScript numbers can safely represent integers up to 2^53 - 1.\n * Therefore:\n * - uint8 through uint48 (< 53 bits) are decoded as number\n * - uint56 through uint512 (>= 53 bits) are decoded as bigint\n */\n\nfunction main() {\n  console.log('=== ABI Uint Type Decoding Example ===')\n  console.log()\n  console.log('JavaScript safe integer range: -(2^53 - 1) to (2^53 - 1)')\n  console.log('Threshold: uint types < 53 bits \u2192 number, >= 53 bits \u2192 bigint')\n  console.log()\n\n  // Generate all valid ABI uint bit lengths (uint8, uint16, uint24, ..., uint512)\n  const validBitLengths = Array.from({ length: 64 }, (_, i) => (i + 1) * 8)\n\n  console.log('Decoding uint types across all valid bit lengths:')\n  console.log('==================================================')\n  console.log()\n\n  // Test decoding for each uint type\n  validBitLengths.forEach((bitLength) => {\n    // Encode the value 1 using the appropriate uint type\n    const abiType = new ABIUintType(bitLength)\n    const encoded = abiType.encode(1)\n\n    // Decode the value back\n    const decoded = getABIDecodedValue(encoded, `uint${bitLength}`, {})\n\n    // Determine expected type based on bit length\n    const expectedType = bitLength < 53 ? 'number' : 'bigint'\n    const actualType = typeof decoded\n    const typeMatch = expectedType === actualType ? '\u2713' : '\u2717'\n\n    console.log(\n      `uint${bitLength.toString().padStart(3, ' ')}: ` +\n      `${decoded.toString().padStart(2, ' ')} ` +\n      `(${actualType.padEnd(6, ' ')}) ${typeMatch}`\n    )\n  })\n\n  console.log()\n  console.log('Detailed examples:')\n  console.log('------------------')\n\n  // Example 1: uint32 (will be a number)\n  console.log()\n  console.log('Example 1: uint32 (32 bits < 53 bits)')\n  const uint32Type = new ABIUintType(32)\n  const encodedUint32 = uint32Type.encode(42)\n  const decodedUint32 = getABIDecodedValue(encodedUint32, 'uint32', {})\n  console.log(`  Encoded value: 42`)\n  console.log(`  Decoded value: ${decodedUint32}`)\n  console.log(`  Type: ${typeof decodedUint32}`)\n  console.log(`  Can use arithmetic: ${decodedUint32} + 8 = ${(decodedUint32 as number) + 8}`)\n\n  // Example 2: uint64 (will be a bigint)\n  console.log()\n  console.log('Example 2: uint64 (64 bits >= 53 bits)')\n  const uint64Type = new ABIUintType(64)\n  const encodedUint64 = uint64Type.encode(1000000000000)\n  const decodedUint64 = getABIDecodedValue(encodedUint64, 'uint64', {})\n  console.log(`  Encoded value: 1000000000000`)\n  console.log(`  Decoded value: ${decodedUint64}`)\n  console.log(`  Type: ${typeof decodedUint64}`)\n  console.log(`  Can use BigInt arithmetic: ${decodedUint64} + 8n = ${(decodedUint64 as bigint) + 8n}`)\n\n  // Example 3: Boundary case - uint48 (number) vs uint56 (bigint)\n  console.log()\n  console.log('Example 3: Boundary between number and bigint')\n  const uint48Type = new ABIUintType(48)\n  const uint56Type = new ABIUintType(56)\n  const encodedUint48 = uint48Type.encode(1)\n  const encodedUint56 = uint56Type.encode(1)\n  const decodedUint48 = getABIDecodedValue(encodedUint48, 'uint48', {})\n  const decodedUint56 = getABIDecodedValue(encodedUint56, 'uint56', {})\n  console.log(`  uint48 (48 bits): type = ${typeof decodedUint48} \u2190 last uint as number`)\n  console.log(`  uint56 (56 bits): type = ${typeof decodedUint56} \u2190 first uint as bigint`)\n\n  console.log()\n  console.log('=== Example Complete ===')\n  console.log('Key takeaway: Always check the bit length of uint types to know')\n  console.log('whether to expect number or bigint in your TypeScript code.')\n}\n\nmain()"
    },
    {
      "example_id": "106-deploy-app-with-replacement-strategy",
      "title": "Deploy App with Replacement Strategy",
      "summary": "Demonstrates how to deploy a new version of an app by replacing the existing app with a completely new one, including deletion of the old app and creation of a new app with updated code.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy a deletable app, then deploy with onUpdate='replace' to delete the old app and create a new one",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "onUpdate parameter",
        "app replacement",
        "app deletion"
      ],
      "feature_tags": [
        "deployment",
        "app-replacement",
        "versioning",
        "lifecycle-management",
        "deletable-apps"
      ],
      "folder": "106-deploy-app-with-replacement-strategy",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded account for deployment"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial app deployed with v1.0",
        "Initial app ID displayed",
        "Replacement app deployed with v2.0",
        "New app ID displayed (different from initial)",
        "Confirmation that old app was deleted",
        "Summary showing the replacement strategy worked"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy replacement to deletable, updated app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package.json with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Explanation of the replacement strategy and when to use it"
        }
      ],
      "notes": "This example focuses on the 'replace' deployment strategy, which is useful when you want to completely replace an app rather than update it in place. The app must be marked as deletable for this strategy to work.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to replace an existing Algorand app with a new one.\n * \n * When you need to deploy a new version of your app but prefer complete replacement\n * over updating the existing app, you can use the 'replace' strategy. This will:\n * 1. Delete the old app (if it's deletable)\n * 2. Create a new app with the updated code and metadata\n * \n * This is useful when:\n * - You want a clean slate with a new app ID\n * - The changes are too significant for an update\n * - You want to reset all global/local state\n */\n\nasync function main() {\n  // Initialize AlgorandClient for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  \n  console.log('=== Deploying Initial App (v1.0) ===')\n  console.log(`Using account: ${account.addr}\\n`)\n  \n  // Define approval and clear programs for v1.0\n  const approvalProgramV1 = `#pragma version 10\n  // Simple approval program v1.0\n  int 1\n  return`\n  \n  const clearProgram = `#pragma version 10\n  // Clear state program\n  int 1\n  return`\n  \n  // Compile the programs\n  const approvalV1 = await algorand.client.algod.compile(approvalProgramV1).do()\n  const clear = await algorand.client.algod.compile(clearProgram).do()\n  \n  // Deploy the first version of the app\n  // Set deletable: true so we can replace it later\n  const deployment1 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approvalV1.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: {\n      name: 'MyApp',\n      version: '1.0',\n      deletable: true,  // Important: must be deletable to allow replacement\n      updatable: true,\n    },\n  }\n  \n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  \n  console.log(`\u2705 Initial deployment successful!`)\n  console.log(`   App ID: ${result1.appId}`)\n  console.log(`   Version: ${result1.version}`)\n  console.log(`   Operation: ${result1.operationPerformed}`)\n  console.log(`   Deletable: ${result1.deletable}`)\n  console.log(`   Updatable: ${result1.updatable}\\n`)\n  \n  // Wait a moment for the transaction to be processed\n  await new Promise(resolve => setTimeout(resolve, 1000))\n  \n  console.log('=== Deploying Replacement App (v2.0) ===')\n  \n  // Define updated approval program for v2.0\n  const approvalProgramV2 = `#pragma version 10\n  // Updated approval program v2.0 with changes\n  int 2\n  return`\n  \n  const approvalV2 = await algorand.client.algod.compile(approvalProgramV2).do()\n  \n  // Deploy the replacement app\n  // Use onUpdate: 'replace' to delete old app and create new one\n  const deployment2 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approvalV2.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: {\n      name: 'MyApp',\n      version: '2.0',\n      deletable: true,\n      updatable: true,\n    },\n    onUpdate: 'replace',  // This triggers the replacement strategy\n  }\n  \n  const result2 = await algorand.appDeployer.deploy(deployment2)\n  \n  console.log(`\u2705 Replacement deployment successful!`)\n  console.log(`   New App ID: ${result2.appId}`)\n  console.log(`   Old App ID: ${result1.appId}`)\n  console.log(`   App IDs are different: ${result2.appId !== result1.appId}`)\n  console.log(`   Version: ${result2.version}`)\n  console.log(`   Operation: ${result2.operationPerformed}`)\n  \n  // Check if the old app was deleted\n  if (result2.deleteResult) {\n    console.log(`   \u2705 Old app was deleted successfully`)\n    console.log(`   Delete transaction ID: ${result2.deleteResult.transaction.txID()}\\n`)\n  }\n  \n  console.log('=== Summary ===')\n  console.log(`The replacement strategy allows you to:`)\n  console.log(`1. Delete the old app (App ID: ${result1.appId})`)\n  console.log(`2. Create a new app (App ID: ${result2.appId})`)\n  console.log(`3. Start fresh with new state and a new app ID`)\n  console.log(`\\nNote: The old app must be deletable for this to work!`)\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "107-deploy-new-algorand-application",
      "title": "Deploy New Algorand Application",
      "summary": "Demonstrates how to deploy a new Algorand application using the appDeployer with deployment metadata, including proper configuration for updatability and deletability controls.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy a new app with deployment metadata and verify all fields are correctly set",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "getApplicationAddress",
        "deployment metadata",
        "application creation"
      ],
      "feature_tags": [
        "app-deployment",
        "deployment-metadata",
        "idempotency",
        "smart-contracts",
        "application-lifecycle",
        "updatable-apps",
        "deletable-apps"
      ],
      "folder": "107-deploy-new-algorand-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "App ID: <number>",
        "App Address: <algorand address>",
        "Created Round: <number>",
        "Application Name: <name from metadata>",
        "Version: <version from metadata>",
        "Updatable: <boolean>",
        "Deletable: <boolean>"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy new app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample TEAL approval program with TMPL_UPDATABLE and TMPL_DELETABLE template variables"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample TEAL clear state program"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "NPM package configuration with required dependencies"
        }
      ],
      "notes": "This example demonstrates the recommended high-level API for app deployment using appDeployer. It shows how to configure deployment metadata including updatability and deletability controls.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { getApplicationAddress } from 'algosdk'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\n/**\n * This example demonstrates how to deploy a new Algorand application using the appDeployer.\n * The appDeployer is the recommended high-level API for app deployment as it handles:\n * - Idempotent deployments (won't redeploy if the app already exists)\n * - Deployment metadata tracking\n * - Updatability and deletability controls\n */\nasync function deployNewApp() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get a test account with funds from the LocalNet dispenser\n  const deployer = await algorand.account.localNet.dispenser()\n  \n  console.log('Deployer account:', deployer.addr)\n\n  // Read the approval and clear state programs\n  const approvalProgram = fs.readFileSync(\n    path.join(__dirname, 'approval.teal'),\n    'utf8'\n  )\n  const clearProgram = fs.readFileSync(\n    path.join(__dirname, 'clear.teal'),\n    'utf8'\n  )\n\n  // Compile the TEAL programs\n  const approvalCompiled = await algorand.client.algod.compile(approvalProgram).do()\n  const clearCompiled = await algorand.client.algod.compile(clearProgram).do()\n\n  // Define deployment metadata\n  // This metadata is used for idempotent deployments and tracking\n  const metadata = {\n    name: 'MyExampleApp',\n    version: '1.0.0',\n    updatable: true,  // Can be updated after deployment\n    deletable: true,  // Can be deleted after deployment\n  }\n\n  console.log('\\nDeploying application with metadata:', metadata)\n\n  // Create the deployment parameters\n  const deployment = {\n    sender: deployer.addr,\n    metadata,\n    createParams: {\n      approvalProgram: new Uint8Array(Buffer.from(approvalCompiled.result, 'base64')),\n      clearStateProgram: new Uint8Array(Buffer.from(clearCompiled.result, 'base64')),\n      globalNumUint: 1,\n      globalNumByteSlice: 1,\n      localNumUint: 0,\n      localNumByteSlice: 0,\n    },\n    deployTimeParams: {\n      TMPL_UPDATABLE: metadata.updatable ? 1 : 0,\n      TMPL_DELETABLE: metadata.deletable ? 1 : 0,\n    },\n  }\n\n  try {\n    // Deploy the application\n    // This will create the app on the blockchain\n    const result = await algorand.appDeployer.deploy(deployment)\n\n    console.log('\\n\u2705 Application deployed successfully!')\n    console.log('\\nDeployment Details:')\n    console.log('-------------------')\n    console.log('App ID:', result.appId.toString())\n    console.log('App Address:', result.appAddress)\n    console.log('Transaction ID:', result.transaction.txID())\n    console.log('Created Round:', result.createdRound.toString())\n    console.log('Updated Round:', result.updatedRound.toString())\n    console.log('\\nMetadata:')\n    console.log('Name:', result.name)\n    console.log('Version:', result.version)\n    console.log('Updatable:', result.updatable)\n    console.log('Deletable:', result.deletable)\n    console.log('Deleted:', result.deleted)\n\n    // Verify the app address matches the expected address\n    const expectedAddress = getApplicationAddress(result.appId)\n    console.log('\\nVerification:')\n    console.log('Expected Address:', expectedAddress)\n    console.log('Matches:', result.appAddress === expectedAddress ? '\u2713' : '\u2717')\n\n    return result\n  } catch (error) {\n    console.error('\u274c Deployment failed:', error)\n    throw error\n  }\n}\n\n// Run the example\ndeployNewApp()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Example failed:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "108-export-and-import-source-maps-for-debugging",
      "title": "Export and Import Source Maps for Debugging",
      "summary": "Shows how to export source maps from one app client instance and import them into another for enhanced error debugging with source code context.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Export and import source maps for better error debugging",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.exportSourceMaps",
        "client.importSourceMaps",
        "error debugging with source context"
      ],
      "feature_tags": [
        "debugging",
        "source-maps",
        "error-handling",
        "serialization",
        "developer-tools"
      ],
      "folder": "108-export-and-import-source-maps-for-debugging",
      "prerequisites": {
        "tools": [
          "algokit"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet with 'algokit localnet start'",
          "Deploy a smart contract with source maps"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Error without source map shows generic 'assert failed' message",
        "Error with imported source map shows exact TEAL source code location with context",
        "Stack trace includes source code snippet with error marker"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Export and import of source map works"
        }
      ],
      "artifacts_plan": [],
      "notes": "Source maps map compiled TEAL bytecode back to the original source code, providing much better error messages during debugging. This is especially useful when sharing client instances or debugging across different environments.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to export and import source maps for better error debugging.\n * \n * Source maps allow you to:\n * - See the exact TEAL source code that caused an error\n * - Get meaningful stack traces with source context\n * - Share debugging information between client instances\n * - Preserve source maps across serialization/deserialization\n * \n * Without source maps, errors show generic messages like \"assert failed pc=885\"\n * With source maps, you see the actual source code line that caused the error\n */\n\nasync function demonstrateSourceMaps() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create a test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('Test account address:', testAccount.addr)\n  \n  // Deploy or get an existing app client\n  // This should be a contract with source maps included\n  const appId = 123n // Replace with your deployed app ID\n  const appSpec = {} // Replace with your app spec\n  \n  const originalClient = algorand.client.getAppClientById({\n    appId: appId,\n    defaultSender: testAccount.addr,\n    appSpec: appSpec,\n  })\n  \n  console.log('\\n\ud83d\udce6 Exporting source maps from original client...')\n  \n  // Export source maps from the original client\n  // This contains the mapping from bytecode to source code\n  const sourceMaps = originalClient.exportSourceMaps()\n  \n  console.log('\u2705 Source maps exported successfully')\n  console.log('Source map data size:', JSON.stringify(sourceMaps).length, 'bytes')\n  \n  // Create a new client instance (simulating a fresh client or different context)\n  console.log('\\n\ud83d\udd27 Creating new client instance without source maps...')\n  \n  const newClient = algorand.client.getAppClientById({\n    appId: appId,\n    defaultSender: testAccount.addr,\n    appSpec: appSpec,\n  })\n  \n  // First, try calling an error method WITHOUT source maps imported\n  console.log('\\n\u274c Attempting to trigger error WITHOUT source maps...')\n  try {\n    await newClient.send.call({\n      method: 'error', // This method intentionally fails\n    })\n  } catch (error: any) {\n    console.log('\\nError caught (without source maps):')\n    console.log('  Message:', error.message || 'Unknown error')\n    console.log('  Stack trace:', error.stack ? 'Generic - contains \"assert failed\"' : 'No stack')\n    // Without source maps, the error is less helpful\n  }\n  \n  // Now import the source maps into the new client\n  console.log('\\n\ud83d\udce5 Importing source maps into new client...')\n  \n  // Source maps can be serialized and deserialized (e.g., saved to file, sent over network)\n  const serializedSourceMaps = JSON.parse(JSON.stringify(sourceMaps))\n  newClient.importSourceMaps(serializedSourceMaps)\n  \n  console.log('\u2705 Source maps imported successfully')\n  \n  // Now try the same error WITH source maps imported\n  console.log('\\n\u274c Attempting to trigger error WITH source maps...')\n  try {\n    await newClient.send.call({\n      method: 'error', // This method intentionally fails\n    })\n  } catch (error: any) {\n    console.log('\\nError caught (with source maps):')\n    console.log('  Message:', error.message || 'Unknown error')\n    \n    // With source maps, we get detailed error information\n    if (error.led) {\n      console.log('\\n\ud83d\udccd Error Details:')\n      console.log('  Program Counter (PC):', error.led.pc)\n      console.log('  Transaction ID:', error.led.txId)\n      console.log('  Error Message:', error.led.msg)\n      \n      if (error.led.traces && error.led.traces.length > 0) {\n        console.log('  Number of traces:', error.led.traces.length)\n      }\n    }\n    \n    // The stack trace now includes source code context\n    if (error.stack) {\n      console.log('\\n\ud83d\udcc4 Stack Trace with Source Context:')\n      console.log(error.stack)\n      console.log('\\n\u2728 Notice the source code context with \"<--- Error\" marker!')\n    }\n  }\n  \n  console.log('\\n\ud83d\udca1 Key Takeaways:')\n  console.log('  - Source maps can be exported and imported between client instances')\n  console.log('  - They can be serialized (e.g., saved to file or sent over network)')\n  console.log('  - Importing source maps provides much better error messages')\n  console.log('  - Error messages include exact TEAL source code and line numbers')\n  console.log('  - This is invaluable for debugging smart contract issues')\n}\n\n// Run the example\ndemonstratSourceMaps()\n  .then(() => {\n    console.log('\\n\u2728 Example completed successfully!')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Example failed:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "109-export-and-import-source-maps-for-enhanced-error-debugging",
      "title": "Export and Import Source Maps for Enhanced Error Debugging",
      "summary": "Demonstrates how to export source maps from an app client and import them into another client instance to get detailed TEAL stack traces when debugging smart contract errors.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Export and import source maps for enhanced error debugging",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.exportSourceMaps",
        "client.importSourceMaps",
        "error debugging",
        "TEAL stack traces"
      ],
      "feature_tags": [
        "source-maps",
        "debugging",
        "error-handling",
        "teal",
        "app-client"
      ],
      "folder": "109-export-and-import-source-maps-for-enhanced-error-debugging",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Application deployed with ID",
        "Source maps exported successfully",
        "Error caught without source maps (limited info)",
        "Source maps imported successfully",
        "Enhanced stack trace with TEAL code",
        "Program counter and error location details"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Export and import of source map works"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple contract with an error method that demonstrates TEAL debugging"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        }
      ],
      "notes": "This example requires a smart contract with an 'error' method that intentionally fails. The artifacts should include a simple contract for demonstration purposes.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to export and import source maps for enhanced error debugging.\n * Source maps allow you to see the original TEAL source code in stack traces when errors occur,\n * making it much easier to debug smart contract issues.\n */\n\nasync function exportAndImportSourceMaps() {\n  // Initialize the AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.localNet.dispenser()\n  \n  console.log('Deploying application...')\n  \n  // Deploy your application (replace with your app spec)\n  // This example assumes you have an appSpec with an 'error' method\n  const appClient = algorand.client.getTypedAppClient({\n    sender: testAccount,\n    // Your app spec here\n  })\n  \n  await appClient.create.bare()\n  const app = await appClient.appClient.getAppReference()\n  \n  console.log(`Application deployed with ID: ${app.appId}`)\n  \n  // Export the source maps from the original client\n  console.log('\\nExporting source maps from original client...')\n  const exportedSourceMaps = appClient.exportSourceMaps()\n  console.log('Source maps exported successfully')\n  \n  // Create a new client instance for the same app (without source maps)\n  console.log('\\nCreating new app client without source maps...')\n  const newClient = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      id: app.appId,\n      sender: testAccount,\n      // Your app spec here\n    },\n    algod,\n  )\n  \n  // Try calling an error method without source maps\n  console.log('\\nCalling error method without source maps...')\n  try {\n    await newClient.call({\n      method: 'error',\n      methodArgs: [],\n    })\n  } catch (e: any) {\n    console.log('Error caught (without source maps):')\n    console.log('Stack trace contains:', e.stack.substring(0, 100) + '...')\n    console.log('Limited debugging information available')\n  }\n  \n  // Import the source maps into the new client\n  console.log('\\nImporting source maps into new client...')\n  // Serialize and deserialize to simulate real-world scenario (e.g., saving to file)\n  newClient.importSourceMaps(JSON.parse(JSON.stringify(exportedSourceMaps)))\n  console.log('Source maps imported successfully')\n  \n  // Try calling the error method again with source maps\n  console.log('\\nCalling error method with source maps...')\n  try {\n    await newClient.call({\n      method: 'error',\n      methodArgs: [],\n    })\n  } catch (e: any) {\n    console.log('\\nError caught (with source maps):')\n    console.log('Enhanced stack trace:')\n    console.log(e.stack)\n    console.log('\\nError details:')\n    console.log(`  Program Counter: ${e.led.pc}`)\n    console.log(`  Message: ${e.led.msg}`)\n    console.log(`  Transaction ID: ${e.led.txId}`)\n    console.log('\\nWith source maps, you can see exactly where the error occurred in your TEAL code!')\n  }\n  \n  console.log('\\n\u2705 Source map export and import demonstration complete')\n  console.log('\\nKey takeaways:')\n  console.log('- Export source maps after deployment to preserve debugging information')\n  console.log('- Import source maps into new client instances for enhanced error messages')\n  console.log('- Source maps show the exact TEAL code location where errors occur')\n  console.log('- This is especially useful when debugging production applications')\n}\n\nexportAndImportSourceMaps().catch(console.error)"
    },
    {
      "example_id": "110-fail-fast-deployment-strategy-with-onupdatefail",
      "title": "Fail-Fast Deployment Strategy with onUpdate=Fail",
      "summary": "Demonstrates using the onUpdate='fail' parameter to implement a fail-fast deployment strategy. When an existing app is detected, the deployment immediately stops with an error instead of updating or replacing the app.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Deploy an app, then attempt to deploy an update with onUpdate='fail', verifying that deployment stops with an error",
      "target_users": [
        "SDK developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "onUpdate='fail' parameter",
        "Deployment strategies",
        "Error handling"
      ],
      "feature_tags": [
        "app-deployment",
        "deployment-strategies",
        "error-handling",
        "fail-fast",
        "devops",
        "onUpdate-parameter"
      ],
      "folder": "110-fail-fast-deployment-strategy-with-onupdatefail",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundry/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundry/algokit-utils algosdk"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Initial deployment creates a new app successfully",
        "Second deployment attempt with onUpdate='fail' throws an error",
        "Error message: 'Update detected and onUpdate=Fail, stopping deployment'",
        "No transaction is sent for the second deployment",
        "Educational explanation of all onUpdate strategies and their use cases"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy failure for updated app fails if onupdate = Fail"
        }
      ],
      "artifacts_plan": [],
      "notes": "The onUpdate='fail' strategy is particularly useful in CI/CD pipelines where you want to prevent accidental updates to production apps. It provides a safety mechanism that requires explicit action to update existing apps. This example also provides comprehensive documentation of all available onUpdate strategies.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundry/algokit-utils'\nimport { consoleLogger } from '@algorandfoundry/algokit-utils/types/logging'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates the fail-fast deployment strategy using onUpdate='fail'.\n * \n * Key concepts:\n * - Deploy an initial version of an app\n * - Attempt to deploy again with onUpdate='fail'\n * - Deployment stops immediately when an existing app is detected\n * - Useful for strict CI/CD pipelines that should never update production apps\n */\n\nasync function failFastDeployment() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get a test account with funds from LocalNet\n  const sender = await algorand.account.localNet.dispenser()\n\n  console.log('=== Initial App Deployment ===')\n  \n  // Define app metadata\n  const metadata = {\n    name: 'MyProductionApp',\n    version: '1.0',\n    updatable: true,\n    deletable: false,\n  }\n\n  // Deploy the initial version\n  const deployment1 = {\n    sender: sender.addr,\n    metadata: metadata,\n    approvalProgram: await getApprovalProgram(1),\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n  }\n\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n\n  if ('transaction' in result1) {\n    console.log(`\u2713 Initial deployment successful`)\n    console.log(`  App ID: ${result1.appId}`)\n    console.log(`  Version: ${result1.version}`)\n    console.log(`  Transaction ID: ${result1.transaction.txID()}`)\n  }\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  console.log('\\n=== Attempting Deployment with onUpdate=\\'fail\\' ===')\n  console.log('This will fail because an app with the same name already exists.\\n')\n\n  // Attempt to deploy again with onUpdate='fail'\n  const deployment2 = {\n    sender: sender.addr,\n    metadata: metadata, // Same metadata as before\n    approvalProgram: await getApprovalProgram(2), // Different code\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    // Setting onUpdate='fail' means deployment will error if app exists\n    onUpdate: 'fail' as const,\n  }\n\n  try {\n    await algorand.appDeployer.deploy(deployment2)\n    \n    // We should never reach this line\n    console.log('\u274c ERROR: Deployment should have failed but succeeded!')\n  } catch (error: any) {\n    console.log('\u2713 Deployment failed as expected (onUpdate=\\'fail\\')')\n    console.log(`\\n=== Error Details ===')\n    console.log(`Error message: ${error.message}`)\n    \n    // Check the specific error message\n    if (error.message.includes('Update detected and onUpdate=Fail')) {\n      console.log('\\nThis error indicates that:')\n      console.log('  - An existing app with the same metadata was found')\n      console.log('  - The onUpdate parameter was set to \\'fail\\'')\n      console.log('  - The deployment was stopped before any transaction was sent')\n    }\n  }\n\n  console.log('\\n=== Understanding onUpdate Strategies ===')\n  console.log('\\nThe onUpdate parameter controls behavior when an existing app is detected:\\n')\n  console.log('  \u2022 onUpdate=\"fail\" (used here):')\n  console.log('    - Immediately stops deployment with an error')\n  console.log('    - No transactions are sent to the network')\n  console.log('    - Use in strict production environments')\n  console.log('    - Prevents accidental updates\\n')\n  console.log('  \u2022 onUpdate=\"update\":')\n  console.log('    - Updates the existing app with new code')\n  console.log('    - Requires updatable=true in original deployment')\n  console.log('    - Use for controlled app version upgrades\\n')\n  console.log('  \u2022 onUpdate=\"replace\":')\n  console.log('    - Deletes the old app and creates a new one')\n  console.log('    - Requires deletable=true in original deployment')\n  console.log('    - Use when app ID can change\\n')\n  console.log('  \u2022 onUpdate=\"append\":')\n  console.log('    - Creates a new app instance (doesn\\'t update existing)')\n  console.log('    - Use when you want multiple versions running\\n')\n\n  console.log('=== Use Cases for onUpdate=\"fail\" ===')\n  console.log('\\n1. Production deployment pipelines:')\n  console.log('   - Prevent accidental overwrites of production apps')\n  console.log('   - Require explicit manual intervention for updates\\n')\n  console.log('2. Immutable deployment requirements:')\n  console.log('   - Enforce that apps are never updated after initial deployment')\n  console.log('   - Audit compliance scenarios\\n')\n  console.log('3. Testing and validation:')\n  console.log('   - Ensure deployment scripts are idempotent')\n  console.log('   - Catch configuration errors before they reach production')\n}\n\n/**\n * Helper function to generate approval program\n */\nasync function getApprovalProgram(version: number): Promise<Uint8Array> {\n  const tealCode = `#pragma version 10\n  txn ApplicationID\n  int 0\n  ==\n  bnz create\n  \n  int 1\n  return\n  \n  create:\n  byte \"version\"\n  int ${version}\n  app_global_put\n  int 1\n  return`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n/**\n * Helper function to generate clear state program\n */\nasync function getClearProgram(): Promise<Uint8Array> {\n  const tealCode = `#pragma version 10\n  int 1`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n// Run the example\nfailFastDeployment().catch(console.error)"
    },
    {
      "example_id": "111-fail-fast-strategy-for-schema-breaks",
      "title": "Fail-Fast Strategy for Schema Breaks",
      "summary": "Demonstrates how to use the 'fail' strategy for onSchemaBreak to prevent accidental schema changes. This is useful for production deployments where you want to be explicitly warned about schema changes before they happen.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "error handling",
      "specific_use_case": "Deploy an app, then attempt to deploy with a schema break and onSchemaBreak='fail', verifying deployment stops with an error",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "onSchemaBreak parameter",
        "schema break detection"
      ],
      "feature_tags": [
        "app-deployment",
        "schema-breaks",
        "error-handling",
        "fail-fast",
        "production-safety"
      ],
      "folder": "111-fail-fast-strategy-for-schema-breaks",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial app deployment succeeds",
        "Attempted deployment with schema break fails immediately",
        "Error message explains schema break detected and suggests using 'replace' if intentional",
        "Original app remains unchanged"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy failure for replacement of schema broken app fails if onSchemaBreak = Fail"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL approval program"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL clear state program"
        }
      ],
      "notes": "This example shows the fail-fast approach to schema changes, which is recommended for production environments to prevent accidental destructive changes.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils/types/config'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates the fail-fast strategy for schema breaks.\n * \n * When onSchemaBreak='fail', the deployment will immediately stop if a schema\n * break is detected, preventing accidental destructive changes in production.\n * \n * This is the safest option for production deployments where schema changes\n * should be intentional and carefully planned.\n */\n\nasync function main() {\n  // Configure AlgoKit\n  Config.configure({ debug: true })\n\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Using account:', account.addr)\n\n  // Define simple TEAL programs\n  const approvalProgram = `#pragma version 8\n// Simple approval program\nint 1\nreturn`\n\n  const clearProgram = `#pragma version 8\n// Simple clear state program  \nint 1\nreturn`\n\n  // Step 1: Deploy initial version of the app\n  console.log('\\n--- Step 1: Deploying initial app version ---')\n  \n  const metadata = {\n    name: 'MyApp',\n    version: '1.0',\n    deletable: true,\n    updatable: true,\n  }\n\n  const deployment1 = {\n    sender: account,\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearProgram,\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 1,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: metadata,\n  }\n\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  console.log('\u2705 App deployed successfully')\n  console.log('   App ID:', result1.appId)\n  console.log('   App Address:', result1.appAddress)\n  console.log('   Schema: globalUints=1, globalByteSlices=1')\n  console.log('   Version:', result1.version)\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  // Step 2: Attempt to deploy with schema-breaking change and onSchemaBreak='fail'\n  console.log('\\n--- Step 2: Attempting deployment with schema break ---')\n  console.log('   New schema: globalUints=2, globalByteSlices=1 (breaking change!)')\n  console.log('   Strategy: onSchemaBreak=\"fail\"')\n  \n  const deployment2 = {\n    sender: account,\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearProgram,\n    schema: {\n      globalUints: 2,  // Schema break: changed from 1 to 2\n      globalByteSlices: 1,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: metadata,\n    onSchemaBreak: 'fail',  // Fail immediately on schema break\n  }\n\n  try {\n    await algorand.appDeployer.deploy(deployment2)\n    console.log('\u274c This should not happen - deployment should have failed!')\n  } catch (error: any) {\n    console.log('\\n\u274c Deployment failed as expected!')\n    console.log('\\n\ud83d\udccb Error Details:')\n    console.log('   ', error.message)\n    \n    console.log('\\n\ud83d\udca1 What happened:')\n    console.log('   1. Deployer detected the schema change (globalUints: 1 -> 2)')\n    console.log('   2. onSchemaBreak was set to \"fail\"')\n    console.log('   3. Deployment was stopped immediately before any changes')\n    console.log('   4. Original app remains unchanged')\n    \n    console.log('\\n\u2705 Use Cases for onSchemaBreak=\"fail\":')\n    console.log('   - Production deployments where changes should be explicit')\n    console.log('   - CI/CD pipelines that should halt on unexpected changes')\n    console.log('   - Safety mechanism to prevent accidental schema modifications')\n    \n    console.log('\\n\ud83d\udd04 Alternatives:')\n    console.log('   - onSchemaBreak=\"replace\": Delete and recreate the app (data loss!)')\n    console.log('   - onSchemaBreak=\"append\": Only allow adding storage (safer)')\n  }\n\n  // Verify the original app is unchanged\n  console.log('\\n--- Verification ---')\n  const appInfo = await algorand.client.algod.getApplicationByID(result1.appId).do()\n  console.log('\u2705 Original app is unchanged')\n  console.log('   App ID:', result1.appId)\n  console.log('   Global State Schema:')\n  console.log('     - Uints:', appInfo.params['global-state-schema'].uints)\n  console.log('     - ByteSlices:', appInfo.params['global-state-schema']['byte-slices'])\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "112-handle-errors-when-replacing-permanent-apps",
      "title": "Handle Errors When Replacing Permanent Apps",
      "summary": "Demonstrates proper error handling when attempting to replace a permanent (non-deletable) app. Shows how to detect and handle logic errors that occur when trying to delete an app that cannot be deleted.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Deploy a permanent (non-deletable) app and attempt to replace it, verifying the deletion fails with a logic error",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "LogicError.parseLogicError",
        "error handling",
        "app permanence"
      ],
      "feature_tags": [
        "error-handling",
        "permanent-apps",
        "logic-errors",
        "deployment-strategies",
        "app-lifecycle"
      ],
      "folder": "112-handle-errors-when-replacing-permanent-apps",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded account for deployment"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Permanent app deployed successfully",
        "Attempt to replace the app fails with an error",
        "Logic error is caught and parsed",
        "Detailed explanation of why the error occurred",
        "Suggestions for alternative approaches",
        "Confirmation that the original app remains unchanged"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy failure for replacement of permanent, updated app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package.json with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Explanation of permanent apps and error handling best practices"
        }
      ],
      "notes": "This example is important for teaching developers about the implications of the deletable flag and proper error handling when deployment strategies fail. It demonstrates defensive programming and helps developers understand app lifecycle constraints.",
      "generated_code": "import { AlgorandClient, LogicError } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates what happens when you try to replace a permanent app.\n * \n * When an app is deployed with deletable: false, it becomes permanent and cannot\n * be deleted. Attempting to use the 'replace' strategy on such an app will fail\n * with a logic error.\n * \n * This example shows:\n * 1. How to deploy a permanent app\n * 2. What happens when you try to replace it\n * 3. How to properly handle and parse the resulting logic error\n * 4. The importance of the deletable flag in app metadata\n */\n\nasync function main() {\n  // Initialize AlgorandClient for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  \n  console.log('=== Deploying Permanent App (deletable: false) ===')\n  console.log(`Using account: ${account.addr}\\n`)\n  \n  // Define approval and clear programs\n  const approvalProgram = `#pragma version 10\n  // Approval program for permanent app\n  int 1\n  return`\n  \n  const clearProgram = `#pragma version 10\n  // Clear state program\n  int 1\n  return`\n  \n  // Compile the programs\n  const approval = await algorand.client.algod.compile(approvalProgram).do()\n  const clear = await algorand.client.algod.compile(clearProgram).do()\n  \n  // Deploy the permanent app\n  // IMPORTANT: deletable is set to false, making this app permanent\n  const deployment1 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approval.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: {\n      name: 'PermanentApp',\n      version: '1.0',\n      deletable: false,  // This makes the app permanent!\n      updatable: true,   // Still updatable, but not deletable\n    },\n  }\n  \n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  \n  console.log(`\u2705 Permanent app deployed successfully!`)\n  console.log(`   App ID: ${result1.appId}`)\n  console.log(`   Version: ${result1.version}`)\n  console.log(`   Deletable: ${result1.deletable} \u26a0\ufe0f`)\n  console.log(`   Updatable: ${result1.updatable}\\n`)\n  \n  // Wait a moment for the transaction to be processed\n  await new Promise(resolve => setTimeout(resolve, 1000))\n  \n  console.log('=== Attempting to Replace Permanent App (v2.0) ===')\n  console.log('\u26a0\ufe0f  This should fail because the app is not deletable...\\n')\n  \n  // Define updated approval program for v2.0\n  const approvalProgramV2 = `#pragma version 10\n  // Updated approval program v2.0\n  int 2\n  return`\n  \n  const approvalV2 = await algorand.client.algod.compile(approvalProgramV2).do()\n  \n  // Attempt to deploy with replace strategy\n  const deployment2 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approvalV2.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: {\n      name: 'PermanentApp',\n      version: '2.0',\n      deletable: false,\n      updatable: true,\n    },\n    onUpdate: 'replace',  // This will attempt to delete and recreate\n  }\n  \n  try {\n    // This should fail!\n    await algorand.appDeployer.deploy(deployment2)\n    console.log('\u274c Unexpected: Deployment succeeded (this should not happen!)')\n  } catch (error: any) {\n    // Expected error path\n    console.log('\u2705 Expected error occurred!\\n')\n    console.log('=== Error Details ===')\n    console.log(`Error message: ${error.message}\\n`)\n    \n    // Parse the logic error for more details\n    const logicError = LogicError.parseLogicError(error)\n    \n    if (logicError) {\n      console.log('=== Parsed Logic Error ===')\n      console.log(`Transaction ID: ${logicError.txId}`)\n      console.log(`Program: ${logicError.program}`)\n      console.log(`Line: ${logicError.line}`)\n      console.log(`Message: ${logicError.message}\\n`)\n    }\n    \n    console.log('=== Why Did This Fail? ===')\n    console.log('The app was deployed with deletable: false, making it permanent.')\n    console.log('When you try to use the \"replace\" strategy, it attempts to:')\n    console.log('  1. Delete the old app')\n    console.log('  2. Create a new app')\n    console.log('')\n    console.log('Step 1 fails because the app\\'s approval program does not allow deletion.')\n    console.log('This is by design - permanent apps cannot be deleted!\\n')\n    \n    console.log('=== What Should You Do Instead? ===')\n    console.log('For permanent apps, you have these options:')\n    console.log('  1. Use onUpdate: \"update\" to update the existing app in place')\n    console.log('  2. Deploy a completely new app with a different name')\n    console.log('  3. Design the app to be deletable from the start if replacement is needed\\n')\n  }\n  \n  console.log('=== Verification ===')\n  console.log(`Original app (${result1.appId}) is still alive and unchanged.`)\n  console.log('You can verify this by querying the app from the blockchain.\\n')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "113-handle-failed-update-of-immutable-application",
      "title": "Handle Failed Update of Immutable Application",
      "summary": "Demonstrates what happens when attempting to update an immutable app. Shows how to properly handle the logic error that occurs when trying to update an app that was deployed with updatable=false.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Deploy an immutable app and attempt to update it, verifying that the update fails with a logic error",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "LogicError.parseLogicError",
        "Immutable app behavior",
        "Error handling"
      ],
      "feature_tags": [
        "app-deployment",
        "error-handling",
        "immutable-apps",
        "logic-errors",
        "app-security"
      ],
      "folder": "113-handle-failed-update-of-immutable-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundry/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundry/algokit-utils algosdk"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Initial deployment creates an immutable app with updatable=false",
        "Update attempt fails with 'logic eval error: assert failed'",
        "Logic error is caught and parsed successfully",
        "Error details show the transaction ID and failure reason",
        "Educational summary about immutability and best practices"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy update to immutable updated app fails"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates proper error handling when working with immutable apps. The LogicError.parseLogicError utility helps extract meaningful information from on-chain errors. This is essential for building robust deployment scripts.",
      "generated_code": "import { AlgorandClient, LogicError } from '@algorandfoundry/algokit-utils'\nimport { consoleLogger } from '@algorandfoundry/algokit-utils/types/logging'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates what happens when you try to update an immutable application.\n * \n * Key concepts:\n * - Deploy an app with updatable=false (immutable)\n * - Attempt to update the immutable app\n * - Catch and parse the resulting logic error\n * - Understand app immutability for security\n */\n\nasync function handleImmutableAppUpdate() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get a test account with funds from LocalNet\n  const sender = await algorand.account.localNet.dispenser()\n\n  console.log('=== Deploying Immutable App ===')\n  \n  // Define app metadata with updatable flag set to FALSE\n  const metadata = {\n    name: 'MyImmutableApp',\n    version: '1.0',\n    updatable: false, // This makes the app immutable\n    deletable: false,\n  }\n\n  // Deploy the initial immutable version\n  const deployment1 = {\n    sender: sender.addr,\n    metadata: metadata,\n    approvalProgram: await getApprovalProgram(1),\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n  }\n\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n\n  if ('transaction' in result1) {\n    console.log(`\u2713 Immutable app deployed successfully`)\n    console.log(`  App ID: ${result1.appId}`)\n    console.log(`  Version: ${result1.version}`)\n    console.log(`  Updatable: ${result1.updatable}`)\n    console.log(`  Transaction ID: ${result1.transaction.txID()}`)\n  }\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  console.log('\\n=== Attempting to Update Immutable App ===')\n\n  // Attempt to deploy an update (this will fail)\n  const deployment2 = {\n    sender: sender.addr,\n    metadata: {\n      ...metadata,\n      version: '2.0',\n    },\n    approvalProgram: await getApprovalProgram(2), // Different code\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    onUpdate: 'update' as const,\n  }\n\n  try {\n    // This will throw an error because the app is immutable\n    await algorand.appDeployer.deploy(deployment2)\n    \n    // We should never reach this line\n    console.log('\u274c ERROR: Update should have failed but succeeded!')\n  } catch (error: any) {\n    console.log('\u2713 Update failed as expected (app is immutable)')\n    console.log(`\\n=== Error Details ===')\n    console.log(`Error message: ${error.message}`)\n    \n    // Check if it's a logic error\n    if (error.message.includes('logic eval error') || error.message.includes('assert failed')) {\n      console.log('\\nThis is a logic error - the app contract rejected the update.')\n      \n      // Parse the logic error for more details\n      const logicError = LogicError.parseLogicError(error)\n      \n      if (logicError) {\n        console.log('\\n=== Parsed Logic Error ===')\n        console.log(`Transaction ID: ${logicError.txId}`)\n        console.log(`Message: ${logicError.message}`)\n        if (logicError.program) {\n          console.log(`Failed in: ${logicError.program}`)\n        }\n        if (logicError.line) {\n          console.log(`Line: ${logicError.line}`)\n        }\n      }\n    }\n  }\n\n  console.log('\\n=== Summary ===')\n  console.log('Immutable apps cannot be updated once deployed.')\n  console.log('This is a security feature to ensure app logic cannot be changed.')\n  console.log('When deploying apps, carefully consider whether they should be updatable.')\n  console.log('\\nBest practices:')\n  console.log('  - Use updatable=false for production apps that should never change')\n  console.log('  - Use updatable=true during development or for apps that need upgrades')\n  console.log('  - Always handle update errors gracefully in your deployment scripts')\n}\n\n/**\n * Helper function to generate approval program\n * The program includes logic to prevent updates when updatable=false\n */\nasync function getApprovalProgram(version: number): Promise<Uint8Array> {\n  const tealCode = `#pragma version 10\n  txn ApplicationID\n  int 0\n  ==\n  bnz create\n  \n  txn OnCompletion\n  int UpdateApplication\n  ==\n  bnz update\n  \n  int 1\n  return\n  \n  create:\n  byte \"version\"\n  int ${version}\n  app_global_put\n  int 1\n  return\n  \n  update:\n  // For immutable apps, this will fail\n  // In real deployment templates, this checks the updatable flag\n  int 0\n  assert\n  int 1\n  return`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n/**\n * Helper function to generate clear state program\n */\nasync function getClearProgram(): Promise<Uint8Array> {\n  const tealCode = `#pragma version 10\n  int 1`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n// Run the example\nhandleImmutableAppUpdate().catch(console.error)"
    },
    {
      "example_id": "114-handle-schema-breaking-changes-with-extra-pages",
      "title": "Handle Schema Breaking Changes with Extra Pages",
      "summary": "Demonstrates how the SDK detects breaking changes (like extra program pages) and handles them according to configured strategy using OnSchemaBreak options.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Handle schema breaking changes when extra program pages are needed",
      "target_users": [
        "SDK developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "factory.deploy",
        "OnSchemaBreak.Fail",
        "OnSchemaBreak.AppendApp",
        "extra pages detection",
        "OnUpdate.UpdateApp"
      ],
      "feature_tags": [
        "schema-break-detection",
        "extra-pages",
        "deployment-strategies",
        "error-handling",
        "app-factory",
        "breaking-changes"
      ],
      "folder": "114-handle-schema-breaking-changes-with-extra-pages",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Small app deployed successfully",
        "Update with OnSchemaBreak.Fail throws error about schema break",
        "Update with OnSchemaBreak.AppendApp creates new app",
        "Different app IDs for original and new app",
        "Clear explanation of schema break handling strategies"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - update detects extra pages as breaking change"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "artifacts/small-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC-56 app spec for a small application that fits in one page"
        },
        {
          "target_file": "artifacts/large-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC-56 app spec for a large application that requires extra pages"
        }
      ],
      "notes": "This example requires two different app specs: a small one that fits in one page and a larger one that requires extra pages. The SDK automatically detects when extra pages would be needed and treats this as a breaking change. OnSchemaBreak.Fail prevents the deployment, while OnSchemaBreak.AppendApp creates a new app instance. OnSchemaBreak.ReplaceApp would delete and recreate at the same app ID (if using name-based deployment).",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport { AlgorandClient, OnSchemaBreak, OnUpdate } from '@algorandfoundation/algokit-utils'\nimport smallAppArc56Json from './artifacts/small-app.arc56.json'\nimport largeAppArc56Json from './artifacts/large-app.arc56.json'\n\n/**\n * This example demonstrates how to handle schema breaking changes,\n * specifically when extra program pages are needed.\n * \n * Key concepts:\n * - Detecting schema breaks (extra pages requirement)\n * - Using OnSchemaBreak.Fail to prevent breaking updates\n * - Using OnSchemaBreak.AppendApp to create a new app when schema breaks\n * - Understanding deployment strategies for breaking changes\n */\n\nasync function handleSchemaBreakExample() {\n  // Setup: Initialize Algorand client and test account\n  const localnet = await algorandFixture()\n  const algorand = localnet.algorand\n\n  console.log('Step 1: Deploy small application (no extra pages)')\n  // Create factory with small app spec\n  let appFactory = algorand.client.getAppFactory({\n    appSpec: smallAppArc56Json,\n    defaultSender: localnet.context.testAccount.addr,\n  })\n\n  const { result: appCreateResult } = await appFactory.deploy({\n    updatable: true, // Allow updates\n  })\n\n  console.log(`Small app created with ID: ${appCreateResult.appId}`)\n  console.log(`Operation performed: ${appCreateResult.operationPerformed}`) // 'create'\n  console.log(`App address: ${appCreateResult.appAddress}`)\n\n  console.log('\\nStep 2: Attempt to update to larger app (requires extra pages)')\n  // Update factory to use large app spec that requires more pages\n  appFactory = algorand.client.getAppFactory({\n    appSpec: largeAppArc56Json, // This app needs extra pages\n    defaultSender: localnet.context.testAccount.addr,\n  })\n\n  console.log('\\nAttempt 1: Using OnSchemaBreak.Fail (will fail)')\n  try {\n    await appFactory.deploy({\n      updatable: true,\n      onSchemaBreak: OnSchemaBreak.Fail, // Fail if schema breaks\n      onUpdate: OnUpdate.UpdateApp,\n    })\n    console.log('\u274c Unexpected: Update should have failed')\n  } catch (error) {\n    console.log('\u2713 Expected error caught:')\n    console.log(`  ${error instanceof Error ? error.message : error}`)\n    console.log('\\n  Schema break detected! Extra pages would break the schema.')\n    console.log('  The deployment was stopped to prevent breaking changes.')\n  }\n\n  console.log('\\nAttempt 2: Using OnSchemaBreak.AppendApp (will create new app)')\n  // This time, allow creating a new app when schema breaks\n  const { result: appAppendResult } = await appFactory.deploy({\n    updatable: true,\n    onSchemaBreak: OnSchemaBreak.AppendApp, // Create new app if schema breaks\n    onUpdate: OnUpdate.UpdateApp,\n  })\n\n  console.log(`\\n\u2713 New app created successfully!`)\n  console.log(`Operation performed: ${appAppendResult.operationPerformed}`) // 'create'\n  console.log(`New app ID: ${appAppendResult.appId}`)\n  console.log(`Original app ID: ${appCreateResult.appId}`)\n  console.log(`App IDs are different: ${appCreateResult.appId !== appAppendResult.appId}`)\n  \n  console.log('\\nSummary:')\n  console.log('- OnSchemaBreak.Fail: Prevents deployment when schema breaks detected')\n  console.log('- OnSchemaBreak.AppendApp: Creates a new app when schema breaks')\n  console.log('- Extra pages are detected as a breaking change')\n  console.log('- This protects your app from incompatible updates')\n}\n\n// Run the example\nhandleSchemaBreakExample().catch(console.error)"
    },
    {
      "example_id": "115-handling-app-updates-with-append-strategy",
      "title": "Handling App Updates with Append Strategy",
      "summary": "Demonstrates how to handle schema breaks and code updates by creating a new app alongside the existing one using the 'append' strategy, useful for blue-green deployments and gradual migrations.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an app, then handle schema breaks or version updates by creating a new app with onSchemaBreak='append' or onUpdate='append' to maintain multiple versions",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "onSchemaBreak parameter",
        "onUpdate parameter",
        "multi-app version management"
      ],
      "feature_tags": [
        "app-deployment",
        "schema-management",
        "version-management",
        "blue-green-deployment",
        "multi-app-management",
        "migration-strategies"
      ],
      "folder": "115-handling-app-updates-with-append-strategy",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Shows initial app deployment with app ID",
        "Shows schema break deployment creating a new app with different ID",
        "Shows version update deployment creating another new app",
        "Demonstrates that old apps remain active alongside new ones"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy append for schema broken app if onSchemaBreak = AppendApp"
        },
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy append for update app if onUpdate = AppendApp"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example combines two related test cases that demonstrate the append strategy for different scenarios. The append strategy is a powerful deployment pattern for managing multiple app versions and performing zero-downtime deployments.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to use the 'append' strategy when deploying apps.\n * The append strategy creates a new app instead of updating or replacing the existing one,\n * which is useful for:\n * - Blue-green deployments\n * - Gradual migrations\n * - Maintaining multiple app versions simultaneously\n * - Handling schema breaks without deleting the old app\n */\n\nasync function demonstrateAppendStrategies() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const sender = algorand.account.localNetDispenser()\n\n  console.log('=== App Deployment with Append Strategies ===')\n  console.log()\n\n  // ===== Example 1: Handling Schema Breaks with Append =====\n  console.log('Example 1: Schema Break with onSchemaBreak=append')\n  console.log('---------------------------------------------------')\n\n  // Initial app deployment\n  const metadata1 = {\n    name: 'MyApp',\n    version: '1.0',\n    updatable: true,\n    deletable: true,\n  }\n\n  const deployment1 = {\n    sender,\n    metadata: metadata1,\n    deployTimeParams: {},\n    schema: {\n      globalInts: 1,\n      globalBytes: 0,\n      localInts: 0,\n      localBytes: 0,\n    },\n    approvalProgram: `#pragma version 8\nint 1\nreturn`,\n    clearStateProgram: `#pragma version 8\nint 1\nreturn`,\n  }\n\n  console.log('Deploying initial app with schema: globalInts=1, globalBytes=0')\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  console.log(`\u2713 Created app with ID: ${result1.appId}`)\n  console.log(`  Operation: ${result1.operationPerformed}`)\n  console.log(`  Version: ${result1.version}`)\n  console.log()\n\n  // Deploy with schema break using 'append' strategy\n  // This will create a NEW app instead of replacing the old one\n  const deployment2 = {\n    sender,\n    metadata: metadata1, // Same metadata\n    onSchemaBreak: 'append' as const, // Key: Use append strategy\n    deployTimeParams: {},\n    schema: {\n      globalInts: 2, // BREAKING CHANGE: Different schema\n      globalBytes: 1,\n      localInts: 0,\n      localBytes: 0,\n    },\n    approvalProgram: `#pragma version 8\nint 1\nreturn`,\n    clearStateProgram: `#pragma version 8\nint 1\nreturn`,\n  }\n\n  console.log('Deploying with schema break (globalInts=2, globalBytes=1) and onSchemaBreak=append')\n  const result2 = await algorand.appDeployer.deploy(deployment2)\n  console.log(`\u2713 Created NEW app with ID: ${result2.appId}`)\n  console.log(`  Operation: ${result2.operationPerformed}`)\n  console.log(`  Old app ID: ${result1.appId} (still exists)`)\n  console.log(`  New app ID: ${result2.appId}`)\n  console.log(`  Both apps are now running simultaneously!`)\n  console.log()\n\n  // ===== Example 2: Version Updates with Append =====\n  console.log('Example 2: Version Update with onUpdate=append')\n  console.log('-----------------------------------------------')\n\n  // Initial app deployment with version 1.0\n  const metadata3 = {\n    name: 'MyVersionedApp',\n    version: '1.0',\n    updatable: true,\n    deletable: true,\n  }\n\n  const deployment3 = {\n    sender,\n    metadata: metadata3,\n    deployTimeParams: { VALUE: 1 },\n    schema: {\n      globalInts: 1,\n      globalBytes: 0,\n      localInts: 0,\n      localBytes: 0,\n    },\n    approvalProgram: `#pragma version 8\nint TMPL_VALUE\nreturn`,\n    clearStateProgram: `#pragma version 8\nint 1\nreturn`,\n  }\n\n  console.log('Deploying app version 1.0 with VALUE=1')\n  const result3 = await algorand.appDeployer.deploy(deployment3)\n  console.log(`\u2713 Created app with ID: ${result3.appId}`)\n  console.log(`  Version: ${result3.version}`)\n  console.log()\n\n  // Deploy version 2.0 with 'append' strategy\n  // This creates a new app instead of updating the existing one\n  const metadata4 = {\n    name: 'MyVersionedApp',\n    version: '2.0', // New version\n    updatable: true,\n    deletable: true,\n  }\n\n  const deployment4 = {\n    sender,\n    metadata: metadata4,\n    onUpdate: 'append' as const, // Key: Use append strategy for updates\n    deployTimeParams: { VALUE: 3 }, // Different template value\n    schema: {\n      globalInts: 1,\n      globalBytes: 0,\n      localInts: 0,\n      localBytes: 0,\n    },\n    approvalProgram: `#pragma version 8\nint TMPL_VALUE\nreturn`,\n    clearStateProgram: `#pragma version 8\nint 1\nreturn`,\n  }\n\n  console.log('Deploying version 2.0 with VALUE=3 and onUpdate=append')\n  const result4 = await algorand.appDeployer.deploy(deployment4)\n  console.log(`\u2713 Created NEW app with ID: ${result4.appId}`)\n  console.log(`  Operation: ${result4.operationPerformed}`)\n  console.log(`  Version 1.0 app ID: ${result3.appId} (still running)`)\n  console.log(`  Version 2.0 app ID: ${result4.appId} (newly created)`)\n  console.log()\n\n  console.log('=== Summary ===')\n  console.log('The append strategy allows you to:')\n  console.log('1. Keep old apps running while deploying new versions')\n  console.log('2. Perform gradual migrations by routing traffic between versions')\n  console.log('3. Rollback quickly by switching back to the old app')\n  console.log('4. Test new versions in production without replacing the old version')\n}\n\n// Run the example\ndemonstrateAppendStrategies().catch(console.error)"
    },
    {
      "example_id": "116-handling-schema-breaks-on-permanent-apps",
      "title": "Handling Schema Breaks on Permanent Apps",
      "summary": "Demonstrates how attempting to replace a permanent (non-deletable) app with a schema-breaking change fails, helping developers understand the importance of planning schema design upfront for permanent applications.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Deploy a permanent app with a schema-breaking change and onSchemaBreak='replace', verifying deletion fails",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "LogicError.parseLogicError",
        "schema break detection",
        "permanent app constraints"
      ],
      "feature_tags": [
        "app-deployment",
        "schema-breaks",
        "error-handling",
        "permanent-apps",
        "logic-errors"
      ],
      "folder": "116-handling-schema-breaks-on-permanent-apps",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial deployment of permanent app succeeds",
        "Attempted schema-breaking replacement fails with 'logic eval error: assert failed'",
        "LogicError is parsed and displayed",
        "Error message confirms permanent apps cannot be deleted for schema replacement"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy replacement to schema broken, permanent app fails"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL approval program with global state"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL clear state program"
        }
      ],
      "notes": "This example is crucial for understanding permanent app limitations. Once an app is deployed as permanent (deletable: false), it cannot be replaced even with onSchemaBreak='replace'. Developers must design their schema correctly from the start.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils/types/config'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates what happens when you try to replace a permanent app\n * (deletable: false) with a schema-breaking change.\n *\n * Key Learning: Permanent apps cannot be deleted and replaced, even with onSchemaBreak='replace'.\n * You must design your schema correctly from the start for permanent applications.\n */\n\nasync function main() {\n  // Configure AlgoKit\n  Config.configure({ debug: true })\n\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Using account:', account.addr)\n\n  // Define simple TEAL programs\n  const approvalProgram = `#pragma version 8\n// Simple approval program with global state\nint 1\nreturn`\n\n  const clearProgram = `#pragma version 8\n// Simple clear state program\nint 1\nreturn`\n\n  // Step 1: Deploy a permanent app (deletable: false)\n  console.log('\\n--- Step 1: Deploying permanent app ---')\n  \n  const metadata = {\n    name: 'PermanentApp',\n    version: '1.0',\n    deletable: false,  // This makes the app permanent\n    updatable: true,\n  }\n\n  const deployment1 = {\n    sender: account,\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearProgram,\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: metadata,\n  }\n\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  console.log('\u2705 Permanent app deployed successfully')\n  console.log('   App ID:', result1.appId)\n  console.log('   App Address:', result1.appAddress)\n  console.log('   Created Round:', result1.createdRound)\n  console.log('   Deletable:', result1.deletable)\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  // Step 2: Attempt to deploy with schema-breaking change and onSchemaBreak='replace'\n  console.log('\\n--- Step 2: Attempting schema-breaking replacement ---')\n  console.log('   Breaking schema by changing globalUints: 1 -> 2')\n  console.log('   Using onSchemaBreak: \"replace\"')\n  \n  const deployment2 = {\n    sender: account,\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearProgram,\n    schema: {\n      globalUints: 2,  // Schema break: increased from 1 to 2\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: {\n      ...metadata,\n      version: '2.0',\n    },\n    onSchemaBreak: 'replace',  // Try to replace the app\n  }\n\n  try {\n    await algorand.appDeployer.deploy(deployment2)\n    console.log('\u274c This should not happen - deployment should have failed!')\n  } catch (error: any) {\n    console.log('\\n\u274c Deployment failed as expected!')\n    console.log('   Error:', error.message)\n    \n    // Parse the logic error for more details\n    if (error.message.includes('logic eval error')) {\n      console.log('\\n\ud83d\udccb Analysis:')\n      console.log('   - The app is marked as permanent (deletable: false)')\n      console.log('   - Schema breaks require deleting and recreating the app')\n      console.log('   - Permanent apps cannot be deleted')\n      console.log('   - Therefore, schema-breaking changes are not possible')\n      console.log('\\n\ud83d\udca1 Key Takeaway:')\n      console.log('   Design your schema carefully for permanent apps!')\n      console.log('   Once deployed as permanent, the schema cannot be changed.')\n    }\n  }\n\n  // Verify the original app still exists\n  console.log('\\n--- Verification ---')\n  const appInfo = await algorand.client.algod.getApplicationByID(result1.appId).do()\n  console.log('\u2705 Original permanent app still exists')\n  console.log('   App ID:', result1.appId)\n  console.log('   Global State Schema - Uints:', appInfo.params['global-state-schema'].uints)\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "117-idempotent-app-deployment",
      "title": "Idempotent App Deployment",
      "summary": "Demonstrates the idempotent nature of the app deployer - deploying the same app twice with identical parameters results in no operation on the second deployment, avoiding unnecessary transactions and costs.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an app twice with identical parameters and verify the second deployment performs no operation",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Infrastructure engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "idempotent deployment",
        "deployment optimization"
      ],
      "feature_tags": [
        "app-deployment",
        "idempotency",
        "optimization",
        "ci-cd",
        "deployment-best-practices"
      ],
      "folder": "117-idempotent-app-deployment",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "First deployment creates a new app with transaction details",
        "Second deployment detects no changes and returns existing app details",
        "No transaction is created on the second deployment",
        "Both deployments return the same app ID and metadata",
        "Console output clearly shows the optimization"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Do nothing if deploying app with no changes"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "approval.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL approval program"
        },
        {
          "target_file": "clear.teal",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple TEAL clear state program"
        }
      ],
      "notes": "This example is particularly valuable for CI/CD pipelines where deployments may run multiple times. The idempotent behavior ensures efficiency and cost savings.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { Config } from '@algorandfoundation/algokit-utils/types/config'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates the idempotent nature of the app deployer.\n * \n * When you deploy an app with identical parameters multiple times, the deployer\n * intelligently detects that nothing has changed and skips the deployment,\n * avoiding unnecessary transactions and costs.\n * \n * This is especially useful for:\n * - CI/CD pipelines that may run multiple times\n * - Development workflows with frequent deployments\n * - Infrastructure-as-code scenarios where you want declarative deployments\n */\n\nasync function main() {\n  // Configure AlgoKit\n  Config.configure({ debug: true })\n\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  console.log('Using account:', account.addr)\n  console.log('Initial balance:', algosdk.microalgosToAlgos(await algorand.client.algod.accountInformation(account.addr).do().then(info => info.amount)), 'ALGO')\n\n  // Define simple TEAL programs\n  const approvalProgram = `#pragma version 8\n// Simple approval program\nint 1\nreturn`\n\n  const clearProgram = `#pragma version 8\n// Simple clear state program\nint 1\nreturn`\n\n  // Define deployment parameters\n  const metadata = {\n    name: 'IdempotentApp',\n    version: '1.0.0',\n    deletable: true,\n    updatable: true,\n  }\n\n  const deploymentParams = {\n    sender: account,\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearProgram,\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 1,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    metadata: metadata,\n  }\n\n  // Step 1: Initial deployment\n  console.log('\\n=== FIRST DEPLOYMENT ===')\n  console.log('Deploying app with:')\n  console.log('  - Name:', metadata.name)\n  console.log('  - Version:', metadata.version)\n  console.log('  - Schema: globalUints=1, globalByteSlices=1')\n  \n  const initialDeployment = await algorand.appDeployer.deploy(deploymentParams)\n  \n  console.log('\\n\u2705 Initial deployment completed')\n  console.log('   Transaction created:', 'transaction' in initialDeployment ? 'Yes' : 'No')\n  if ('transaction' in initialDeployment) {\n    console.log('   Transaction ID:', initialDeployment.transaction.txID())\n  }\n  console.log('   App ID:', initialDeployment.appId)\n  console.log('   App Address:', initialDeployment.appAddress)\n  console.log('   Created Round:', initialDeployment.createdRound)\n  console.log('   Updated Round:', initialDeployment.updatedRound)\n  console.log('   Version:', initialDeployment.version)\n  console.log('   Deletable:', initialDeployment.deletable)\n  console.log('   Updatable:', initialDeployment.updatable)\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  // Get balance after first deployment\n  const balanceAfterFirst = algosdk.microalgosToAlgos(\n    await algorand.client.algod.accountInformation(account.addr).do().then(info => info.amount)\n  )\n  console.log('\\n   Balance after first deployment:', balanceAfterFirst, 'ALGO')\n\n  // Step 2: Second deployment with identical parameters\n  console.log('\\n=== SECOND DEPLOYMENT (IDENTICAL PARAMETERS) ===')\n  console.log('Deploying the exact same app again...')\n  \n  const secondDeployment = await algorand.appDeployer.deploy(deploymentParams)\n  \n  console.log('\\n\u2705 Second deployment completed')\n  console.log('   Transaction created:', 'transaction' in secondDeployment ? 'Yes' : 'No')\n  console.log('   App ID:', secondDeployment.appId)\n  console.log('   App Address:', secondDeployment.appAddress)\n  console.log('   Created Round:', secondDeployment.createdRound)\n  console.log('   Updated Round:', secondDeployment.updatedRound)\n  console.log('   Version:', secondDeployment.version)\n  console.log('   Deletable:', secondDeployment.deletable)\n  console.log('   Updatable:', secondDeployment.updatable)\n\n  // Get balance after second deployment\n  const balanceAfterSecond = algosdk.microalgosToAlgos(\n    await algorand.client.algod.accountInformation(account.addr).do().then(info => info.amount)\n  )\n  console.log('\\n   Balance after second deployment:', balanceAfterSecond, 'ALGO')\n\n  // Step 3: Analysis\n  console.log('\\n=== IDEMPOTENCY ANALYSIS ===')\n  \n  const hasTransaction = 'transaction' in secondDeployment\n  console.log('\\n\ud83d\udcca Comparison:')\n  console.log('   Same App ID:', initialDeployment.appId === secondDeployment.appId ? '\u2705' : '\u274c')\n  console.log('   Same App Address:', initialDeployment.appAddress === secondDeployment.appAddress ? '\u2705' : '\u274c')\n  console.log('   Same Version:', initialDeployment.version === secondDeployment.version ? '\u2705' : '\u274c')\n  console.log('   Created Round:', initialDeployment.createdRound === secondDeployment.createdRound ? '\u2705 Same' : '\u274c Different')\n  console.log('   Updated Round:', initialDeployment.updatedRound === secondDeployment.updatedRound ? '\u2705 Same (no update)' : '\u274c Different')\n  console.log('   Transaction Created:', hasTransaction ? '\u274c Yes (unexpected)' : '\u2705 No (optimized!)')\n  console.log('   Balance Changed:', balanceAfterFirst === balanceAfterSecond ? '\u2705 No (no fees)' : '\u274c Yes')\n\n  console.log('\\n\ud83d\udca1 Key Insights:')\n  console.log('   1. The deployer detected no changes between deployments')\n  console.log('   2. No transaction was created (saving time and fees)')\n  console.log('   3. The same app information was returned')\n  console.log('   4. This behavior is called \"idempotency\"')\n  \n  console.log('\\n\ud83c\udfaf Benefits:')\n  console.log('   \u2705 Safe to run deployment scripts multiple times')\n  console.log('   \u2705 No unnecessary blockchain transactions')\n  console.log('   \u2705 Cost savings (no transaction fees)')\n  console.log('   \u2705 Faster deployment cycles')\n  console.log('   \u2705 Perfect for CI/CD automation')\n  \n  console.log('\\n\ud83d\udd27 When Updates Occur:')\n  console.log('   - When approval or clear program changes')\n  console.log('   - When schema changes (within allowed bounds)')\n  console.log('   - When version number changes')\n  console.log('   - When metadata changes')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "118-multi-account-transaction-groups-with-different-signers",
      "title": "Multi-Account Transaction Groups with Different Signers",
      "summary": "Demonstrates how to compose transaction groups where different transactions are signed by different accounts, useful for multi-party operations and complex transaction workflows.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction composition",
      "specific_use_case": "Call an ABI method with a transaction argument signed by a different account",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DApp developers"
      ],
      "features_tested": [
        "client.call",
        "transaction with signer",
        "multi-account transaction groups",
        "transaction arguments with explicit signers"
      ],
      "feature_tags": [
        "transaction-groups",
        "multi-account",
        "abi-calls",
        "transaction-composition",
        "signers"
      ],
      "folder": "118-multi-account-transaction-groups-with-different-signers",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App account and second signer account addresses",
        "Second signer account funded successfully",
        "Transaction group successfully sent with multiple signers",
        "Details showing which account signed which transaction"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Sign transaction in group with different signer if provided"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample contract with call_abi_txn method that accepts a transaction and string argument"
        }
      ],
      "notes": "This is a high-value example for DApp developers who need to coordinate transactions from multiple users or accounts. Common use cases include escrow services, atomic swaps, and multi-signature workflows.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to compose transaction groups where different\n * transactions are signed by different accounts. This is essential for:\n * - Multi-party operations (escrow, atomic swaps, etc.)\n * - Complex DApp workflows involving multiple users\n * - Smart contracts that require transactions from specific accounts\n */\n\nasync function multiAccountTransactionGroupExample() {\n  // Initialize AlgoKit and get clients\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n\n  // Get the main application account (deployer)\n  const appAccount = await algorand.account.localNetDispenser()\n  console.log(`App account address: ${appAccount.addr}`)\n\n  // Create and fund a second account that will sign a transaction in the group\n  console.log('\\nCreating and funding second signer account...')\n  const secondSigner = algorand.account.random()\n  \n  // Fund the second account\n  await algorand.send.payment({\n    sender: appAccount.addr,\n    receiver: secondSigner.addr,\n    amount: algokit.algo(1),\n  })\n  console.log(`Second signer address: ${secondSigner.addr}`)\n  console.log('Second signer account funded with 1 ALGO')\n\n  // Deploy or get an existing application\n  console.log('\\nDeploying application...')\n  const { client } = await deployYourApp(appAccount, algod, indexer)\n\n  // Create a payment transaction from the second signer\n  // This transaction will be included in the group but signed by the second account\n  console.log('\\nCreating payment transaction from second signer...')\n  const paymentTxn = await algorand.createTransaction.payment({\n    sender: secondSigner.addr,\n    receiver: secondSigner.addr,\n    amount: algokit.microAlgo(5000),\n  })\n\n  console.log('Calling ABI method with multi-account transaction group...')\n  console.log('  - App call will be signed by app account')\n  console.log('  - Payment transaction will be signed by second signer')\n\n  // Call the ABI method, passing the transaction with its signer\n  // The framework will automatically handle signing each transaction with the appropriate signer\n  const result = await client.call({\n    method: 'call_abi_txn',\n    methodArgs: [\n      // Pass both the transaction and its signer as an object\n      { transaction: paymentTxn, signer: secondSigner },\n      'test'\n    ],\n    sender: appAccount.addr, // The app call itself is signed by appAccount\n  })\n\n  console.log('\\n\u2705 Transaction group successfully sent!')\n  console.log(`Total transactions in group: ${result.transactions.length}`)\n  console.log('\\nTransaction details:')\n  result.transactions.forEach((txn, idx) => {\n    console.log(`  [${idx}] Type: ${txn.type}, ID: ${txn.txID()}`)\n  })\n\n  console.log('\\nKey takeaway: Different transactions in the group were signed by different accounts')\n  console.log('  - Transaction 0 (app call): Signed by app account')\n  console.log('  - Transaction 1 (payment): Signed by second signer')\n}\n\n// Helper function placeholder - replace with your actual app deployment\nasync function deployYourApp(account: any, algod: any, indexer: any) {\n  // This is a placeholder - implement your actual app deployment logic\n  // The app should have a method like:\n  // call_abi_txn(txn: Transaction, note: string) -> void\n  throw new Error('Implement your app deployment logic here')\n}\n\n// Run the example\nmultiAccountTransactionGroupExample().catch(console.error)"
    },
    {
      "example_id": "119-nested-method-calls---method-call-as-argument",
      "title": "Nested Method Calls - Method Call as Argument",
      "summary": "Demonstrates how to compose method calls where one method accepts another method call as an argument, enabling complex interaction patterns and ABI composability.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call a smart contract method that takes another method call as an argument",
      "target_users": [
        "Smart contract developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup.addAppCallMethodCall",
        "method call arguments",
        "nested method calls",
        "ABI composability"
      ],
      "feature_tags": [
        "nested-method-calls",
        "method-composition",
        "abi-composability",
        "advanced",
        "smart-contracts",
        "transaction-groups"
      ],
      "folder": "119-nested-method-calls---method-call-as-argument",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Nested method call executed successfully",
        "Return value from inner helloWorld call showing 'Hello, World!'",
        "Return value from outer methodArg call showing the app ID",
        "Confirmation that method composition worked correctly"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "method with method call arg"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Contract with helloWorld and methodArg methods demonstrating method composition"
        }
      ],
      "notes": "This example showcases advanced ABI composability where methods can call other methods. This is particularly useful for DeFi protocols, multi-contract interactions, and building modular smart contract architectures.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppCallMethodCall } from '@algorandfoundation/algokit-utils/types/composer'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to compose method calls where one method accepts\n * another method call as an argument. This enables powerful composability patterns\n * in smart contract interactions.\n */\n\nasync function nestedMethodCallExample() {\n  // Initialize AlgorandClient - connects to your Algorand node\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get account from LocalNet\n  const alice = (await algorand.account.localNetDispenser()).account\n\n  // Deploy or reference your application\n  const appId = 1234 // Replace with your actual app ID\n\n  // Define ABI methods\n  // In a real scenario, you'd import these from your contract's ABI JSON\n  const helloWorldMethod = new algosdk.ABIMethod({\n    name: 'helloWorld',\n    args: [],\n    returns: { type: 'string', desc: 'Returns a greeting message' },\n  })\n\n  const methodArgMethod = new algosdk.ABIMethod({\n    name: 'methodArg',\n    args: [{ type: 'appl', name: 'innerCall', desc: 'An inner application call to execute' }],\n    returns: { type: 'uint64', desc: 'Returns the app ID of the inner call' },\n  })\n\n  console.log('Creating a method call that takes another method call as an argument...')\n\n  // Define the inner method call that will be used as an argument\n  // This call will be executed as part of the outer method\n  const helloWorldCall: AppCallMethodCall = {\n    sender: alice.addr,\n    appId: appId,\n    method: helloWorldMethod,\n  }\n\n  console.log('\\nInner method call: helloWorld()')\n  console.log('Outer method call: methodArg(helloWorldCall)')\n\n  // Create a transaction group with a method that accepts another method call as an argument\n  const methodArgResult = await algorand\n    .newGroup()\n    .addAppCallMethodCall({\n      sender: alice.addr,\n      appId: appId,\n      method: methodArgMethod,\n      // Pass the helloWorld method call as an argument\n      args: [helloWorldCall],\n    })\n    .send()\n\n  console.log('\\nNested method call executed successfully!')\n  console.log(`Transaction ID: ${methodArgResult.txIds[0]}`)\n\n  // Process return values\n  // The first return value is from the inner helloWorld call\n  // The second return value is from the outer methodArg call\n  if (methodArgResult.returns && methodArgResult.returns.length > 0) {\n    console.log('\\nReturn values:')\n\n    // Return value from the inner helloWorld call\n    const innerReturnValue = methodArgResult.returns[0].returnValue?.valueOf()\n    console.log(`Inner call (helloWorld) returned: ${innerReturnValue}`)\n\n    // Return value from the outer methodArg call\n    if (methodArgResult.returns.length > 1) {\n      const outerReturnValue = methodArgResult.returns[1].returnValue?.valueOf()\n      console.log(`Outer call (methodArg) returned: ${outerReturnValue}`)\n      console.log(`Expected app ID: ${appId}`)\n      console.log(`Match: ${outerReturnValue === BigInt(appId)}`)\n    }\n  }\n\n  console.log('\\nKey takeaways:')\n  console.log('- Methods can accept other method calls as arguments')\n  console.log('- This enables powerful composability and modularity in smart contracts')\n  console.log('- Inner method calls are executed as part of the outer method')\n  console.log('- Both inner and outer methods can return values')\n  console.log('- Use cases: DeFi protocols, multi-step workflows, contract orchestration')\n  console.log('\\nCommon patterns:')\n  console.log('- Oracle data fetching followed by processing')\n  console.log('- Multi-contract interactions in DeFi')\n  console.log('- Modular contract architectures')\n}\n\n// Run the example\nnestedMethodCallExample().catch(console.error)\n"
    },
    {
      "example_id": "120-pass-transaction-as-abi-method-argument",
      "title": "Pass Transaction as ABI Method Argument",
      "summary": "Demonstrates how to call an ABI method with a transaction as an argument, creating an atomic transaction group",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call an ABI method with a transaction as an argument",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.send.call",
        "transaction arguments",
        "atomic transactions",
        "AppManager.getABIReturn"
      ],
      "feature_tags": [
        "abi",
        "transaction-arguments",
        "atomic-transactions",
        "payment-transaction",
        "app-client",
        "typed-client"
      ],
      "folder": "120-pass-transaction-as-abi-method-argument",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "SENDER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy your smart contract with the 'call_abi_txn' method",
          "Update YOUR_APP_ID in the code with your deployed app ID"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creating a payment transaction to pass as an argument...",
        "Payment transaction created for 5000 microAlgos",
        "Calling ABI method with transaction argument...",
        "Transaction group confirmed!",
        "Number of transactions in group: 2",
        "Return value: Sent 5000. test",
        "Example completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Construct transaction with abi encoding including transaction"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract with call_abi_txn method that accepts a payment transaction and string"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining the example and atomic transaction groups"
        }
      ],
      "notes": "This example shows the power of atomic transaction groups. When a transaction is passed as an ABI argument, both transactions must succeed or both will fail, ensuring atomicity.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { AppManager } from '@algorandfoundation/algokit-utils/types/app-manager'\nimport { getArc56Method } from '@algorandfoundation/algokit-utils/types/app-spec'\n// Import your generated typed client\nimport { YourAppClient } from './artifacts/YourAppClient'\n\n/**\n * This example demonstrates how to pass a transaction as an argument to an ABI method.\n * When you pass a transaction as an ABI argument, the SDK automatically creates an\n * atomic transaction group, ensuring both transactions execute together or not at all.\n */\n\nasync function main() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get account from KMD (or use your own account)\n  const sender = await algorand.account.fromEnvironment('SENDER')\n  \n  console.log('Creating a payment transaction to pass as an argument...')\n  \n  // Create a payment transaction that will be passed as an argument\n  const paymentTxn = await algorand.createTransaction.payment({\n    sender: sender.addr,\n    receiver: sender.addr,\n    amount: algokit.microAlgo(5000), // 5000 microAlgos\n  })\n  \n  console.log(`Payment transaction created for ${paymentTxn.payment?.amount} microAlgos`)\n  \n  // Initialize your app client (assumes you have a deployed app)\n  const appClient = new YourAppClient(\n    {\n      resolveBy: 'id',\n      id: YOUR_APP_ID, // Replace with your deployed app ID\n      sender,\n    },\n    algorand.client.algod\n  )\n  \n  console.log('Calling ABI method with transaction argument...')\n  \n  // Call the ABI method with the transaction as an argument\n  // The SDK will automatically create an atomic transaction group\n  const result = await appClient.send.call({\n    method: 'call_abi_txn',\n    args: [paymentTxn, 'test'],\n  })\n  \n  console.log('Transaction group confirmed!')\n  console.log(`Number of transactions in group: ${result.transactions.length}`)\n  console.log(`Return value: ${result.return}`)\n  \n  // Extract the ABI return value from the confirmation\n  if (result.confirmations && result.confirmations[1]) {\n    const returnValue = AppManager.getABIReturn(\n      result.confirmations[1],\n      getArc56Method('call_abi_txn', appClient.appSpec)\n    )\n    console.log(`ABI Return Value: ${returnValue?.returnValue}`)\n  }\n  \n  console.log('\\nExample completed successfully!')\n  console.log('The payment transaction and app call were executed atomically.')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "121-pass-transaction-as-method-argument",
      "title": "Pass Transaction as Method Argument",
      "summary": "Shows how to call a smart contract method that accepts a transaction as an argument, a common pattern for complex dApp logic.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Call a smart contract method that accepts a transaction as an argument",
      "target_users": [
        "Smart contract developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup.addAppCallMethodCall",
        "algorand.createTransaction.payment",
        "transaction arguments to methods",
        "ABI method calls"
      ],
      "feature_tags": [
        "abi-method-call",
        "transaction-reference",
        "method-arguments",
        "transaction-groups",
        "smart-contracts"
      ],
      "folder": "121-pass-transaction-as-method-argument",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction group sent successfully",
        "Method return value showing the sender address",
        "Confirmation that the transaction argument was processed correctly"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "method with txn arg"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Contract with txnArg method that accepts a transaction argument"
        }
      ],
      "notes": "This example requires a deployed smart contract with a method that accepts transaction arguments. The pattern is useful for payment verification, escrow logic, and complex multi-step workflows.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to pass a transaction as an argument to a smart contract method.\n * This pattern is useful when your contract needs to verify or process transaction details.\n */\n\nasync function transactionAsArgumentExample() {\n  // Initialize AlgorandClient - connects to your Algorand node\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get account from LocalNet\n  const alice = (await algorand.account.localNetDispenser()).account\n\n  // Deploy or reference your application\n  // For this example, assume we have an app with a 'txnArg' method that accepts a transaction\n  const appId = 1234 // Replace with your actual app ID\n\n  // Get the ABI method definition\n  // In a real scenario, you'd import this from your contract's ABI JSON\n  const txnArgMethod = new algosdk.ABIMethod({\n    name: 'txnArg',\n    args: [{ type: 'txn', name: 'payment', desc: 'Payment transaction to process' }],\n    returns: { type: 'address', desc: 'Sender address from the transaction' },\n  })\n\n  console.log('Creating a transaction group with a payment transaction as a method argument...')\n\n  // Create a transaction group where:\n  // 1. A payment transaction is added to the group\n  // 2. An app call method references that payment transaction as an argument\n  const txnResult = await algorand\n    .newGroup()\n    // Add a payment transaction to the group\n    .addPayment({\n      sender: alice.addr,\n      receiver: alice.addr,\n      amount: AlgoAmount.MicroAlgo(0),\n      note: new Uint8Array([1]),\n    })\n    // Add an app call that references a payment transaction as an argument\n    .addAppCallMethodCall({\n      sender: alice.addr,\n      appId: appId,\n      method: txnArgMethod,\n      // Create a transaction to pass as an argument\n      // Note: This transaction is created but not sent separately - it's passed as data\n      args: [\n        algorand.createTransaction.payment({\n          sender: alice.addr,\n          receiver: alice.addr,\n          amount: AlgoAmount.MicroAlgo(0),\n        }),\n      ],\n    })\n    .send()\n\n  console.log('\\nTransaction group sent successfully!')\n  console.log(`Transaction ID: ${txnResult.txIds[0]}`)\n\n  // Access the return value from the method call\n  if (txnResult.returns && txnResult.returns.length > 0) {\n    const returnValue = txnResult.returns[0].returnValue?.valueOf()\n    console.log(`\\nMethod return value: ${returnValue}`)\n    console.log(`Expected: ${alice.addr}`)\n    console.log(`Match: ${returnValue === alice.addr}`)\n  }\n\n  console.log('\\nKey takeaways:')\n  console.log('- Transactions can be passed as arguments to ABI method calls')\n  console.log('- Use algorand.createTransaction to create transaction objects for arguments')\n  console.log('- The transaction is included in the group but processed by the smart contract')\n  console.log('- This pattern enables contracts to verify and process transaction details')\n  console.log('- Common use cases: escrow validation, payment verification, multi-step workflows')\n}\n\n// Run the example\ntransactionAsArgumentExample().catch(console.error)\n"
    },
    {
      "example_id": "122-raw-application-call-with-manual-argument-encoding",
      "title": "Raw Application Call with Manual Argument Encoding",
      "summary": "Demonstrates how to make a raw application call with manually encoded arguments in an atomic transaction group, providing fine-grained control over the call parameters.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "transaction management",
      "specific_use_case": "Make a raw application call with manually encoded arguments in an atomic transaction group",
      "target_users": [
        "Advanced SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.newGroup.addAppCall",
        "raw app call",
        "manual argument encoding",
        "atomic transaction groups",
        "method selectors"
      ],
      "feature_tags": [
        "transaction-groups",
        "raw-app-call",
        "manual-encoding",
        "abi-method-selector",
        "atomic-transactions",
        "advanced"
      ],
      "folder": "122-raw-application-call-with-manual-argument-encoding",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction group successfully executed",
        "Balance changes showing payment and fees",
        "App call logs showing the result of the calculation"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "addAppCall"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Simple contract with doMath method for demonstration"
        }
      ],
      "notes": "This example requires a deployed smart contract with a 'doMath' method. Users should replace the appId and method selector with their own contract details.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to make a raw application call with manually encoded arguments.\n * This approach gives you fine-grained control over the call parameters and is useful when you need\n * to work directly with the low-level ABI encoding.\n */\n\nasync function rawAppCallExample() {\n  // Initialize AlgorandClient - connects to your Algorand node\n  const algorand = AlgorandClient.defaultLocalNet()\n\n  // Get accounts from LocalNet\n  const alice = (await algorand.account.localNetDispenser()).account\n  const bob = algosdk.generateAccount()\n\n  // Fund bob's account\n  await algorand.send.payment({\n    sender: alice.addr,\n    receiver: bob.addr,\n    amount: AlgoAmount.Algos(10),\n  })\n\n  // Deploy a test application (replace this with your actual app deployment)\n  // For this example, assume we have an app with a 'doMath' method that takes two uint64s and an operation\n  const appId = 1234 // Replace with your actual app ID\n\n  // Get the ABI method selector for 'doMath'\n  // In a real scenario, you'd get this from your contract's ABI\n  const methodSelector = new Uint8Array([0x15, 0x1f, 0x7c, 0x75]) // Example selector\n\n  console.log('Creating atomic transaction group with payment and raw app call...')\n\n  // Get balances before the transaction\n  const alicePreBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPreBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`Alice balance before: ${alicePreBalance.microAlgo} microAlgos`)\n  console.log(`Bob balance before: ${bobPreBalance.microAlgo} microAlgos`)\n\n  // Create an atomic transaction group with:\n  // 1. A payment transaction from Alice to Bob\n  // 2. A raw app call with manually encoded arguments\n  const result = await algorand\n    .newGroup()\n    // Add a payment transaction\n    .addPayment({\n      sender: alice.addr,\n      receiver: bob.addr,\n      amount: AlgoAmount.MicroAlgo(1),\n      note: new Uint8Array([1]),\n    })\n    // Add a raw app call with manually encoded arguments\n    .addAppCall({\n      sender: alice.addr,\n      appId: appId,\n      args: [\n        methodSelector, // Method selector (first 4 bytes of method signature hash)\n        algosdk.encodeUint64(1), // First argument: uint64 value 1\n        algosdk.encodeUint64(2), // Second argument: uint64 value 2\n        Uint8Array.from(Buffer.from('AANzdW0=', 'base64')), // Third argument: operation (\"sum\")\n      ],\n      note: 'addAppCall',\n    })\n    .execute()\n\n  console.log('\\nTransaction group executed successfully!')\n  console.log(`Group ID: ${result.groupId}`)\n\n  // Get balances after the transaction\n  const alicePostBalance = (await algorand.account.getInformation(alice.addr)).balance\n  const bobPostBalance = (await algorand.account.getInformation(bob.addr)).balance\n\n  console.log(`\\nAlice balance after: ${alicePostBalance.microAlgo} microAlgos`)\n  console.log(`Bob balance after: ${bobPostBalance.microAlgo} microAlgos`)\n  console.log(`Alice paid: ${alicePreBalance.microAlgo - alicePostBalance.microAlgo} microAlgos (includes fees)`)\n  console.log(`Bob received: ${bobPostBalance.microAlgo - bobPreBalance.microAlgo} microAlgos`)\n\n  // Check if there are logs from the app call\n  if (result.confirmations[1].logs && result.confirmations[1].logs.length > 0) {\n    const logData = Buffer.from(result.confirmations[1].logs[0]).toString('hex')\n    console.log(`\\nApp call log output: ${logData}`)\n  }\n\n  console.log('\\nKey takeaways:')\n  console.log('- Raw app calls give you fine-grained control over arguments')\n  console.log('- Method selectors are the first 4 bytes of the method signature hash')\n  console.log('- Arguments must be manually encoded using algosdk encoding functions')\n  console.log('- Atomic groups ensure all transactions succeed or fail together')\n}\n\n// Run the example\nrawAppCallExample().catch(console.error)\n"
    },
    {
      "example_id": "123-rekey-account-during-application-opt-in",
      "title": "Rekey Account During Application Opt-In",
      "summary": "Demonstrates how to rekey an account during an application opt-in operation and use the rekeyed account for subsequent transactions.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "account management",
      "specific_use_case": "Rekey an account during an application opt-in operation",
      "target_users": [
        "SDK developers",
        "Security engineers"
      ],
      "features_tested": [
        "client.optIn",
        "rekeyTo parameter",
        "algorand.account.rekeyed",
        "rekeyed account transactions"
      ],
      "feature_tags": [
        "account-rekeying",
        "app-client",
        "opt-in",
        "security",
        "account-management",
        "rekeyed-transactions"
      ],
      "folder": "123-rekey-account-during-application-opt-in",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Original and rekey target addresses displayed",
        "Application created successfully",
        "Opt-in successful and account rekeyed",
        "Payment transaction successful with transaction ID",
        "Confirmation that the account has been rekeyed"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Call app with rekey"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app-spec.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "App specification with opt_in method that supports rekeying"
        }
      ],
      "notes": "Demonstrates advanced security pattern of rekeying accounts. The rekeyed account maintains the original address but requires the new key for signing. This is useful for key rotation, multi-sig setups, and other security patterns.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport { appSpec } from './app-spec' // Import your app specification\n\n/**\n * This example demonstrates how to rekey an account during an application opt-in.\n * Rekeying allows you to change the spending authority of an account to a different key,\n * which is useful for security patterns like key rotation and multi-sig setups.\n */\n\nasync function rekeyAccountDuringOptIn() {\n  // Initialize AlgoKit and get localnet context\n  const localnet = algokit.Config.getConfigFromEnvOrDefaults()\n  const algod = algokit.getAlgoClient({\n    server: localnet.algodServer,\n    token: localnet.algodToken,\n    port: localnet.algodPort,\n  })\n  \n  // Get an algorand client for easier account and transaction management\n  const algorand = algokit.AlgorandClient.fromClients({ algod })\n  \n  // Get a test account with funds\n  const testAccount = await algokit.getDispenserAccount(algod)\n  \n  // Create a random account to rekey to\n  const rekeyTo = algorand.account.random()\n  \n  console.log('Original account address:', testAccount.addr)\n  console.log('Rekey target address:', rekeyTo.addr)\n  \n  // Create an app client\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'id',\n      app: appSpec,\n      sender: testAccount,\n      id: 0,\n    },\n    algod,\n  )\n  \n  // Create the application\n  console.log('\\nCreating application...')\n  await client.create({\n    deployTimeParams: {\n      UPDATABLE: 0,\n      DELETABLE: 0,\n      VALUE: 1,\n    },\n  })\n  console.log('Application created successfully')\n  \n  // Opt-in to the application and rekey the account in the same transaction\n  console.log('\\nOpting in to application and rekeying account...')\n  await client.optIn({\n    method: 'opt_in',\n    methodArgs: [],\n    rekeyTo, // This parameter rekeys the account to the new address\n  })\n  console.log('Opt-in successful and account rekeyed')\n  \n  // Create a rekeyed account object that can be used for transactions\n  // This combines the original address with the new signing authority\n  const rekeyedAccount = algorand.account.rekeyed(testAccount, rekeyTo)\n  \n  console.log('\\nTesting rekeyed account by sending a payment...')\n  \n  // Send a payment using the rekeyed account\n  // The transaction is sent from testAccount.addr but signed with rekeyTo's key\n  const txn = await algorand.send.payment({\n    amount: algokit.microAlgos(0), // 0 ALGO payment for testing\n    sender: rekeyedAccount,\n    receiver: testAccount.addr,\n  })\n  \n  console.log('Payment transaction successful!')\n  console.log('Transaction ID:', txn.txId)\n  console.log('\\nThe account has been successfully rekeyed.')\n  console.log('Future transactions from', testAccount.addr, 'must be signed by', rekeyTo.addr)\n}\n\n// Run the example\nrekeyAccountDuringOptIn().catch(console.error)"
    },
    {
      "example_id": "124-replace-app-with-schema-breaking-changes",
      "title": "Replace App with Schema-Breaking Changes",
      "summary": "Demonstrates how to handle schema-breaking changes during app deployment by using the replacement strategy. When schema changes are incompatible with updates, the app can be deleted and recreated with the new schema.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an app, then deploy with a schema-breaking change and onSchemaBreak='replace' to delete and recreate the app",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "onSchemaBreak parameter",
        "schema changes",
        "app replacement"
      ],
      "feature_tags": [
        "schema-management",
        "schema-breaking-changes",
        "app-replacement",
        "state-management",
        "deployment-strategies"
      ],
      "folder": "124-replace-app-with-schema-breaking-changes",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "DEPLOYER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a funded account for deployment"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial app deployed with original schema",
        "Schema changes explained",
        "Replacement app deployed with new schema",
        "New app ID displayed (different from original)",
        "Confirmation that old app was deleted",
        "Educational notes about schema breaking changes and their implications"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy replacement of deletable schema broken app"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package.json with required dependencies"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Detailed explanation of schema management, breaking changes, and best practices"
        }
      ],
      "notes": "This example is crucial for developers managing app schema evolution. It demonstrates the constraints of Algorand's storage model and provides a practical solution for handling schema-breaking changes. The example emphasizes the trade-offs and implications of replacing an app.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to handle schema-breaking changes in Algorand apps.\n * \n * When you need to change the storage schema (global/local state) of an app,\n * you often cannot update it in place because Algorand doesn't allow certain\n * schema modifications. In these cases, you can use the 'replace' strategy\n * with onSchemaBreak parameter.\n * \n * This example shows:\n * 1. Deploying an app with an initial schema\n * 2. Attempting to deploy with a schema-breaking change\n * 3. Using onSchemaBreak: 'replace' to handle the situation\n * 4. The old app is deleted and a new one is created\n */\n\nasync function main() {\n  // Initialize AlgorandClient for local development\n  const algorand = AlgorandClient.defaultLocalNet()\n  const account = await algorand.account.fromEnvironment('DEPLOYER')\n  \n  console.log('=== Deploying Initial App with Original Schema ===')\n  console.log(`Using account: ${account.addr}\\n`)\n  \n  // Define approval and clear programs\n  const approvalProgram = `#pragma version 10\n  // Approval program v1.0\n  int 1\n  return`\n  \n  const clearProgram = `#pragma version 10\n  // Clear state program\n  int 1\n  return`\n  \n  // Compile the programs\n  const approval = await algorand.client.algod.compile(approvalProgram).do()\n  const clear = await algorand.client.algod.compile(clearProgram).do()\n  \n  // Deploy the first version with initial schema\n  const deployment1 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approval.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 2,        // Initial: 2 global uint values\n      globalByteSlices: 1,   // Initial: 1 global byte slice\n      localUints: 1,         // Initial: 1 local uint value\n      localByteSlices: 0,    // Initial: 0 local byte slices\n    },\n    metadata: {\n      name: 'SchemaApp',\n      version: '1.0',\n      deletable: true,  // Must be deletable to allow replacement\n      updatable: true,\n    },\n  }\n  \n  const result1 = await algorand.appDeployer.deploy(deployment1)\n  \n  console.log(`\u2705 Initial deployment successful!`)\n  console.log(`   App ID: ${result1.appId}`)\n  console.log(`   Version: ${result1.version}`)\n  console.log(`   Schema (Global): ${deployment1.schema.globalUints} uints, ${deployment1.schema.globalByteSlices} byte slices`)\n  console.log(`   Schema (Local): ${deployment1.schema.localUints} uints, ${deployment1.schema.localByteSlices} byte slices\\n`)\n  \n  // Wait a moment for the transaction to be processed\n  await new Promise(resolve => setTimeout(resolve, 1000))\n  \n  console.log('=== Deploying Updated App with Schema-Breaking Changes ===')\n  console.log('Schema changes:')\n  console.log('  - Global uints: 2 \u2192 3 (adding storage)')\n  console.log('  - Local byte slices: 0 \u2192 2 (adding storage)')\n  console.log('\\nThese changes break the schema and require replacement...\\n')\n  \n  // Deploy with schema-breaking changes\n  const deployment2 = {\n    sender: account.addr,\n    approvalProgram: new Uint8Array(Buffer.from(approval.result, 'base64')),\n    clearStateProgram: new Uint8Array(Buffer.from(clear.result, 'base64')),\n    schema: {\n      globalUints: 3,        // Changed: 2 \u2192 3 (schema breaking!)\n      globalByteSlices: 1,   // Unchanged\n      localUints: 1,         // Unchanged\n      localByteSlices: 2,    // Changed: 0 \u2192 2 (schema breaking!)\n    },\n    metadata: {\n      name: 'SchemaApp',\n      version: '2.0',\n      deletable: true,\n      updatable: true,\n    },\n    onSchemaBreak: 'replace',  // Handle schema break by replacing the app\n  }\n  \n  const result2 = await algorand.appDeployer.deploy(deployment2)\n  \n  console.log(`\u2705 Replacement deployment successful!`)\n  console.log(`   New App ID: ${result2.appId}`)\n  console.log(`   Old App ID: ${result1.appId}`)\n  console.log(`   App IDs are different: ${result2.appId !== result1.appId}`)\n  console.log(`   Version: ${result2.version}`)\n  console.log(`   Operation: ${result2.operationPerformed}`)\n  console.log(`   Schema (Global): ${deployment2.schema.globalUints} uints, ${deployment2.schema.globalByteSlices} byte slices`)\n  console.log(`   Schema (Local): ${deployment2.schema.localUints} uints, ${deployment2.schema.localByteSlices} byte slices\\n`)\n  \n  // Check if the old app was deleted\n  if (result2.deleteResult) {\n    console.log(`   \u2705 Old app was deleted as part of replacement`)\n    console.log(`   Delete transaction ID: ${result2.deleteResult.transaction.txID()}\\n`)\n  }\n  \n  console.log('=== Understanding Schema Changes ===')\n  console.log('Schema-breaking changes occur when:')\n  console.log('  \u2022 You increase the number of global uints')\n  console.log('  \u2022 You increase the number of global byte slices')\n  console.log('  \u2022 You increase the number of local uints')\n  console.log('  \u2022 You increase the number of local byte slices')\n  console.log('')\n  console.log('\u26a0\ufe0f  Algorand does NOT allow updating an app to increase storage!')\n  console.log('\\nSolutions:')\n  console.log('  1. Use onSchemaBreak: \"replace\" to delete and recreate (as shown here)')\n  console.log('  2. Use onSchemaBreak: \"fail\" to abort the deployment')\n  console.log('  3. Design your schema with extra capacity from the start\\n')\n  \n  console.log('=== Important Considerations ===')\n  console.log('When replacing an app due to schema changes:')\n  console.log('  \u26a0\ufe0f  All global state is lost (reset to empty)')\n  console.log('  \u26a0\ufe0f  Users must re-opt-in to the new app')\n  console.log('  \u26a0\ufe0f  All local state is lost for all users')\n  console.log('  \u26a0\ufe0f  The app gets a new ID (update references!)')\n  console.log('  \u2705  You get the new schema you need')\n  console.log('  \u2705  Fresh start with clean state\\n')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "125-replace-application-with-custom-abi-methods",
      "title": "Replace Application with Custom ABI Methods",
      "summary": "Shows how to replace an application using custom ABI methods for both creation and deletion, with the ability to capture return values from both operations.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Replace an application using custom ABI create and delete methods",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "factory.deploy",
        "createParams with ABI method",
        "deleteParams with ABI method",
        "deleteReturn",
        "return values from ABI methods",
        "populateAppCallResources"
      ],
      "feature_tags": [
        "app-deployment",
        "app-replacement",
        "abi-methods",
        "custom-create",
        "custom-delete",
        "return-values",
        "factory-pattern"
      ],
      "folder": "125-replace-application-with-custom-abi-methods",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker",
          "node"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure your smart contract has 'create_abi' and 'delete_abi' methods defined"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Initial app deployed",
        "Replacement performed using ABI methods",
        "Return value from create_abi method: 'arg_io'",
        "Return value from delete_abi method: 'arg2_io'",
        "New app created with higher ID",
        "Old app deleted successfully"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Deploy app - replace (abi)"
        }
      ],
      "artifacts_plan": [],
      "notes": "Your smart contract must implement both 'create_abi' and 'delete_abi' methods that accept the appropriate arguments and return values. The populateAppCallResources: false option gives you more control over resource population.",
      "generated_code": "import { algorandFixture } from '@algorandfoundation/algokit-utils/testing'\nimport * as algosdk from 'algosdk'\nimport { OnApplicationComplete } from 'algosdk'\n\n/**\n * This example demonstrates advanced app replacement using custom ABI methods.\n * \n * Unlike simple replacement, this shows:\n * - Using custom ABI methods for app creation (create_abi)\n * - Using custom ABI methods for app deletion (delete_abi)\n * - Capturing return values from both operations\n * - Passing arguments to both create and delete methods\n * \n * This is useful when your smart contract has specific initialization\n * or cleanup logic that needs to be executed during deployment/deletion.\n */\n\nasync function replaceApplicationWithAbiExample() {\n  // Set up the testing environment with LocalNet\n  const localnet = await algorandFixture()\n  const { testAccount } = localnet.context\n\n  // Create a factory instance for your application\n  // Your app spec should define 'create_abi' and 'delete_abi' methods\n  const factory = localnet.algorand.client.getTypedAppFactory({\n    // Your app specification with ABI methods would go here\n    // Must include:\n    // - create_abi: A method that handles app creation with custom logic\n    // - delete_abi: A method that handles app deletion with custom logic\n  })\n\n  console.log('Step 1: Deploy initial application')\n  const { result: createdApp } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    deletable: true, // Required for replacement\n    populateAppCallResources: false, // Manual resource handling\n  })\n\n  console.log(`\u2713 Initial app deployed with ID: ${createdApp.appId}`)\n  console.log(`  App address: ${createdApp.appAddress}`)\n\n  console.log('\\nStep 2: Replace app using custom ABI methods')\n  const { result: app } = await factory.deploy({\n    deployTimeParams: {\n      VALUE: 2,\n    },\n    onUpdate: 'replace',\n    \n    // Custom ABI method for creation\n    createParams: {\n      method: 'create_abi',\n      args: ['arg_io'], // Arguments passed to the create method\n    },\n    \n    // Custom ABI method for deletion\n    deleteParams: {\n      method: 'delete_abi',\n      args: ['arg2_io'], // Arguments passed to the delete method\n    },\n    \n    populateAppCallResources: false,\n  })\n\n  console.log(`\\n\u2713 Replacement with ABI methods completed!`)\n  console.log(`  Operation performed: ${app.operationPerformed}`)\n  console.log(`  Old app ID: ${createdApp.appId}`)\n  console.log(`  New app ID: ${app.appId}`)\n  console.log(`  New app address: ${app.appAddress}`)\n  console.log(`  Address matches: ${algosdk.getApplicationAddress(app.appId) === app.appAddress ? '\u2713' : '\u2717'}`)\n\n  // Return values from ABI methods\n  console.log(`\\n\u2713 ABI Method Return Values:`)\n  console.log(`  create_abi returned: \"${app.return}\"`)\n  console.log(`  delete_abi returned: \"${app.deleteReturn}\"`)\n\n  // Verify the deletion occurred\n  if (app.deleteResult && app.deleteResult.confirmation) {\n    console.log(`\\n\u2713 Old application deleted via ABI method`)\n    console.log(`  Deleted app ID: ${app.deleteResult.transaction.applicationCall?.appIndex}`)\n    console.log(`  OnComplete: ${app.deleteResult.transaction.applicationCall?.onComplete === OnApplicationComplete.DeleteApplicationOC ? 'DeleteApplication' : 'Unknown'}`)\n  }\n\n  console.log('\\n\u2139\ufe0f  Benefits of ABI methods:')\n  console.log('  \u2022 Execute custom initialization logic during creation')\n  console.log('  \u2022 Perform cleanup operations before deletion')\n  console.log('  \u2022 Capture return values for validation or logging')\n  console.log('  \u2022 Pass dynamic arguments to control behavior')\n}\n\n// Run the example\nreplaceApplicationWithAbiExample()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\\n\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "126-replace-an-application-with-delete-and-recreate",
      "title": "Replace an Application with Delete and Recreate",
      "summary": "Demonstrates how to replace an existing Algorand application by deleting it and creating a new one using the 'replace' deployment strategy",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Replace an existing application by deleting it and creating a new one",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.deploy",
        "onUpdate: 'replace'",
        "deleteResult",
        "OnApplicationComplete.DeleteApplicationOC",
        "app replacement"
      ],
      "feature_tags": [
        "app-client",
        "deployment",
        "replace",
        "delete",
        "schema-breaking-changes",
        "deployment-strategies"
      ],
      "folder": "126-replace-an-application-with-delete-and-recreate",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "INDEXER_PORT",
            "required": false,
            "example": "8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have a compiled app spec JSON file for your smart contract"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "First deployment creates app with VALUE=1",
        "Second deployment replaces the app with VALUE=2",
        "New app ID is greater than the original app ID",
        "Delete transaction confirmation is logged",
        "Operation performed: replace"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - replace"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample app spec with deploy-time parameters (VALUE, UPDATABLE, DELETABLE)"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        }
      ],
      "notes": "This example shows how to handle schema-breaking changes by replacing an application instead of updating it. The original app is deleted and a new one is created with the updated configuration.",
      "generated_code": "import algosdk from 'algosdk'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport appSpec from './contract.json'\n\n/**\n * This example demonstrates how to replace an existing Algorand application\n * by deleting it and creating a new one. This is useful when you need to make\n * schema-breaking changes that cannot be handled by a regular update.\n */\n\nasync function replaceApp() {\n  // Setup clients for LocalNet\n  const algodClient = algokit.getAlgoClient(\n    algokit.getAlgoNodeConfig('algod', 'localnet')\n  )\n  const indexer = algokit.getAlgoClient(\n    algokit.getAlgoNodeConfig('indexer', 'localnet')\n  )\n\n  // Get a test account with funds\n  const account = await algokit.getLocalNetDispenserAccount(algodClient)\n\n  console.log('Account address:', account.addr)\n  console.log('\\n--- Step 1: Deploy initial app ---')\n\n  // Create an app client that can find existing apps by creator and name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: account,\n      creatorAddress: account.addr,\n      findExistingUsing: indexer,\n    },\n    algodClient\n  )\n\n  // Deploy the first version of the app with VALUE=1\n  // allowDelete: true is required for the app to be deletable later\n  const createdApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    allowDelete: true,\n  })\n\n  console.log('Initial app created:')\n  console.log('  App ID:', createdApp.appId)\n  console.log('  App Address:', createdApp.appAddress)\n  console.log('  Operation:', createdApp.operationPerformed)\n\n  console.log('\\n--- Step 2: Replace the app with a new version ---')\n\n  // Deploy again with onUpdate: 'replace'\n  // This will delete the old app and create a new one with VALUE=2\n  const replacedApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 2,\n    },\n    onUpdate: 'replace',\n  })\n\n  console.log('App replaced:')\n  console.log('  New App ID:', replacedApp.appId)\n  console.log('  New App Address:', replacedApp.appAddress)\n  console.log('  Operation:', replacedApp.operationPerformed)\n  console.log('  Old App ID (deleted):', createdApp.appId)\n\n  // Verify the replacement\n  if (replacedApp.appId > createdApp.appId) {\n    console.log('\\n\u2713 Replacement successful: New app ID is greater than old app ID')\n  }\n\n  // Check delete result\n  if (replacedApp.deleteResult) {\n    console.log('\\nDelete operation details:')\n    console.log('  Deleted app ID:', replacedApp.deleteResult.transaction.applicationCall?.appIndex?.toString())\n    console.log('  Transaction ID:', replacedApp.deleteResult.transaction.txID())\n    console.log('  On Complete:', algosdk.OnApplicationComplete[replacedApp.deleteResult.transaction.applicationCall?.onComplete || 0])\n  }\n\n  console.log('\\n--- Summary ---')\n  console.log('The replace strategy is useful when:')\n  console.log('  \u2022 Making schema-breaking changes (e.g., changing global/local state)')\n  console.log('  \u2022 Completely redesigning app logic')\n  console.log('  \u2022 Starting fresh with a new app instance')\n  console.log('\\nNote: The old app must have allowDelete: true for replacement to work')\n}\n\n// Run the example\nreplaceApp().catch(console.error)\n"
    },
    {
      "example_id": "127-retrieve-latest-app-when-multiple-apps-have-same-name",
      "title": "Retrieve Latest App When Multiple Apps Have Same Name",
      "summary": "Shows how the SDK handles multiple apps created with the same name, demonstrating that getCreatorAppsByName returns only the most recently created app",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "medium",
      "use_case_category": "app deployment",
      "specific_use_case": "Create multiple apps with the same name and verify that getCreatorAppsByName returns the most recently created one",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.send.appCreate",
        "algorand.appDeployer.getCreatorAppsByName"
      ],
      "feature_tags": [
        "app-creation",
        "name-collision",
        "latest-app-retrieval",
        "multiple-apps",
        "app-deployer"
      ],
      "folder": "127-retrieve-latest-app-when-multiple-apps-have-same-name",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Three apps created with the same name",
        "Retrieved app matches the third (most recent) app",
        "First and second app IDs are shown as not matching"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Latest created app is retrieved"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates important behavior for developers managing multiple deployments - only the latest app with a given name is returned by getCreatorAppsByName.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how the SDK handles multiple apps with the same name.\n * When multiple apps are created with identical names, getCreatorAppsByName returns\n * only the most recently created app.\n * \n * This is important for understanding app deployment patterns and version management.\n */\n\nasync function main() {\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.fromEnvironment('ACCOUNT1')\n  console.log(`Using account: ${testAccount.addr}\\n`)\n\n  // Define deployment metadata (same name for all apps)\n  const appName = 'MY_APP'\n  const creationMetadata = {\n    name: appName,\n    version: '1.0',\n    updatable: true,\n    deletable: false\n  }\n\n  console.log('Creating multiple apps with the same name...')\n  console.log(`App name: ${appName}\\n`)\n\n  // Compile simple TEAL programs\n  const approvalProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n  const clearProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n\n  // Create three apps with the same name but different leases\n  // (lease prevents transaction deduplication)\n  console.log('Creating App 1...')\n  const app1 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify(creationMetadata)),\n    lease: new Uint8Array([1]) // Unique lease to prevent deduplication\n  })\n  console.log(`  \u2705 App 1 created with ID: ${app1.appId}`)\n\n  console.log('Creating App 2...')\n  const app2 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify(creationMetadata)),\n    lease: new Uint8Array([2])\n  })\n  console.log(`  \u2705 App 2 created with ID: ${app2.appId}`)\n\n  console.log('Creating App 3...')\n  const app3 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify(creationMetadata)),\n    lease: new Uint8Array([3])\n  })\n  console.log(`  \u2705 App 3 created with ID: ${app3.appId}\\n`)\n\n  // Wait for indexer to catch up\n  console.log('Waiting for indexer to index the transactions...')\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  // Retrieve apps by name\n  const apps = await algorand.appDeployer.getCreatorAppsByName(testAccount.addr)\n\n  console.log('\\n\ud83d\udccb Retrieved apps by name:')\n  const retrievedApp = apps.apps[appName]\n  \n  if (retrievedApp) {\n    console.log(`\\n\ud83d\udd0d Checking which app is returned for name '${appName}':`)\n    console.log(`  App 1 ID: ${app1.appId} - ${retrievedApp.appId === app1.appId ? '\u274c' : '\u2705'} Not returned`)\n    console.log(`  App 2 ID: ${app2.appId} - ${retrievedApp.appId === app2.appId ? '\u274c' : '\u2705'} Not returned`)\n    console.log(`  App 3 ID: ${app3.appId} - ${retrievedApp.appId === app3.appId ? '\u2705' : '\u274c'} RETURNED (Latest)`)\n    \n    console.log(`\\n\u2705 Result: getCreatorAppsByName returns the LATEST app created with name '${appName}'`)\n    console.log(`   Retrieved App ID: ${retrievedApp.appId}`)\n  } else {\n    console.log(`\u274c App '${appName}' not found in retrieved apps`)\n  }\n\n  console.log(`\\n\ud83d\udca1 Key Takeaway: When multiple apps share the same name, only the most`)\n  console.log(`   recently created app is returned by getCreatorAppsByName.`)\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "128-search-transactions-with-filters-and-pagination",
      "title": "Search Transactions with Filters and Pagination",
      "summary": "Demonstrates how to search for transactions using the Algorand Indexer with filters (transaction type, address role) and pagination support.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Search for transactions with specific criteria (payment transactions from a specific sender) using pagination",
      "target_users": [
        "SDK developers",
        "Application developers",
        "Transaction monitoring systems",
        "Analytics platforms"
      ],
      "features_tested": [
        "indexer.searchTransactions",
        "transaction filtering",
        "pagination",
        "filtering by transaction type",
        "filtering by address role"
      ],
      "feature_tags": [
        "indexer",
        "transaction-search",
        "pagination",
        "filtering",
        "payment-transaction",
        "address-role",
        "localnet"
      ],
      "folder": "128-search-transactions-with-filters-and-pagination",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost:8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Transaction 1 sent: <tx_id> (1 microAlgo from testAccount)",
        "Transaction 2 sent: <tx_id> (2 microAlgos from testAccount)",
        "Transaction 3 sent: <tx_id> (1 microAlgo from secondAccount)",
        "Total Transactions Found: 2",
        "Search filters working correctly!",
        "Found exactly the transactions from testAccount",
        "Filtered out transactions from secondAccount"
      ],
      "source_tests": [
        {
          "file": "src/indexer-lookup.spec.ts",
          "test_name": "Transactions are searched with pagination"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example showcases the power of the Algorand Indexer for filtering and searching transactions. The search capability supports multiple filters including transaction type, address role (sender/receiver), specific addresses, and pagination for handling large result sets. This is essential for building transaction monitoring systems, analytics platforms, and wallet applications.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport { searchTransactions } from '@algorandfoundation/algokit-utils/types/indexer'\n\n/**\n * Example: Search Transactions with Filters and Pagination\n * \n * This example demonstrates how to:\n * 1. Send multiple payment transactions from different accounts\n * 2. Wait for the indexer to index the transactions\n * 3. Search for transactions with specific filters:\n *    - Transaction type (payment)\n *    - Address role (sender)\n *    - Specific sender address\n * 4. Use pagination to retrieve results\n */\n\nasync function searchTransactionsWithFilters() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get dispenser account for funding\n  const dispenser = await algorand.account.dispenser()\n  \n  // Create test accounts\n  const testAccount = await algorand.account.random()\n  const secondAccount = await algorand.account.random()\n  const receiver = await algorand.account.random()\n  \n  console.log('Setting up test accounts...')\n  console.log(`Test Account 1 (main sender): ${testAccount.addr}`)\n  console.log(`Test Account 2 (secondary sender): ${secondAccount.addr}`)\n  console.log(`Receiver Account: ${receiver.addr}`)\n  \n  // Fund both sender accounts\n  console.log('\\nFunding test accounts...')\n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: testAccount.addr,\n    amount: algosdk.algosToMicroalgos(10),\n  })\n  \n  await algorand.send.payment({\n    sender: dispenser.addr,\n    receiver: secondAccount.addr,\n    amount: algosdk.algosToMicroalgos(10),\n  })\n  \n  console.log('Accounts funded successfully')\n  \n  // Send multiple test transactions\n  console.log('\\nSending test transactions...')\n  \n  // Transaction 1: 1 microAlgo from testAccount\n  const result1 = await algorand.send.payment({\n    sender: testAccount.addr,\n    receiver: receiver.addr,\n    amount: 1n,\n    signer: testAccount,\n  })\n  const txId1 = result1.transaction.txID()\n  console.log(`Transaction 1 sent: ${txId1} (1 microAlgo from testAccount)`)\n  \n  // Transaction 2: 2 microAlgos from testAccount\n  const result2 = await algorand.send.payment({\n    sender: testAccount.addr,\n    receiver: receiver.addr,\n    amount: 2n,\n    signer: testAccount,\n  })\n  const txId2 = result2.transaction.txID()\n  console.log(`Transaction 2 sent: ${txId2} (2 microAlgos from testAccount)`)\n  \n  // Transaction 3: 1 microAlgo from secondAccount (this should be filtered out)\n  const result3 = await algorand.send.payment({\n    sender: secondAccount.addr,\n    receiver: receiver.addr,\n    amount: 1n,\n    signer: secondAccount,\n  })\n  const txId3 = result3.transaction.txID()\n  console.log(`Transaction 3 sent: ${txId3} (1 microAlgo from secondAccount)`)\n  \n  // Wait for indexer to catch up and index all transactions\n  console.log('\\nWaiting for indexer to index transactions...')\n  await new Promise(resolve => setTimeout(resolve, 3000))\n  \n  // Search for transactions with filters:\n  // - Type: payment transactions only\n  // - Address role: sender\n  // - Address: testAccount (filter out secondAccount transactions)\n  console.log('\\nSearching for payment transactions from testAccount...')\n  \n  const searchResults = await searchTransactions(\n    algorand.client.indexer,\n    (s) => s\n      .txType('pay')  // Filter by transaction type: payment\n      .addressRole('sender')  // Filter by address role: sender\n      .address(testAccount.addr),  // Filter by specific sender address\n    1  // Page size/limit\n  )\n  \n  // Display search results\n  console.log('\\n=== Search Results ===')\n  console.log(`Current Round: ${searchResults.currentRound}`)\n  console.log(`Total Transactions Found: ${searchResults.transactions.length}`)\n  \n  console.log('\\nTransaction Details:')\n  searchResults.transactions.forEach((txn, index) => {\n    console.log(`\\n  Transaction ${index + 1}:`)\n    console.log(`    ID: ${txn.id}`)\n    console.log(`    Sender: ${txn.sender}`)\n    console.log(`    Receiver: ${txn['payment-transaction']?.receiver}`)\n    console.log(`    Amount: ${txn['payment-transaction']?.amount} microAlgos`)\n    console.log(`    Round: ${txn['confirmed-round']}`)\n    console.log(`    Type: ${txn['tx-type']}`)\n  })\n  \n  // Verify that we found the correct transactions\n  const foundTxIds = searchResults.transactions.map(t => t.id).sort()\n  const expectedTxIds = [txId1, txId2].sort()\n  \n  console.log('\\n=== Verification ===')\n  console.log(`Expected transaction IDs: ${expectedTxIds.join(', ')}`)\n  console.log(`Found transaction IDs: ${foundTxIds.join(', ')}`)\n  \n  const allFound = expectedTxIds.every(id => foundTxIds.includes(id))\n  const noExtras = foundTxIds.every(id => expectedTxIds.includes(id))\n  \n  if (allFound && noExtras) {\n    console.log('\\n\u2713 Search filters working correctly!')\n    console.log('\u2713 Found exactly the transactions from testAccount')\n    console.log('\u2713 Filtered out transactions from secondAccount')\n  } else {\n    console.log('\\n\u2717 Search results do not match expected transactions')\n  }\n}\n\n// Run the example\nsearchTransactionsWithFilters().catch(console.error)"
    },
    {
      "example_id": "129-simulate-transaction-group-before-sending",
      "title": "Simulate Transaction Group Before Sending",
      "summary": "Demonstrates how to simulate a transaction group before actually sending it to the network. This is useful for testing, validation, and estimating costs without committing transactions to the blockchain.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction simulation",
      "specific_use_case": "Simulate a transaction group and compare results with actual execution",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.newGroup",
        "simulate",
        "send",
        "transaction groups",
        "addAppCallMethodCall",
        "addPayment"
      ],
      "feature_tags": [
        "transaction-group",
        "simulation",
        "testing",
        "abi-method-call",
        "payment",
        "group-transactions"
      ],
      "folder": "129-simulate-transaction-group-before-sending",
      "prerequisites": {
        "tools": [
          "algokit",
          "node"
        ],
        "libraries": [
          "@algorand/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorand/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "App deployed with ID",
        "Simulation Results",
        "Number of transactions: 3",
        "Actual Send Results",
        "Transaction counts match: true",
        "Return values match: true",
        "Simulation and actual execution produced consistent results"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "simulated transaction group result should match sent transaction group result"
        }
      ],
      "artifacts_plan": [],
      "notes": "Transaction simulation is a powerful feature for testing and validation. It allows you to preview the effects of transactions without actually committing them to the blockchain. This is especially useful for complex transaction groups involving multiple app calls and payments.",
      "generated_code": "import { AlgorandClient } from '@algorand/algokit-utils';\nimport { algorandFixture } from '@algorand/algokit-utils/testing';\nimport algosdk from 'algosdk';\nimport { microAlgos } from '@algorand/algokit-utils';\n\n/**\n * This example demonstrates how to simulate a transaction group before sending it.\n * Simulation allows you to:\n * - Test transaction logic without committing to the blockchain\n * - Estimate costs and resource requirements\n * - Validate transaction results before execution\n * - Debug smart contract behavior\n */\n\nasync function main() {\n  // Setup: Initialize Algorand client and get test account\n  const localnet = algorandFixture();\n  await localnet.beforeEach();\n  const { testAccount } = localnet.context;\n  const algorand = localnet.context.algorand;\n\n  console.log('=== Transaction Group Simulation Example ===\\n');\n\n  // Step 1: Deploy an app (for this example, assume we have an app deployed)\n  console.log('Step 1: Setting up application...');\n  // You would replace this with your actual app deployment\n  const appClient = algorand.client.getAppClient({\n    appSpec: {\n      // Your app spec here - this should include the methods we're calling\n      hints: {},\n      source: { approval: '', clear: '' },\n      state: { global: { num_byte_slices: 0, num_uints: 0 }, local: { num_byte_slices: 0, num_uints: 0 } },\n      schema: { global: { declared: {}, reserved: {} }, local: { declared: {}, reserved: {} } },\n      contract: { \n        name: 'TestApp', \n        methods: [\n          { name: 'set_global', args: [], returns: { type: 'void' } },\n          { name: 'call_abi', args: [], returns: { type: 'string' } }\n        ] \n      }\n    },\n    sender: testAccount,\n  });\n  \n  await appClient.deploy();\n  const appId = appClient.appId;\n  console.log(`App deployed with ID: ${appId}\\n`);\n\n  // Step 2: Define transaction group parameters\n  console.log('Step 2: Defining transaction group...');\n  \n  // First transaction: ABI method call to set global state\n  const appCall1Params = {\n    sender: testAccount,\n    appId: appId,\n    method: algosdk.ABIMethod.fromSignature('set_global(uint64,uint64,string,byte[4])void'),\n    args: [1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])],\n  };\n  console.log('  - App call 1: set_global method');\n\n  // Second transaction: Payment transaction\n  const paymentParams = {\n    sender: testAccount,\n    receiver: testAccount,\n    amount: microAlgos(10000), // 0.01 ALGO\n  };\n  console.log('  - Payment: 0.01 ALGO');\n\n  // Third transaction: ABI method call\n  const appCall2Params = {\n    sender: testAccount,\n    appId: appId,\n    method: algosdk.ABIMethod.fromSignature('call_abi(string)string'),\n    args: ['test'],\n  };\n  console.log('  - App call 2: call_abi method\\n');\n\n  // Step 3: Simulate the transaction group\n  console.log('Step 3: Simulating transaction group...');\n  const simulateResult = await algorand\n    .newGroup()\n    .addAppCallMethodCall(appCall1Params)\n    .addPayment(paymentParams)\n    .addAppCallMethodCall(appCall2Params)\n    .simulate({ skipSignatures: true });\n\n  console.log('\\n=== Simulation Results ===');\n  console.log(`Number of transactions: ${simulateResult.transactions.length}`);\n  console.log(`Number of returns: ${simulateResult.returns?.length || 0}`);\n  if (simulateResult.returns && simulateResult.returns.length > 0) {\n    console.log('Return values:');\n    simulateResult.returns.forEach((ret, idx) => {\n      console.log(`  Return ${idx}: ${ret}`);\n    });\n  }\n\n  // Step 4: Send the actual transaction group\n  console.log('\\nStep 4: Sending actual transaction group...');\n  const sendResult = await algorand\n    .newGroup()\n    .addAppCallMethodCall(appCall1Params)\n    .addPayment(paymentParams)\n    .addAppCallMethodCall(appCall2Params)\n    .send();\n\n  console.log('\\n=== Actual Send Results ===');\n  console.log(`Number of transactions: ${sendResult.transactions.length}`);\n  console.log(`Number of returns: ${sendResult.returns?.length || 0}`);\n  if (sendResult.returns && sendResult.returns.length > 0) {\n    console.log('Return values:');\n    sendResult.returns.forEach((ret, idx) => {\n      console.log(`  Return ${idx}: ${ret}`);\n    });\n  }\n\n  // Step 5: Compare results\n  console.log('\\n=== Comparison ===');\n  console.log(`Transaction counts match: ${simulateResult.transactions.length === sendResult.transactions.length}`);\n  console.log(`Return counts match: ${simulateResult.returns?.length === sendResult.returns?.length}`);\n  \n  if (simulateResult.returns && sendResult.returns) {\n    const returnsMatch = simulateResult.returns.every((ret, idx) => \n      JSON.stringify(ret) === JSON.stringify(sendResult.returns![idx])\n    );\n    console.log(`Return values match: ${returnsMatch}`);\n  }\n\n  console.log('\\n\u2705 Simulation and actual execution produced consistent results!');\n  console.log('\\nKey Takeaway: Use simulate() to test transaction groups before committing them to the blockchain.');\n\n  // Cleanup\n  await localnet.afterEach();\n}\n\nmain().catch(console.error);"
    },
    {
      "example_id": "130-smart-contract-deployment-with-abi-method-call",
      "title": "Smart Contract Deployment with ABI Method Call",
      "summary": "Shows how to deploy a smart contract application using an ABI method call for initialization. This enables typed contract creation with proper method signatures.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create a new smart contract application using an ABI method call",
      "target_users": [
        "Smart contract developers",
        "dApp developers"
      ],
      "features_tested": [
        "algorand.send.appCreateMethodCall",
        "ABIContract",
        "program compilation"
      ],
      "feature_tags": [
        "app-creation",
        "abi-method-calls",
        "smart-contracts",
        "program-compilation",
        "typed-contracts",
        "app-deployment"
      ],
      "folder": "130-smart-contract-deployment-with-abi-method-call",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALICE_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic phrase here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Place your application.json file in the same directory as main.ts"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Approval and clear state programs compiled successfully",
        "Smart contract deployed with App ID",
        "Application information including creator address and state schemas"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "methodCall create"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "application.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Sample application specification file with ABI contract definition and TEAL source code"
        }
      ],
      "notes": "You'll need a valid application specification (application.json) with contract ABI definition and TEAL source code. The example assumes the app spec has a 'createApplication' method defined.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\n/**\n * This example demonstrates how to deploy a smart contract application\n * using an ABI method call for initialization.\n * \n * Using ABI methods provides type safety and ensures the correct\n * arguments are passed during contract creation.\n */\nasync function deploySmartContractWithABI() {\n  // Initialize the Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a funded account\n  const alice = await algorand.account.fromEnvironment('ALICE')\n  \n  console.log('Loading application specification...')\n  \n  // Load the application specification (app spec)\n  // The app spec contains the ABI contract definition and TEAL source code\n  const appSpecPath = path.join(__dirname, 'application.json')\n  const appSpec = JSON.parse(fs.readFileSync(appSpecPath, 'utf-8'))\n  \n  // Create an ABI contract instance from the app spec\n  const contract = new algosdk.ABIContract(appSpec.contract)\n  \n  console.log(`\\nFound creation method: ${contract.getMethodByName('createApplication').name}`)\n  \n  // Helper function to compile TEAL programs\n  async function compileProgram(source: string): Promise<Uint8Array> {\n    const algod = algorand.client.algod\n    const result = await algod.compile(source).do()\n    return new Uint8Array(Buffer.from(result.result, 'base64'))\n  }\n  \n  console.log('\\nCompiling approval program...')\n  const approvalProgram = await compileProgram(appSpec.source.approval)\n  console.log('\u2713 Approval program compiled')\n  \n  console.log('Compiling clear state program...')\n  const clearStateProgram = await compileProgram(appSpec.source.clear)\n  console.log('\u2713 Clear state program compiled')\n  \n  console.log('\\nDeploying smart contract...')\n  \n  // Deploy the smart contract using an ABI method call\n  const result = await algorand.send.appCreateMethodCall({\n    sender: alice,\n    method: contract.getMethodByName('createApplication'),\n    approvalProgram: approvalProgram,\n    clearStateProgram: clearStateProgram,\n  })\n  \n  const appId = result.appId\n  console.log(`\\n\u2713 Smart contract deployed successfully!`)\n  console.log(`  App ID: ${appId}`)\n  console.log(`  Transaction ID: ${result.txIds[0]}`)\n  \n  // Get application information\n  const algod = algorand.client.algod\n  const appInfo = await algod.getApplicationByID(Number(appId)).do()\n  \n  console.log('\\nApplication Information:')\n  console.log(`  Creator: ${appInfo.params.creator}`)\n  console.log(`  Global State Schema: ${appInfo.params['global-state-schema']?.['num-uint']} uints, ${appInfo.params['global-state-schema']?.['num-byte-slice']} byte slices`)\n  console.log(`  Local State Schema: ${appInfo.params['local-state-schema']?.['num-uint']} uints, ${appInfo.params['local-state-schema']?.['num-byte-slice']} byte slices`)\n  \n  console.log('\\n\u2713 Smart contract deployment completed!')\n}\n\n// Run the example\ndeploySmartContractWithABI().catch(console.error)"
    },
    {
      "example_id": "131-update-application-with-abi-update-method",
      "title": "Update Application with ABI Update Method",
      "summary": "Demonstrates how to update an existing application using an ABI update method with arguments. Shows the complete update workflow including method invocation, return value capture, and operation verification.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Update an existing application using an ABI update method",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.deploy",
        "updateArgs with ABI method",
        "onUpdate",
        "OnApplicationComplete.UpdateApplicationOC",
        "return value from update method",
        "operationPerformed detection"
      ],
      "feature_tags": [
        "app-client",
        "update",
        "abi",
        "update-method",
        "return-values",
        "on-complete"
      ],
      "folder": "131-update-application-with-abi-update-method",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have an app spec JSON file with an 'update_abi' method"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Setting up app client...",
        "=== INITIAL DEPLOYMENT ===",
        "Creating application with VALUE=1...",
        "\u2705 Application created",
        "=== UPDATING WITH ABI METHOD ===",
        "Updating application with VALUE=2 and calling update_abi method...",
        "\u2705 Update operation performed successfully",
        "App Identity:",
        "  App ID: <number> (same: true)",
        "\u2705 Transaction type confirmed as UpdateApplication",
        "\u2705 Return value from update_abi method: arg_io",
        "\u2705 Application successfully updated with ABI method"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - update (abi)"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app_spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "User needs to provide their own app spec with an 'update_abi' method that accepts a string argument and returns a string"
        }
      ],
      "notes": "This example requires an application specification with an ABI update method. The update method allows you to execute custom logic during the update operation, such as state migrations or validation. The method can accept arguments and return values, making updates more flexible and programmable.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\nimport { OnApplicationComplete } from 'algosdk'\n\n// This example demonstrates updating an application using an ABI update method\n// The update method can accept arguments and return values\n\nasync function updateAppWithAbiMethod() {\n  // Initialize AlgoKit and get clients\n  const algod = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('algod'))\n  const indexer = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('indexer'))\n  const account = await algokit.getLocalNetDispenserAccount(algod)\n\n  // Load your application specification\n  const appSpec = '<YOUR_APP_SPEC>' // Replace with your actual app spec\n\n  console.log('Setting up app client...')\n  \n  // Create an app client\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: account,\n      creatorAddress: account.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  console.log('\\n=== INITIAL DEPLOYMENT ===')\n  console.log('Creating application with VALUE=1...')\n  \n  // First deployment - create the application\n  const createdApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    allowUpdate: true, // Must allow updates\n  })\n\n  console.log(`\u2705 Application created`)\n  console.log(`App ID: ${createdApp.appId}`)\n  console.log(`Created in Round: ${createdApp.createdRound}`)\n\n  console.log('\\n=== UPDATING WITH ABI METHOD ===')\n  console.log('Updating application with VALUE=2 and calling update_abi method...')\n  \n  // Second deployment - update with ABI method\n  const updatedApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 2, // Updated parameter\n    },\n    onUpdate: 'update', // Perform an update\n    updateArgs: {\n      // Specify the ABI method to call during update\n      method: 'update_abi', // Name of your ABI update method\n      methodArgs: ['arg_io'], // Arguments to pass to the update method\n    },\n  })\n\n  // Verify the update operation\n  if (updatedApp.operationPerformed === 'update') {\n    console.log('\u2705 Update operation performed successfully')\n    \n    // Verify it's the same app\n    console.log(`\\nApp Identity:`)\n    console.log(`  App ID: ${updatedApp.appId} (same: ${updatedApp.appId === createdApp.appId})`)\n    console.log(`  App Address: ${updatedApp.appAddress} (same: ${updatedApp.appAddress === createdApp.appAddress})`)\n    \n    // Check round information\n    console.log(`\\nRound Information:`)\n    console.log(`  Created in Round: ${updatedApp.createdRound}`)\n    console.log(`  Updated in Round: ${updatedApp.updatedRound}`)\n    console.log(`  Rounds are different: ${updatedApp.updatedRound !== updatedApp.createdRound}`)\n    \n    // Verify the transaction type\n    if (updatedApp.transaction.applicationCall?.onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      console.log('\\n\u2705 Transaction type confirmed as UpdateApplication')\n    }\n    \n    // Display the return value from the update method\n    if (updatedApp.return?.returnValue) {\n      console.log(`\\n\u2705 Return value from update_abi method: ${updatedApp.return.returnValue}`)\n    }\n    \n    console.log('\\n\u2705 Application successfully updated with ABI method')\n  } else {\n    console.log(`\u26a0\ufe0f  Expected update but got: ${updatedApp.operationPerformed}`)\n  }\n\n  return { createdApp, updatedApp }\n}\n\n// Run the example\nupdateAppWithAbiMethod()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "132-update-application-with-deploy-time-parameters",
      "title": "Update Application with Deploy-Time Parameters",
      "summary": "Demonstrates idempotent application deployment and how to update an existing application with new deploy-time parameters. Shows operation detection, round tracking, and the difference between create and update operations.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Update an existing application with new deploy-time parameters",
      "target_users": [
        "SDK developers",
        "DevOps engineers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.deploy",
        "allowUpdate",
        "onUpdate",
        "operationPerformed",
        "updatedRound vs createdRound",
        "idempotent deployment"
      ],
      "feature_tags": [
        "app-client",
        "deployment",
        "update",
        "idempotent",
        "deploy-time-params",
        "round-tracking"
      ],
      "folder": "132-update-application-with-deploy-time-parameters",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have an app spec JSON file from your smart contract"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Setting up app client...",
        "=== INITIAL DEPLOYMENT ===",
        "Deploying application with VALUE=1...",
        "Operation performed: create",
        "App ID: <number>",
        "=== UPDATING APPLICATION ===",
        "Deploying again with VALUE=2...",
        "Operation performed: update",
        "\u2705 Application was updated (not recreated)",
        "Round Information:",
        "  Created in Round: <round1>",
        "  Updated in Round: <round2>",
        "\u2705 Deploy-time parameter VALUE was updated from 1 to 2"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - update"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "app_spec.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "User needs to provide their own app spec with deploy-time parameters (template variables)"
        }
      ],
      "notes": "This example demonstrates idempotent deployment where the deploy() method intelligently determines whether to create or update an application. The allowUpdate flag must be set to true during initial deployment to allow future updates. Deploy-time parameters are template variables in TEAL code that can be customized at deployment time.",
      "generated_code": "import * as algokit from '@algorandfoundation/algokit-utils'\n\n// This example demonstrates updating an existing application with new deploy-time parameters\n// It shows idempotent deployment - deploy() can create or update based on the situation\n\nasync function updateApplicationWithDeployParams() {\n  // Initialize AlgoKit and get clients\n  const algod = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('algod'))\n  const indexer = algokit.getAlgoClient(algokit.getDefaultLocalNetConfig('indexer'))\n  const account = await algokit.getLocalNetDispenserAccount(algod)\n\n  // Load your application specification\n  const appSpec = '<YOUR_APP_SPEC>' // Replace with your actual app spec\n\n  console.log('Setting up app client...')\n  \n  // Create an app client\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: account,\n      creatorAddress: account.addr,\n      findExistingUsing: indexer,\n    },\n    algod,\n  )\n\n  console.log('\\n=== INITIAL DEPLOYMENT ===')\n  console.log('Deploying application with VALUE=1...')\n  \n  // First deployment - create the application\n  const createdApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 1, // Initial deploy-time parameter\n    },\n    allowUpdate: true, // Allow future updates\n  })\n\n  console.log(`Operation performed: ${createdApp.operationPerformed}`)\n  console.log(`App ID: ${createdApp.appId}`)\n  console.log(`App Address: ${createdApp.appAddress}`)\n  console.log(`Created in Round: ${createdApp.createdRound}`)\n\n  console.log('\\n=== UPDATING APPLICATION ===')\n  console.log('Deploying again with VALUE=2...')\n  \n  // Second deployment - update the existing application\n  const updatedApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 2, // Updated deploy-time parameter\n    },\n    onUpdate: 'update', // Specify what to do on update\n  })\n\n  console.log(`Operation performed: ${updatedApp.operationPerformed}`)\n  \n  // Verify this was an update, not a new creation\n  if (updatedApp.operationPerformed === 'update') {\n    console.log('\u2705 Application was updated (not recreated)')\n    console.log(`App ID remains: ${updatedApp.appId}`)\n    console.log(`App Address remains: ${updatedApp.appAddress}`)\n    console.log(`\\nRound Information:`)\n    console.log(`  Created in Round: ${updatedApp.createdRound}`)\n    console.log(`  Updated in Round: ${updatedApp.updatedRound}`)\n    \n    // Verify the app ID didn't change\n    if (updatedApp.appId === createdApp.appId) {\n      console.log('\u2705 App ID unchanged (same app)')\n    }\n    \n    // Verify the address didn't change\n    if (updatedApp.appAddress === createdApp.appAddress) {\n      console.log('\u2705 App address unchanged (same app)')\n    }\n    \n    // Verify the created round is the same but updated round is different\n    if (updatedApp.createdRound === createdApp.createdRound) {\n      console.log('\u2705 Created round unchanged')\n    }\n    \n    if (updatedApp.updatedRound !== updatedApp.createdRound) {\n      console.log('\u2705 Updated round is different from created round')\n    }\n    \n    console.log(`\\n\u2705 Deploy-time parameter VALUE was updated from 1 to 2`)\n  } else {\n    console.log(`\u26a0\ufe0f  Expected update but got: ${updatedApp.operationPerformed}`)\n  }\n\n  return { createdApp, updatedApp }\n}\n\n// Run the example\nupdateApplicationWithDeployParams()\n  .then(() => {\n    console.log('\\n\u2705 Example completed successfully')\n    process.exit(0)\n  })\n  .catch((error) => {\n    console.error('\u274c Error:', error)\n    process.exit(1)\n  })"
    },
    {
      "example_id": "133-update-a-deployed-updatable-application",
      "title": "Update a Deployed Updatable Application",
      "summary": "Demonstrates how to deploy an initial version of an updatable app, then deploy an update with new code and version metadata, maintaining the same app ID throughout the update process.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Deploy an updatable app, then deploy an update with new code and version, verifying the same app ID is updated",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "algorand.appDeployer.deploy",
        "App update with onUpdate='update'",
        "Version management",
        "Idempotent deployment"
      ],
      "feature_tags": [
        "app-deployment",
        "app-update",
        "updatable-apps",
        "version-management",
        "idempotent-deployment",
        "metadata"
      ],
      "folder": "133-update-a-deployed-updatable-application",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundry/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundry/algokit-utils algosdk"
        ],
        "execute": [
          "ts-node main.ts"
        ]
      },
      "expected_output": [
        "Initial deployment creates a new app with version 1.0",
        "Update deployment maintains the same app ID",
        "Version is updated to 2.0",
        "Updated round number reflects the update transaction",
        "App metadata shows updatable=true and deleted=false"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Deploy update to updatable updated app"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example requires a running LocalNet instance. The helper functions for generating approval and clear programs are simplified for demonstration purposes. In production, you would typically load pre-compiled TEAL programs or use a smart contract framework.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundry/algokit-utils'\nimport { consoleLogger } from '@algorandfoundry/algokit-utils/types/logging'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates how to update an existing updatable application.\n * \n * Key concepts:\n * - Deploy an initial version of an updatable app\n * - Deploy an update with new code and version metadata\n * - The same app ID is maintained across updates\n * - Using onUpdate='update' to perform the update operation\n */\n\nasync function updateDeployedApp() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  algorand.setLogger(consoleLogger)\n\n  // Get a test account with funds from LocalNet\n  const sender = await algorand.account.localNet.dispenser()\n\n  console.log('=== Deploying Initial Version of Updatable App ===')\n  \n  // Define initial app metadata with updatable flag set to true\n  const initialMetadata = {\n    name: 'MyUpdatableApp',\n    version: '1.0',\n    updatable: true,\n    deletable: false,\n  }\n\n  // Deploy the initial version\n  const deployment1 = {\n    sender: sender.addr,\n    metadata: initialMetadata,\n    // In a real scenario, you would provide your approval and clear programs\n    approvalProgram: await getApprovalProgram(1), // Version 1 code\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n  }\n\n  const result1 = await algorand.appDeployer.deploy(deployment1)\n\n  if ('transaction' in result1) {\n    console.log(`\u2713 Initial deployment successful`)\n    console.log(`  App ID: ${result1.appId}`)\n    console.log(`  Version: ${result1.version}`)\n    console.log(`  Created Round: ${result1.createdRound}`)\n    console.log(`  Transaction ID: ${result1.transaction.txID()}`)\n  }\n\n  // Wait for indexer to catch up\n  await new Promise(resolve => setTimeout(resolve, 2000))\n\n  console.log('\\n=== Deploying Update (Version 2.0) ===')\n\n  // Define updated metadata with new version\n  const updatedMetadata = {\n    ...initialMetadata,\n    version: '2.0',\n  }\n\n  // Deploy the update with new code\n  const deployment2 = {\n    sender: sender.addr,\n    metadata: updatedMetadata,\n    approvalProgram: await getApprovalProgram(2), // Version 2 code (different)\n    clearStateProgram: await getClearProgram(),\n    schema: {\n      globalUints: 1,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0,\n    },\n    // Specify onUpdate='update' to update the existing app\n    onUpdate: 'update' as const,\n  }\n\n  const result2 = await algorand.appDeployer.deploy(deployment2)\n\n  if ('transaction' in result2 && result2.confirmation) {\n    console.log(`\u2713 Update deployment successful`)\n    console.log(`  App ID: ${result2.appId} (same as before: ${result1.appId === result2.appId})`)\n    console.log(`  Version: ${result2.version}`)\n    console.log(`  Updated Round: ${result2.updatedRound}`)\n    console.log(`  Transaction ID: ${result2.transaction.txID()}`)\n    console.log(`\\n  Metadata:`)    \n    console.log(`    - Updatable: ${result2.updatable}`)\n    console.log(`    - Deletable: ${result2.deletable}`)\n    console.log(`    - Deleted: ${result2.deleted}`)\n  }\n\n  console.log('\\n=== Summary ===')\n  console.log(`The app was successfully updated from v${result1.version} to v${result2.version}`)\n  console.log(`The app ID remained constant: ${result2.appId}`)\n  console.log(`This demonstrates idempotent deployment with update capability.`)\n}\n\n/**\n * Helper function to generate approval program\n * In a real application, this would load your TEAL code or compiled program\n */\nasync function getApprovalProgram(version: number): Promise<Uint8Array> {\n  // Simple approval program that stores a value (version) in global state\n  const tealCode = `#pragma version 10\n  txn ApplicationID\n  int 0\n  ==\n  bnz create\n  \n  txn OnCompletion\n  int UpdateApplication\n  ==\n  bnz update\n  \n  int 1\n  return\n  \n  create:\n  byte \"version\"\n  int ${version}\n  app_global_put\n  int 1\n  return\n  \n  update:\n  byte \"version\"\n  int ${version}\n  app_global_put\n  int 1\n  return`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n/**\n * Helper function to generate clear state program\n */\nasync function getClearProgram(): Promise<Uint8Array> {\n  const tealCode = `#pragma version 10\n  int 1`\n  \n  const client = algosdk.makeApplicationClient(\n    algosdk.algodClient('http://localhost', 4001, 'a'.repeat(64))\n  )\n  const compiled = await algosdk.compileProgram(client, tealCode)\n  return compiled.compiledProgram\n}\n\n// Run the example\nupdateDeployedApp().catch(console.error)"
    },
    {
      "example_id": "134-use-custom-signers-in-atomic-transaction-groups",
      "title": "Use Custom Signers in Atomic Transaction Groups",
      "summary": "Demonstrates how to use custom transaction signers to control signing behavior in atomic transaction groups, including using different signers for different transactions",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Control transaction signing in atomic groups with custom signers",
      "target_users": [
        "SDK developers",
        "Wallet developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "custom TransactionSigner",
        "transaction signing",
        "atomic transactions",
        "multi-account transactions",
        "transaction with custom signer"
      ],
      "feature_tags": [
        "transaction-signing",
        "custom-signer",
        "atomic-transactions",
        "transaction-groups",
        "multi-account",
        "abi",
        "app-client"
      ],
      "folder": "134-use-custom-signers-in-atomic-transaction-groups",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "SENDER_MNEMONIC",
            "required": true,
            "example": "your 25-word mnemonic here"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy your smart contract with the 'call_abi_txn' method",
          "Update YOUR_APP_ID in the code with your deployed app ID"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "=== Example 1: Custom Signer for All Transactions ===",
        "Custom signer called to sign transactions at indexes: [0, 1]",
        "Signed transactions at indexes: 0,1",
        "Both transactions in the atomic group were signed by the custom signer",
        "=== Example 2: Different Signers for Different Transactions ===",
        "Creating and funding a second account...",
        "Second account created: [address]",
        "Calling ABI method with different signer for payment transaction...",
        "Success! Transactions were signed by different accounts",
        "All examples completed successfully!"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Sign all transactions in group with abi call with transaction arg"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Sign transaction in group with different signer if provided"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract with call_abi_txn method that accepts a payment transaction and string"
        },
        {
          "target_file": "README.md",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Documentation explaining custom signers and multi-account atomic transactions"
        }
      ],
      "notes": "These patterns are crucial for wallet developers and applications that need fine-grained control over transaction signing. Example 1 shows how to intercept all signing operations, useful for logging or custom approval flows. Example 2 demonstrates multi-party atomic transactions where different participants sign different transactions.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport type { TransactionSigner } from 'algosdk'\n// Import your generated typed client\nimport { YourAppClient } from './artifacts/YourAppClient'\n\n/**\n * This example demonstrates two patterns for custom transaction signing:\n * 1. Using a custom signer to intercept and sign all transactions in a group\n * 2. Specifying different signers for individual transactions in an atomic group\n */\n\nasync function example1_customSignerForAllTransactions() {\n  console.log('\\n=== Example 1: Custom Signer for All Transactions ===')\n  \n  const algorand = AlgorandClient.defaultLocalNet()\n  const sender = await algorand.account.fromEnvironment('SENDER')\n  \n  // Create a payment transaction\n  const paymentTxn = await algorand.createTransaction.payment({\n    sender: sender.addr,\n    receiver: sender.addr,\n    amount: algokit.microAlgo(3000),\n  })\n  \n  // Initialize app client\n  const appClient = new YourAppClient(\n    {\n      resolveBy: 'id',\n      id: YOUR_APP_ID, // Replace with your deployed app ID\n      sender,\n    },\n    algorand.client.algod\n  )\n  \n  // Track which transaction indexes are signed\n  let signedIndexes: number[] = []\n  \n  // Create a custom signer that logs which transactions it signs\n  const customSigner: TransactionSigner = (transactionGroup, indexesToSign) => {\n    console.log(`Custom signer called to sign transactions at indexes: ${indexesToSign}`)\n    signedIndexes = indexesToSign\n    \n    // Delegate to the default signer after logging\n    return algorand.account.getSigner(sender.addr)(transactionGroup, indexesToSign)\n  }\n  \n  console.log('Calling ABI method with custom signer...')\n  \n  // Call the method with the custom signer\n  await appClient.send.call({\n    method: 'call_abi_txn',\n    args: [paymentTxn, 'test'],\n    sender: sender.addr,\n    signer: customSigner,\n  })\n  \n  console.log(`Signed transactions at indexes: ${signedIndexes}`)\n  console.log('Both transactions in the atomic group were signed by the custom signer')\n}\n\nasync function example2_differentSignersPerTransaction() {\n  console.log('\\n=== Example 2: Different Signers for Different Transactions ===')\n  \n  const algorand = AlgorandClient.defaultLocalNet()\n  const mainAccount = await algorand.account.fromEnvironment('SENDER')\n  \n  // Create a second account that will sign the payment transaction\n  console.log('Creating and funding a second account...')\n  const secondAccount = await algorand.account.random()\n  \n  // Fund the second account\n  await algorand.send.payment({\n    sender: mainAccount.addr,\n    receiver: secondAccount.addr,\n    amount: algokit.algo(1),\n  })\n  \n  console.log(`Second account created: ${secondAccount.addr}`)\n  \n  // Create a payment transaction from the second account\n  const paymentTxn = await algorand.createTransaction.payment({\n    sender: secondAccount.addr,\n    receiver: secondAccount.addr,\n    amount: algokit.microAlgo(2000),\n  })\n  \n  // Initialize app client with main account as sender\n  const appClient = new YourAppClient(\n    {\n      resolveBy: 'id',\n      id: YOUR_APP_ID, // Replace with your deployed app ID\n      sender: mainAccount,\n    },\n    algorand.client.algod\n  )\n  \n  console.log('Calling ABI method with different signer for payment transaction...')\n  \n  // Call the method, specifying a different signer for the payment transaction\n  // The main account will sign the app call, the second account will sign the payment\n  await appClient.send.call({\n    method: 'call_abi_txn',\n    args: [\n      {\n        txn: paymentTxn,\n        signer: secondAccount.signer, // Specify custom signer for this transaction\n      },\n      'test',\n    ],\n  })\n  \n  console.log('Success! Transactions were signed by different accounts:')\n  console.log(`  - Payment transaction signed by: ${secondAccount.addr}`)\n  console.log(`  - App call transaction signed by: ${mainAccount.addr}`)\n}\n\nasync function main() {\n  console.log('Custom Signers in Atomic Transaction Groups')\n  console.log('============================================')\n  \n  // Run both examples\n  await example1_customSignerForAllTransactions()\n  await example2_differentSignersPerTransaction()\n  \n  console.log('\\nAll examples completed successfully!')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "135-using-foreign-references-in-application-calls",
      "title": "Using Foreign References in Application Calls",
      "summary": "Demonstrates how to reference foreign apps, accounts, and assets when calling ABI methods, enabling cross-app interactions and access to external resources.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "app interaction",
      "specific_use_case": "Call an ABI method with foreign app, account, and asset references",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "DApp developers"
      ],
      "features_tested": [
        "client.call",
        "foreign references",
        "apps parameter",
        "accounts parameter",
        "assets parameter",
        "ABI return value decoding"
      ],
      "feature_tags": [
        "foreign-references",
        "cross-app-calls",
        "foreign-assets",
        "foreign-accounts",
        "abi-calls",
        "app-interaction"
      ],
      "folder": "135-using-foreign-references-in-application-calls",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Application deployed successfully",
        "Method called with foreign app, account, and asset references",
        "Return value showing the contract accessed the foreign references",
        "Explanation of how foreign references enable cross-app interactions"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Construct transaction with abi encoding including foreign references not in signature"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample contract with call_abi_foreign_refs method that accesses foreign apps, accounts, and assets and returns information about them"
        }
      ],
      "notes": "Foreign references are crucial for building composable smart contracts. Algorand limits transactions to referencing up to 8 foreign apps, 4 foreign accounts, and 8 foreign assets. This example shows the basic pattern that can be extended for more complex cross-app interactions.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { AppManager } from '@algorandfoundation/algokit-utils/types/app-manager'\n\n/**\n * This example demonstrates how to use foreign references (apps, accounts, assets)\n * when calling application methods. Foreign references allow your smart contract to:\n * - Read state from other applications\n * - Access account information beyond the sender\n * - Query asset parameters and holdings\n * - Perform cross-app interactions\n */\n\nasync function foreignReferencesExample() {\n  // Initialize AlgoKit and get clients\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n\n  // Get a test account\n  const testAccount = await algorand.account.localNetDispenser()\n  console.log(`Test account address: ${testAccount.addr}`)\n\n  // Deploy the application\n  console.log('\\nDeploying application...')\n  const { client } = await deployYourApp(testAccount, algod, indexer)\n  console.log('Application deployed successfully')\n\n  // Define foreign references to pass to the application\n  // These are resources external to the application that it needs to access\n  const foreignAppId = 345      // ID of another application\n  const foreignAssetId = 567     // ID of an asset (ASA)\n  const foreignAccount = testAccount.addr  // An account address\n\n  console.log('\\nCalling ABI method with foreign references:')\n  console.log(`  - Foreign App ID: ${foreignAppId}`)\n  console.log(`  - Foreign Asset ID: ${foreignAssetId}`)\n  console.log(`  - Foreign Account: ${foreignAccount}`)\n\n  // Call the ABI method with foreign references\n  // The apps, accounts, and assets arrays make these resources available to the contract\n  const result = await client.call({\n    method: 'call_abi_foreign_refs',\n    methodArgs: [],\n    apps: [foreignAppId],           // Foreign application references\n    accounts: [foreignAccount],     // Foreign account references\n    assets: [foreignAssetId],       // Foreign asset references\n  })\n\n  console.log('\\n\u2705 Method call successful!')\n  console.log(`Transaction ID: ${result.transactions[0].txID()}`)\n\n  // Decode and display the ABI return value\n  if (result.confirmations && result.confirmations[0]) {\n    const abiMethod = client.getABIMethod('call_abi_foreign_refs')\n    if (abiMethod) {\n      const returnValue = AppManager.getABIReturn(\n        result.confirmations[0],\n        abiMethod\n      )\n\n      console.log('\\nReturn value from contract:')\n      console.log(`  ${returnValue?.returnValue}`)\n\n      // The contract can now access these foreign references:\n      // - Read from the foreign app's global/local state\n      // - Get account balance, assets held, etc.\n      // - Query asset parameters (total supply, decimals, etc.)\n    }\n  }\n\n  console.log('\\nForeign references explained:')\n  console.log('  \u2022 apps[]: Allows reading state from other applications')\n  console.log('  \u2022 accounts[]: Provides access to account information')\n  console.log('  \u2022 assets[]: Enables querying asset parameters and holdings')\n  console.log('\\nThese references are essential for cross-app interactions and composability!')\n}\n\n// Helper function placeholder - replace with your actual app deployment\nasync function deployYourApp(account: any, algod: any, indexer: any) {\n  // This is a placeholder - implement your actual app deployment logic\n  // The app should have a method like:\n  // call_abi_foreign_refs() -> string\n  // that accesses the foreign references passed in the transaction\n  throw new Error('Implement your app deployment logic here')\n}\n\n// Run the example\nforeignReferencesExample().catch(console.error)"
    },
    {
      "example_id": "136-working-with-nested-abi-tuples-containing-byte-arrays",
      "title": "Working with Nested ABI Tuples Containing Byte Arrays",
      "summary": "Learn how to work with nested ABI tuples containing byte arrays. This example shows how to define complex nested tuple types and convert JavaScript values to properly typed ABI values for smart contract interactions.",
      "language": "typescript",
      "complexity": "moderate",
      "example_potential": "high",
      "use_case_category": "ABI type conversion",
      "specific_use_case": "Convert nested tuples with byte arrays (byte[2],(byte[1],bool)) for smart contract data preparation",
      "target_users": [
        "Smart contract developers",
        "SDK developers"
      ],
      "features_tested": [
        "convertAbiByteArrays",
        "ABITupleType",
        "ABIArrayStaticType",
        "ABIByteType",
        "ABIBoolType",
        "nested tuple conversion"
      ],
      "feature_tags": [
        "abi",
        "tuples",
        "nested-structures",
        "byte-arrays",
        "type-conversion",
        "smart-contracts",
        "algosdk"
      ],
      "folder": "136-working-with-nested-abi-tuples-containing-byte-arrays",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Nested tuple structure created successfully",
        "Outer tuple: byte[2] + (byte[1], bool)",
        "First element (byte[2]): Uint8Array containing [1, 2]",
        "Second element is a nested tuple with byte[1] and bool",
        "Nested tuple first element (byte[1]): Uint8Array containing [3]",
        "Nested tuple second element (bool): true"
      ],
      "source_tests": [
        {
          "file": "src/util.spec.ts",
          "test_name": "should handle nested tuples with byte arrays"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example demonstrates recursive tuple processing, which is essential for working with complex smart contract data structures. The convertAbiByteArrays function properly handles nested structures by recursively converting number arrays to Uint8Array instances.",
      "generated_code": "import {\n  ABIByteType,\n  ABIArrayStaticType,\n  ABITupleType,\n  ABIBoolType,\n  convertAbiByteArrays,\n  type ABIValue,\n} from '@algorandfoundation/algokit-utils'\n\n/**\n * Demonstrates working with nested ABI tuples containing byte arrays.\n * \n * This example shows how to:\n * 1. Define nested tuple types with byte arrays\n * 2. Convert JavaScript values to ABI-compatible types\n * 3. Handle complex nested structures for smart contract interactions\n * \n * The structure being created is: (byte[2],(byte[1],bool))\n * - Outer tuple contains a byte array and an inner tuple\n * - Inner tuple contains a byte array and a boolean\n */\n\nfunction main() {\n  console.log('=== Working with Nested ABI Tuples and Byte Arrays ===\\n')\n\n  // Step 1: Define the ABI types\n  console.log('Step 1: Defining ABI types...')\n  \n  // Basic byte type\n  const byteType = new ABIByteType()\n  \n  // Static array of 2 bytes: byte[2]\n  const byteArray2Type = new ABIArrayStaticType(byteType, 2)\n  \n  // Static array of 1 byte: byte[1]\n  const byteArray1Type = new ABIArrayStaticType(byteType, 1)\n  \n  // Boolean type\n  const boolType = new ABIBoolType()\n  \n  console.log('\u2713 Created basic types: byte, byte[2], byte[1], bool\\n')\n\n  // Step 2: Create nested tuple structure\n  console.log('Step 2: Creating nested tuple structure...')\n  \n  // Inner tuple: (byte[1], bool)\n  const innerTupleType = new ABITupleType([byteArray1Type, boolType])\n  console.log('\u2713 Created inner tuple type: (byte[1], bool)')\n  \n  // Outer tuple: (byte[2], (byte[1], bool))\n  const outerTupleType = new ABITupleType([byteArray2Type, innerTupleType])\n  console.log('\u2713 Created outer tuple type: (byte[2], (byte[1], bool))\\n')\n\n  // Step 3: Prepare the data\n  console.log('Step 3: Preparing data...')\n  const value = [\n    [1, 2],           // byte[2] - outer array\n    [[3], true],      // (byte[1], bool) - inner tuple\n  ]\n  console.log('Original value:', JSON.stringify(value), '\\n')\n\n  // Step 4: Convert to ABI format\n  console.log('Step 4: Converting to ABI format...')\n  const result = convertAbiByteArrays(value, outerTupleType) as ABIValue[]\n  console.log('\u2713 Conversion complete\\n')\n\n  // Step 5: Inspect the results\n  console.log('Step 5: Inspecting converted results...')\n  console.log('Result is an array:', Array.isArray(result))\n  console.log('Result length:', result.length)\n  console.log()\n\n  // Check first element (byte[2])\n  console.log('First element (byte[2]):')\n  console.log('  Type:', result[0].constructor.name)\n  console.log('  Values:', Array.from(result[0] as Uint8Array))\n  console.log('  \u2713 Correctly converted to Uint8Array')\n  console.log()\n\n  // Check second element (nested tuple)\n  const nestedTuple = result[1] as ABIValue[]\n  console.log('Second element (nested tuple):')\n  console.log('  Is array:', Array.isArray(nestedTuple))\n  console.log('  Length:', nestedTuple.length)\n  console.log()\n\n  // Check nested tuple elements\n  console.log('  First element of nested tuple (byte[1]):')\n  console.log('    Type:', nestedTuple[0].constructor.name)\n  console.log('    Values:', Array.from(nestedTuple[0] as Uint8Array))\n  console.log('    \u2713 Correctly converted to Uint8Array')\n  console.log()\n\n  console.log('  Second element of nested tuple (bool):')\n  console.log('    Type:', typeof nestedTuple[1])\n  console.log('    Value:', nestedTuple[1])\n  console.log('    \u2713 Boolean value preserved')\n  console.log()\n\n  console.log('=== Summary ===')\n  console.log('\u2713 Successfully created and converted nested tuple structure')\n  console.log('\u2713 Byte arrays properly converted to Uint8Array instances')\n  console.log('\u2713 Nested structure maintained with correct types')\n  console.log('\u2713 Ready for smart contract interactions')\n}\n\n// Run the example\nmain()"
    },
    {
      "example_id": "137-arc56-error-handling-in-smart-contract-applications",
      "title": "ARC56 Error Handling in Smart Contract Applications",
      "summary": "Comprehensive demonstration of ARC56 error handling including deployment errors, method call errors with template variables, and error propagation through nested inner application calls",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "error handling",
      "specific_use_case": "Handle and display custom error messages from ARC56-compliant smart contracts in various scenarios including deployment, method calls, and nested app calls",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "ARC56 error handling",
        "deployment errors",
        "inner app errors",
        "nested app calls",
        "error propagation",
        "template variables with error messages"
      ],
      "feature_tags": [
        "arc56",
        "error-handling",
        "smart-contracts",
        "app-deployment",
        "inner-transactions",
        "nested-calls",
        "template-variables",
        "app-factory",
        "app-client"
      ],
      "folder": "137-arc56-error-handling-in-smart-contract-applications",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start AlgoKit LocalNet: algokit localnet start"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Deployment error caught with custom message: 'custom error message'",
        "Method call error caught with dynamic template variables: 'this is an error'",
        "Nested inner app error caught and propagated: 'custom error message'"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "ARC56 error message on deploy"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "ARC56 error messages with dynamic template vars (cblock offset)"
        },
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "ARC56 error messages from inner app error"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "deploy-error-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 application spec that throws an error during deployment"
        },
        {
          "target_file": "template-vars-error-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 application spec with template variables that throws errors"
        },
        {
          "target_file": "error-inner-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 spec for the innermost application in nested call chain"
        },
        {
          "target_file": "error-middle-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 spec for the middle application that calls inner app"
        },
        {
          "target_file": "error-outer-app.arc56.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "ARC56 spec for the outer application that calls middle app"
        }
      ],
      "notes": "This example demonstrates three critical scenarios for ARC56 error handling: (1) errors during deployment, (2) errors in method calls with dynamic template variables that affect program counter offsets, and (3) error propagation through nested inner application calls. All scenarios show how custom error messages are properly extracted and surfaced to developers.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { microAlgos } from '@algorandfoundation/algokit-utils'\nimport * as deployErrorAppArc56Json from './deploy-error-app.arc56.json'\nimport * as templateVarsErrorAppArc56Json from './template-vars-error-app.arc56.json'\nimport * as errorInnerAppArc56Json from './error-inner-app.arc56.json'\nimport * as errorMiddleAppArc56Json from './error-middle-app.arc56.json'\nimport * as errorOuterAppArc56Json from './error-outer-app.arc56.json'\n\n/**\n * ARC56 Error Handling Examples\n * \n * This example demonstrates how to handle custom error messages from ARC56-compliant\n * smart contracts in three scenarios:\n * 1. Errors during application deployment\n * 2. Errors in method calls with dynamic template variables\n * 3. Error propagation through nested inner application calls\n */\n\nasync function main() {\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a funded test account\n  const testAccount = await algorand.account.fromEnvironment('LOCALNET_ACCOUNT')\n  \n  console.log('=== ARC56 Error Handling Examples ===')\n  console.log()\n  \n  // ========================================\n  // Example 1: Deployment Error Handling\n  // ========================================\n  console.log('1. Testing deployment error handling...')\n  try {\n    // Create a factory for an app that throws an error during deployment\n    const deployErrorFactory = algorand.client.getAppFactory({\n      appSpec: deployErrorAppArc56Json as any,\n      defaultSender: testAccount.addr,\n    })\n    \n    // Attempt to deploy the app - this will fail with a custom error message\n    await deployErrorFactory.deploy({ \n      createParams: { method: 'createApplication' } \n    })\n    \n    console.log('\u274c Expected an error but deployment succeeded')\n  } catch (error: any) {\n    // The ARC56 error message is extracted and surfaced here\n    console.log('\u2705 Deployment error caught successfully!')\n    console.log(`   Error message: \"${error.message}\"`)\n    console.log('   Expected: \"custom error message\"')\n  }\n  console.log()\n  \n  // ========================================\n  // Example 2: Error Messages with Template Variables\n  // ========================================\n  console.log('2. Testing error messages with dynamic template variables...')\n  try {\n    // Create a factory for an app with template variables\n    const templateVarsFactory = algorand.client.getAppFactory({\n      appSpec: templateVarsErrorAppArc56Json as any,\n      defaultSender: testAccount.addr,\n    })\n    \n    // Deploy the app with specific template variable values\n    // These template variables can affect the program counter (cblock offset),\n    // but error messages should still be correctly identified\n    const { appClient } = await templateVarsFactory.deploy({\n      createParams: {\n        method: 'createApplication',\n      },\n      deployTimeParams: {\n        bytes64TmplVar: '0'.repeat(64),\n        uint64TmplVar: 123,\n        bytes32TmplVar: '0'.repeat(32),\n        bytesTmplVar: 'foo',\n      },\n    })\n    \n    console.log(`   App deployed successfully with ID: ${appClient.appId}`)\n    \n    // Call a method that throws an error\n    await appClient.send.call({ method: 'throwError' })\n    \n    console.log('\u274c Expected an error but method call succeeded')\n  } catch (error: any) {\n    // Even with template variables affecting code offsets,\n    // the ARC56 error message is correctly extracted\n    console.log('\u2705 Error caught successfully with template variables!')\n    console.log(`   Error message: \"${error.message}\"`)\n    console.log('   Expected: \"this is an error\"')\n  }\n  console.log()\n  \n  // ========================================\n  // Example 3: Nested Inner App Error Propagation\n  // ========================================\n  console.log('3. Testing error propagation through nested inner app calls...')\n  try {\n    // Deploy the innermost application\n    const innerFactory = algorand.client.getAppFactory({\n      appSpec: errorInnerAppArc56Json as any,\n      defaultSender: testAccount.addr,\n    })\n    const { appClient: innerClient } = await innerFactory.deploy({ \n      createParams: { method: 'createApplication' } \n    })\n    console.log(`   Inner app deployed with ID: ${innerClient.appId}`)\n    \n    // Deploy the middle application\n    const middleFactory = algorand.client.getAppFactory({\n      appSpec: errorMiddleAppArc56Json as any,\n      defaultSender: testAccount.addr,\n    })\n    const { appClient: middleClient } = await middleFactory.deploy({ \n      createParams: { method: 'createApplication' } \n    })\n    console.log(`   Middle app deployed with ID: ${middleClient.appId}`)\n    \n    // Deploy the outer application\n    const outerFactory = algorand.client.getAppFactory({\n      appSpec: errorOuterAppArc56Json as any,\n      defaultSender: testAccount.addr,\n    })\n    const { appClient: outerClient } = await outerFactory.deploy({ \n      createParams: { method: 'createApplication' } \n    })\n    console.log(`   Outer app deployed with ID: ${outerClient.appId}`)\n    \n    // Call the outer app, which calls the middle app, which calls the inner app\n    // The inner app will throw an error that should propagate up\n    // Note: Extra fee is needed for inner transactions\n    await outerClient.send.call({ \n      method: 'callMiddle', \n      args: [middleClient.appId, innerClient.appId], \n      extraFee: microAlgos(2000) \n    })\n    \n    console.log('\u274c Expected an error but nested call succeeded')\n  } catch (error: any) {\n    // The error from the innermost app is propagated through the call chain\n    // and the ARC56 error message is correctly extracted\n    console.log('\u2705 Nested inner app error caught and propagated successfully!')\n    console.log(`   Error message: \"${error.message}\"`)\n    console.log('   Expected: \"custom error message\"')\n    console.log('   This error originated from the innermost app and propagated up')\n  }\n  console.log()\n  \n  console.log('=== All ARC56 error handling examples completed ===')\n}\n\nmain().catch((error) => {\n  console.error('Unexpected error:', error)\n  process.exit(1)\n})"
    },
    {
      "example_id": "138-full-app-lifecycle-create-update-and-delete-with-metadata-tracking",
      "title": "Full App Lifecycle: Create, Update, and Delete with Metadata Tracking",
      "summary": "Comprehensive example demonstrating the complete app lifecycle including creating multiple apps, updating one with new metadata, deleting another, and tracking all state changes",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Create multiple apps, update one with new metadata, delete another, and verify all apps and their states are correctly tracked",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "algorand.send.appCreate",
        "algorand.send.appUpdate",
        "algorand.send.appDelete",
        "algorand.appDeployer.getCreatorAppsByName"
      ],
      "feature_tags": [
        "app-lifecycle",
        "app-creation",
        "app-update",
        "app-deletion",
        "metadata-tracking",
        "deployment-metadata",
        "app-deployer"
      ],
      "folder": "138-full-app-lifecycle-create-update-and-delete-with-metadata-tracking",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost:4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Three apps created with different names",
        "One app updated with new metadata (version, updatable, deletable flags changed)",
        "One app deleted",
        "Retrieved apps showing correct states: one updated, one unchanged, one deleted",
        "Metadata tracking showing creation and update metadata separately"
      ],
      "source_tests": [
        {
          "file": "src/app-deploy.spec.ts",
          "test_name": "Created, updated and deleted apps are retrieved by name with deployment metadata"
        }
      ],
      "artifacts_plan": [],
      "notes": "This is the most comprehensive example showing full app lifecycle management. It demonstrates best practices for managing app deployments including versioning, metadata updates, and proper tracking of app states.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport algosdk from 'algosdk'\n\n/**\n * Comprehensive example demonstrating the full Algorand app lifecycle:\n * \n * 1. Create multiple apps with deployment metadata\n * 2. Update an app with new metadata (version upgrade, flag changes)\n * 3. Delete an app\n * 4. Retrieve all apps and verify their states\n * \n * This shows how metadata is tracked throughout the app's lifetime,\n * including creation metadata, update metadata, and deletion status.\n */\n\nasync function main() {\n  // Initialize Algorand client for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get a test account with funds\n  const testAccount = await algorand.account.fromEnvironment('ACCOUNT1')\n  console.log(`Using account: ${testAccount.addr}\\n`)\n\n  // ========================================\n  // STEP 1: Create three apps with metadata\n  // ========================================\n  console.log('\ud83d\udce6 STEP 1: Creating three apps with metadata\\n')\n  \n  const appName1 = 'APP_1'\n  const appName2 = 'APP_2'\n  const appName3 = 'APP_3'\n  \n  const creationMetadata = {\n    name: appName1,\n    version: '1.0',\n    updatable: true,\n    deletable: true\n  }\n\n  // Compile simple TEAL programs\n  const approvalProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n  const clearProgram = await algorand.app.compileTeal(\n    '#pragma version 10\\nint 1\\nreturn'\n  )\n\n  // Create App 1\n  console.log(`Creating ${appName1}...`)\n  const app1 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify(creationMetadata))\n  })\n  console.log(`  \u2705 ${appName1} created with ID: ${app1.appId}\\n`)\n\n  // Create App 2\n  console.log(`Creating ${appName2}...`)\n  const app2 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify({ ...creationMetadata, name: appName2 }))\n  })\n  console.log(`  \u2705 ${appName2} created with ID: ${app2.appId}\\n`)\n\n  // Create App 3\n  console.log(`Creating ${appName3}...`)\n  const app3 = await algorand.send.appCreate({\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    schema: {\n      globalUints: 0,\n      globalByteSlices: 0,\n      localUints: 0,\n      localByteSlices: 0\n    },\n    onComplete: algosdk.OnApplicationComplete.NoOpOC,\n    note: new TextEncoder().encode(JSON.stringify({ ...creationMetadata, name: appName3 }))\n  })\n  console.log(`  \u2705 ${appName3} created with ID: ${app3.appId}\\n`)\n\n  // ========================================\n  // STEP 2: Update App 1 with new metadata\n  // ========================================\n  console.log('\ud83d\udd04 STEP 2: Updating App 1 with new metadata\\n')\n  \n  const updateMetadata = {\n    name: appName1,\n    version: '2.0', // Version upgrade\n    updatable: false, // Lock further updates\n    deletable: false // Prevent deletion\n  }\n\n  console.log(`Updating ${appName1} (ID: ${app1.appId})...`)\n  console.log('  New metadata:', JSON.stringify(updateMetadata, null, 2))\n  \n  const update1 = await algorand.send.appUpdate({\n    appId: app1.appId,\n    sender: testAccount.addr,\n    approvalProgram: approvalProgram.compiledBase64ToBytes,\n    clearStateProgram: clearProgram.compiledBase64ToBytes,\n    note: new TextEncoder().encode(JSON.stringify(updateMetadata))\n  })\n  console.log(`  \u2705 ${appName1} updated in round: ${update1.confirmation.confirmedRound}\\n`)\n\n  // ========================================\n  // STEP 3: Delete App 3\n  // ========================================\n  console.log('\ud83d\uddd1\ufe0f  STEP 3: Deleting App 3\\n')\n  \n  console.log(`Deleting ${appName3} (ID: ${app3.appId})...`)\n  const delete3 = await algorand.send.appDelete({\n    appId: app3.appId,\n    sender: testAccount.addr\n  })\n  console.log(`  \u2705 ${appName3} deleted in round: ${delete3.confirmation.confirmedRound}\\n`)\n\n  // Wait for indexer to catch up\n  console.log('Waiting for indexer to index all transactions...')\n  await new Promise(resolve => setTimeout(resolve, 3000))\n\n  // ========================================\n  // STEP 4: Retrieve and verify all apps\n  // ========================================\n  console.log('\\n\ud83d\udccb STEP 4: Retrieving all apps and verifying states\\n')\n  \n  const apps = await algorand.appDeployer.getCreatorAppsByName(testAccount.addr)\n\n  console.log(`Creator: ${apps.creator}`)\n  console.log(`Apps found: ${Object.keys(apps.apps).sort().join(', ')}\\n`)\n\n  // Verify App 1 (updated)\n  console.log(`\\n\u2501\u2501\u2501 ${appName1} (Updated App) \u2501\u2501\u2501`)\n  const app1Data = apps.apps[appName1]\n  if (app1Data) {\n    console.log(`App ID: ${app1Data.appId}`)\n    console.log(`App Address: ${app1Data.appAddress}`)\n    console.log(`Deleted: ${app1Data.deleted}`)\n    console.log(`\\nCreation Metadata (v1.0):`, app1Data.createdMetadata)\n    console.log(`  - Created in round: ${app1Data.createdRound}`)\n    console.log(`\\nCurrent Metadata (v2.0):`, {\n      name: app1Data.name,\n      version: app1Data.version,\n      updatable: app1Data.updatable,\n      deletable: app1Data.deletable\n    })\n    console.log(`  - Updated in round: ${app1Data.updatedRound}`)\n    console.log(`\\n\u2705 Metadata shows version upgrade from 1.0 to 2.0`)\n    console.log(`\u2705 Update flags changed: updatable=${app1Data.updatable}, deletable=${app1Data.deletable}`)\n  }\n\n  // Verify App 2 (unchanged)\n  console.log(`\\n\u2501\u2501\u2501 ${appName2} (Unchanged App) \u2501\u2501\u2501`)\n  const app2Data = apps.apps[appName2]\n  if (app2Data) {\n    console.log(`App ID: ${app2Data.appId}`)\n    console.log(`Deleted: ${app2Data.deleted}`)\n    console.log(`Version: ${app2Data.version}`)\n    console.log(`\\n\u2705 App remains in original state`)\n  }\n\n  // Verify App 3 (deleted)\n  console.log(`\\n\u2501\u2501\u2501 ${appName3} (Deleted App) \u2501\u2501\u2501`)\n  const app3Data = apps.apps[appName3]\n  if (app3Data) {\n    console.log(`App ID: ${app3Data.appId}`)\n    console.log(`Deleted: ${app3Data.deleted}`)\n    console.log(`\\n\u2705 App is marked as deleted but still tracked in metadata`)\n  }\n\n  // Summary\n  console.log('\\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501')\n  console.log('\ud83d\udcca SUMMARY')\n  console.log('\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501')\n  console.log(`\u2705 Created 3 apps with metadata`)\n  console.log(`\u2705 Updated 1 app (${appName1}) - version 1.0 \u2192 2.0`)\n  console.log(`\u2705 Deleted 1 app (${appName3})`)\n  console.log(`\u2705 All apps tracked with correct states`)\n  console.log(`\\n\ud83d\udca1 Key Features Demonstrated:`)\n  console.log(`   \u2022 Creation metadata preserved even after updates`)\n  console.log(`   \u2022 Update metadata tracked separately with round number`)\n  console.log(`   \u2022 Deleted apps remain in metadata with deleted=true flag`)\n  console.log(`   \u2022 Full lifecycle visibility for app management`)\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "139-look-up-applications-created-by-account",
      "title": "Look Up Applications Created By Account",
      "summary": "Demonstrates how to retrieve all applications created by a specific account using the Algorand indexer with pagination support.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Look up all applications created by a specific account using the indexer with pagination support",
      "target_users": [
        "SDK developers",
        "Smart contract developers",
        "Application developers",
        "DevOps engineers"
      ],
      "features_tested": [
        "indexer.lookupAccountCreatedApplicationByAddress",
        "algorand.client.getAppFactory",
        "factory.send.bare.create"
      ],
      "feature_tags": [
        "indexer",
        "application-lookup",
        "pagination",
        "app-factory",
        "application-deployment",
        "creator-filtering"
      ],
      "folder": "139-look-up-applications-created-by-account",
      "prerequisites": {
        "tools": [
          "algokit",
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": true,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": true,
            "example": "http://localhost"
          },
          {
            "name": "INDEXER_PORT",
            "required": true,
            "example": "8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": true,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "CREATOR_ACCOUNT_MNEMONIC",
            "required": true,
            "example": "your 25 word mnemonic here..."
          },
          {
            "name": "SECOND_ACCOUNT_MNEMONIC",
            "required": true,
            "example": "another 25 word mnemonic here..."
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure indexer is running and synced"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Creator and second account addresses displayed",
        "Three applications deployed with their IDs logged",
        "Indexer lookup returns only apps created by the creator account (not the second account)",
        "List of application IDs created by the specified account"
      ],
      "source_tests": [
        {
          "file": "src/indexer-lookup.spec.ts",
          "test_name": "Application create transactions are found by creator with pagination"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Users need to provide their own app spec JSON for the application they want to deploy"
        }
      ],
      "notes": "This example requires a LocalNet or TestNet environment with indexer enabled. The indexer has eventual consistency, so there's a delay between transaction confirmation and indexer availability. The pagination parameter allows control over how many results are returned per page.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { lookupAccountCreatedApplicationByAddress } from '@algorandfoundation/algokit-utils/types/indexer-lookup'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to look up all applications created by a specific account\n * using the Algorand indexer with pagination support.\n * \n * Use case: Discover and manage applications deployed by users or manage multi-app deployments.\n */\n\nasync function main() {\n  // Initialize the AlgorandClient for LocalNet\n  const algorand = AlgorandClient.testNet() // or AlgorandClient.mainNet() for production\n  \n  // Get the creator account (the account that will deploy apps)\n  const testAccount = await algorand.account.fromEnvironment('CREATOR_ACCOUNT')\n  \n  // Create a second account for comparison\n  const secondAccount = await algorand.account.fromEnvironment('SECOND_ACCOUNT')\n  \n  console.log('Creator account:', testAccount.addr)\n  console.log('Second account:', secondAccount.addr)\n  \n  // Load your application spec (replace with your actual app spec)\n  // For this example, assume you have a contract with deploy-time parameters\n  const appSpec = {\n    // Your app spec JSON here\n    // This would typically be loaded from a JSON file:\n    // const appSpec = JSON.parse(fs.readFileSync('path/to/app-spec.json', 'utf-8'))\n  }\n  \n  // Create an app factory with deploy-time parameters\n  const factory = algorand.client.getAppFactory({\n    appSpec: appSpec,\n    defaultSender: testAccount,\n    deletable: false,\n    updatable: false,\n    deployTimeParams: { VALUE: 1 },\n  })\n  \n  console.log('\\nDeploying applications...')\n  \n  // Deploy first application with default deploy-time parameters\n  const { result: app1 } = await factory.send.bare.create()\n  console.log('App 1 created with ID:', app1.appId)\n  \n  // Deploy second application with different deploy-time parameters\n  const { result: app2 } = await factory.send.bare.create({ \n    deployTimeParams: { VALUE: 2 } \n  })\n  console.log('App 2 created with ID:', app2.appId)\n  \n  // Deploy a third application from a different account (for comparison)\n  await factory.send.bare.create({ sender: secondAccount })\n  console.log('App 3 created from second account')\n  \n  // Wait for indexer to catch up (indexer has eventual consistency)\n  console.log('\\nWaiting for indexer to index the transactions...')\n  await new Promise(resolve => setTimeout(resolve, 3000))\n  \n  // Look up all applications created by the test account with pagination\n  console.log('\\nLooking up applications created by:', testAccount.addr)\n  const apps = await lookupAccountCreatedApplicationByAddress(\n    algorand.client.indexer,\n    testAccount.addr,\n    true, // includeAll: include deleted apps\n    1     // paginationLimit: number of results per page\n  )\n  \n  // Display the results\n  console.log('\\nApplications created by test account:')\n  const appIds = apps.map((a) => BigInt(a.id)).sort()\n  appIds.forEach((id) => {\n    console.log(`  - App ID: ${id}`)\n  })\n  \n  console.log('\\nExpected app IDs:', [app1.appId, app2.appId].sort())\n  console.log('Retrieved app IDs:', appIds)\n  console.log('\\nNote: The third app created by secondAccount should not appear in this list.')\n}\n\nmain().catch(console.error)"
    },
    {
      "example_id": "140-multiple-layers-of-nested-app-calls",
      "title": "Multiple Layers of Nested App Calls",
      "summary": "Demonstrates the most advanced composition pattern with multiple layers of nested method calls. Shows how to call a method that takes a method call argument, which itself takes another method call argument that has a transaction argument - showcasing the full flexibility of the SDK's method composition.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "medium",
      "use_case_category": "transaction management",
      "specific_use_case": "Call a method that takes a method call argument, which itself takes another method call argument that has a transaction argument",
      "target_users": [
        "Advanced smart contract developers",
        "Complex dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup()",
        "addAppCallMethodCall",
        "deeply nested method calls",
        "multi-layer method composition",
        "transaction arguments",
        "AppCallMethodCall type"
      ],
      "feature_tags": [
        "nested-method-calls",
        "multi-layer-composition",
        "app-call",
        "method-arguments",
        "advanced-composition",
        "transaction-group",
        "complex-workflows"
      ],
      "folder": "140-multiple-layers-of-nested-app-calls",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy a smart contract with methods that accept method call arguments"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Multi-layer nested transaction group sent successfully",
        "Three return values from the nested method calls",
        "First return: <sender-address>",
        "Second return: <app-id>",
        "Third return: <app-id>",
        "Transaction IDs and confirmation details"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "multiple layers of nested app calls"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample smart contract with txnArg and methodArg methods for multi-layer nesting"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "This example demonstrates the deepest level of method call nesting supported by the SDK. Requires a smart contract with methods that accept method call arguments at multiple levels.",
      "generated_code": "import { AlgorandClient, Config } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport { AppCallMethodCall } from '@algorandfoundation/algokit-utils/types/composer'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates multiple layers of nested method calls.\n * \n * Scenario: Call a method that takes a method call argument,\n * which itself takes another method call argument that has a transaction argument.\n * \n * This shows the deepest level of method composition supported,\n * useful for extremely complex multi-step dApp operations.\n * \n * Structure:\n * Level 1 (outer): methodArg(methodCall)\n *   \u2514\u2500 Level 2 (middle): methodArg(methodCall)\n *        \u2514\u2500 Level 3 (inner): txnArg(payment)\n */\n\nasync function multiLayerNestedCallsExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create an account to use as sender\n  const alice = algorand.account.fromEnvironment('ALICE', algosdk.generateAccount())\n  \n  console.log('Setting up multi-layer nested method call example...')\n  console.log('Sender address:', alice.addr)\n  \n  // Ensure alice has funds\n  await algorand.send.payment({\n    sender: algorand.account.localNetDispenser(),\n    receiver: alice.addr,\n    amount: AlgoAmount.Algos(10),\n  })\n  \n  // NOTE: You need to deploy your smart contract and get the appId\n  // For this example, we assume you have a contract with these methods:\n  // - txnArg(txn: transaction): returns sender address\n  // - methodArg(method_call): returns app ID\n  \n  // Replace this with your actual deployed app ID\n  const appId = 123456 // TODO: Replace with actual app ID\n  \n  // Get the ABI method definitions from your contract client\n  // In a real scenario, you would import your generated app client\n  // For example: import { YourAppClient } from './artifacts/YourApp.client'\n  // const appClient = new YourAppClient({ sender: alice, resolveBy: 'id', id: appId }, algorand.client.algod)\n  // const txnArgMethod = appClient.appClient.getABIMethod('txnArg')!\n  // const methodArgMethod = appClient.appClient.getABIMethod('methodArg')!\n  \n  console.log('\\nStep 1: Create the innermost method call (Level 3) with a payment transaction')\n  \n  // Level 3 (innermost): Method that takes a transaction argument\n  const txnArg2Call: AppCallMethodCall = {\n    sender: alice.addr,\n    appId: appId,\n    method: txnArgMethod, // Replace with actual method\n    note: 'txnArg2Call',\n    args: [\n      algorand.createTransaction.payment({\n        sender: alice.addr,\n        receiver: alice.addr,\n        amount: AlgoAmount.MicroAlgo(1),\n      })\n    ],\n  }\n  \n  console.log('Level 3 configured: txnArg with payment transaction (amount: 1 microAlgo)')\n  \n  console.log('\\nStep 2: Create the middle method call (Level 2) that takes Level 3 as an argument')\n  \n  // Level 2 (middle): Method that takes the innermost method call as an argument\n  const txnArg1Call: AppCallMethodCall = {\n    sender: alice.addr,\n    appId: appId,\n    method: methodArgMethod, // Replace with actual method\n    note: 'txnArg1Call',\n    args: [txnArg2Call],\n  }\n  \n  console.log('Level 2 configured: methodArg taking Level 3 as argument')\n  \n  console.log('\\nStep 3: Create the outermost method call (Level 1) that takes Level 2 as an argument')\n  \n  // Level 1 (outermost): Build and send the transaction group\n  const nestedTxnArgRes = await algorand\n    .newGroup()\n    .addAppCallMethodCall({\n      sender: alice.addr,\n      appId: appId,\n      note: 'nestedTxnArgRes',\n      method: methodArgMethod, // Replace with actual method\n      args: [txnArg1Call],\n    })\n    .send()\n  \n  console.log('\\nTransaction group sent successfully!')\n  console.log('Transaction IDs:', nestedTxnArgRes.txIds)\n  \n  // Extract and display the return values from all three levels\n  if (nestedTxnArgRes.returns) {\n    console.log('\\nReturn values from nested calls:')\n    \n    const firstReturn = nestedTxnArgRes.returns[0]?.returnValue?.valueOf()\n    const secondReturn = nestedTxnArgRes.returns[1]?.returnValue?.valueOf()\n    const thirdReturn = nestedTxnArgRes.returns[2]?.returnValue?.valueOf()\n    \n    console.log('- Level 3 return (sender from txnArg):', firstReturn)\n    console.log('- Level 2 return (app ID from methodArg):', secondReturn)\n    console.log('- Level 1 return (app ID from methodArg):', thirdReturn)\n  }\n  \n  console.log('\\nMulti-layer nested method call example completed successfully!')\n  console.log('This demonstrates the full depth of method composition capabilities.')\n}\n\n// Run the example\nmultiLayerNestedCallsExample().catch(console.error)"
    },
    {
      "example_id": "141-nested-method-calls-with-transaction-arguments",
      "title": "Nested Method Calls with Transaction Arguments",
      "summary": "Demonstrates how to compose method calls where a method takes another method call as an argument, and that nested method call itself takes a transaction as an argument. This shows advanced composition patterns for complex dApp workflows.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "medium",
      "use_case_category": "transaction management",
      "specific_use_case": "Call a method that takes another method call as an argument, where that nested method call itself takes a transaction as an argument",
      "target_users": [
        "Smart contract developers",
        "Advanced dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup()",
        "addAppCallMethodCall",
        "nested method calls",
        "transaction arguments",
        "method composition",
        "AppCallMethodCall type"
      ],
      "feature_tags": [
        "nested-method-calls",
        "transaction-composition",
        "app-call",
        "method-arguments",
        "advanced-composition",
        "transaction-group"
      ],
      "folder": "141-nested-method-calls-with-transaction-arguments",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Ensure you have a deployed smart contract with methods that accept transaction and method call arguments"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Nested method call transaction group sent successfully",
        "First return value: <sender-address>",
        "Second return value: <app-id>",
        "Transaction IDs and confirmation details"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "method with method call arg that has a txn arg"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample smart contract with txnArg and nestedTxnArg methods for testing nested calls"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "This example requires a smart contract that has methods like 'txnArg' and 'nestedTxnArg' that accept transaction and method call arguments. The contract should be deployed before running this example.",
      "generated_code": "import { AlgorandClient, Config } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport { AppCallMethodCall } from '@algorandfoundation/algokit-utils/types/composer'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates nested method calls with transaction arguments.\n * \n * Scenario: Call a method that takes another method call as an argument,\n * where that nested method call itself takes a transaction as an argument.\n * \n * This is useful for complex dApp workflows where you need to compose\n * multiple contract interactions in a single atomic group.\n */\n\nasync function nestedMethodCallsExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create an account to use as sender\n  const alice = algorand.account.fromEnvironment('ALICE', algosdk.generateAccount())\n  \n  console.log('Setting up nested method call example...')\n  console.log('Sender address:', alice.addr)\n  \n  // Ensure alice has funds\n  await algorand.send.payment({\n    sender: algorand.account.localNetDispenser(),\n    receiver: alice.addr,\n    amount: AlgoAmount.Algos(10),\n  })\n  \n  // NOTE: You need to deploy your smart contract and get the appId\n  // For this example, we assume you have a contract with these methods:\n  // - txnArg(txn: transaction): returns sender address\n  // - nestedTxnArg(arg1: any, arg2: method_call): returns app ID\n  \n  // Replace this with your actual deployed app ID\n  const appId = 123456 // TODO: Replace with actual app ID\n  \n  // Get the ABI method definitions from your contract client\n  // In a real scenario, you would import your generated app client\n  // For example: import { YourAppClient } from './artifacts/YourApp.client'\n  // const appClient = new YourAppClient({ sender: alice, resolveBy: 'id', id: appId }, algorand.client.algod)\n  \n  // For demonstration, we'll show the structure:\n  // const txnArgMethod = appClient.appClient.getABIMethod('txnArg')!\n  // const nestedTxnArgMethod = appClient.appClient.getABIMethod('nestedTxnArg')!\n  \n  console.log('\\nStep 1: Create the inner method call with a payment transaction argument')\n  \n  // Define the inner method call that takes a transaction as an argument\n  const txnArgCall: AppCallMethodCall = {\n    sender: alice,\n    appId: appId,\n    method: txnArgMethod, // Replace with actual method from your contract\n    // The payment transaction is passed as an argument to the method\n    args: [\n      algorand.createTransaction.payment({\n        sender: alice,\n        receiver: alice,\n        amount: AlgoAmount.MicroAlgo(0),\n      })\n    ],\n  }\n  \n  console.log('Inner method call configured: txnArg with payment transaction')\n  \n  console.log('\\nStep 2: Create the outer method call that takes the inner method call as an argument')\n  \n  // Build and send the transaction group with nested method calls\n  const nestedTxnArgRes = await algorand\n    .newGroup()\n    .addAppCallMethodCall({\n      sender: alice,\n      appId: appId,\n      method: nestedTxnArgMethod, // Replace with actual method from your contract\n      // The first arg is undefined (placeholder), the second is the nested method call\n      args: [undefined, txnArgCall],\n    })\n    .send()\n  \n  console.log('\\nTransaction group sent successfully!')\n  console.log('Transaction ID:', nestedTxnArgRes.txIds[0])\n  \n  // Extract and display the return values\n  if (nestedTxnArgRes.returns) {\n    const firstReturn = nestedTxnArgRes.returns[0]?.returnValue?.valueOf()\n    const secondReturn = nestedTxnArgRes.returns[1]?.returnValue?.valueOf()\n    \n    console.log('\\nReturn values:')\n    console.log('- First return (sender from txnArg):', firstReturn)\n    console.log('- Second return (app ID from nestedTxnArg):', secondReturn)\n  }\n  \n  console.log('\\nNested method call example completed successfully!')\n}\n\n// Run the example\nnestedMethodCallsExample().catch(console.error)"
    },
    {
      "example_id": "142-parallel-nested-method-calls-with-transaction-arguments",
      "title": "Parallel Nested Method Calls with Transaction Arguments",
      "summary": "Demonstrates how to compose a method with multiple nested method calls in parallel, each with their own transaction arguments. Shows how to call a method that accepts multiple method call arguments simultaneously, useful for complex multi-step operations that need to happen atomically.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "medium",
      "use_case_category": "transaction management",
      "specific_use_case": "Call a method that accepts multiple method call arguments, each of which has its own transaction argument",
      "target_users": [
        "Advanced smart contract developers",
        "Complex dApp developers"
      ],
      "features_tested": [
        "algorand.newGroup()",
        "addAppCallMethodCall",
        "multiple nested method calls",
        "parallel method composition",
        "transaction arguments",
        "AppCallMethodCall type"
      ],
      "feature_tags": [
        "nested-method-calls",
        "parallel-composition",
        "app-call",
        "method-arguments",
        "advanced-composition",
        "transaction-group",
        "multi-arg-methods"
      ],
      "folder": "142-parallel-nested-method-calls-with-transaction-arguments",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy a smart contract with methods that accept multiple method call arguments"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Parallel nested transaction group sent successfully",
        "Three return values from the method calls",
        "First return: <sender-address> (from first nested call)",
        "Second return: <sender-address> (from second nested call)",
        "Third return: <app-id>",
        "Transaction IDs and confirmation details"
      ],
      "source_tests": [
        {
          "file": "src/types/algorand-client.spec.ts",
          "test_name": "method with two method call args that each have a txn arg"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample smart contract with txnArg and doubleNestedTxnArg methods"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with required dependencies"
        },
        {
          "target_file": "tsconfig.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "TypeScript configuration"
        }
      ],
      "notes": "This example shows parallel method composition where multiple nested method calls are passed as separate arguments to a parent method. Each nested call has its own transaction argument.",
      "generated_code": "import { AlgorandClient, Config } from '@algorandfoundation/algokit-utils'\nimport { AlgoAmount } from '@algorandfoundation/algokit-utils/types/amount'\nimport { AppCallMethodCall } from '@algorandfoundation/algokit-utils/types/composer'\nimport algosdk from 'algosdk'\n\n/**\n * This example demonstrates parallel nested method calls with transaction arguments.\n * \n * Scenario: Call a method that accepts multiple method call arguments,\n * each of which has its own transaction argument.\n * \n * This is useful for complex multi-step operations where you need to\n * compose multiple parallel contract interactions in a single atomic group.\n * \n * Structure:\n * doubleNestedTxnArg(arg1, methodCall1, arg2, methodCall2)\n *   \u251c\u2500 methodCall1: txnArg(payment1)\n *   \u2514\u2500 methodCall2: txnArg(payment2)\n */\n\nasync function parallelNestedCallsExample() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  \n  // Get or create an account to use as sender\n  const alice = algorand.account.fromEnvironment('ALICE', algosdk.generateAccount())\n  \n  console.log('Setting up parallel nested method call example...')\n  console.log('Sender address:', alice.addr)\n  \n  // Ensure alice has funds\n  await algorand.send.payment({\n    sender: algorand.account.localNetDispenser(),\n    receiver: alice.addr,\n    amount: AlgoAmount.Algos(10),\n  })\n  \n  // NOTE: You need to deploy your smart contract and get the appId\n  // For this example, we assume you have a contract with these methods:\n  // - txnArg(txn: transaction): returns sender address\n  // - doubleNestedTxnArg(arg1, method1, arg2, method2): processes both method calls\n  \n  // Replace this with your actual deployed app ID\n  const appId = 123456 // TODO: Replace with actual app ID\n  \n  // Get the ABI method definitions from your contract client\n  // In a real scenario, you would import your generated app client\n  // For example: import { YourAppClient } from './artifacts/YourApp.client'\n  // const appClient = new YourAppClient({ sender: alice, resolveBy: 'id', id: appId }, algorand.client.algod)\n  // const txnArgMethod = appClient.appClient.getABIMethod('txnArg')!\n  // const doubleNestedMethod = appClient.appClient.getABIMethod('doubleNestedTxnArg')!\n  \n  console.log('\\nStep 1: Create the first nested method call with a payment transaction (0 microAlgo)')\n  \n  // First nested method call with its own transaction argument\n  const firstTxnCall: AppCallMethodCall = {\n    sender: alice,\n    appId: appId,\n    method: txnArgMethod, // Replace with actual method\n    args: [\n      algorand.createTransaction.payment({\n        sender: alice,\n        receiver: alice,\n        amount: AlgoAmount.MicroAlgo(0),\n      })\n    ],\n  }\n  \n  console.log('First nested call configured: txnArg with payment of 0 microAlgo')\n  \n  console.log('\\nStep 2: Create the second nested method call with a different payment transaction (1 microAlgo)')\n  \n  // Second nested method call with its own transaction argument and a note to differentiate it\n  const secondTxnCall: AppCallMethodCall = {\n    sender: alice,\n    appId: appId,\n    method: txnArgMethod, // Replace with actual method\n    args: [\n      algorand.createTransaction.payment({\n        sender: alice,\n        receiver: alice,\n        amount: AlgoAmount.MicroAlgo(1),\n      })\n    ],\n    note: new Uint8Array([1]), // Adding a note to differentiate this call\n  }\n  \n  console.log('Second nested call configured: txnArg with payment of 1 microAlgo and custom note')\n  \n  console.log('\\nStep 3: Create the parent method call that takes both nested calls as arguments')\n  \n  // Build and send the transaction group with parallel nested method calls\n  const doubleNestedTxnArgRes = await algorand\n    .newGroup()\n    .addAppCallMethodCall({\n      sender: alice,\n      appId: appId,\n      method: doubleNestedMethod, // Replace with actual method\n      // Pass both nested method calls as separate arguments\n      // undefined values are placeholders for other arguments the method might need\n      args: [undefined, firstTxnCall, undefined, secondTxnCall],\n    })\n    .send()\n  \n  console.log('\\nTransaction group sent successfully!')\n  console.log('Transaction IDs:', doubleNestedTxnArgRes.txIds)\n  \n  // Extract and display the return values\n  if (doubleNestedTxnArgRes.returns) {\n    console.log('\\nReturn values from parallel nested calls:')\n    \n    const firstReturn = doubleNestedTxnArgRes.returns[0]?.returnValue?.valueOf()\n    const secondReturn = doubleNestedTxnArgRes.returns[1]?.returnValue?.valueOf()\n    const thirdReturn = doubleNestedTxnArgRes.returns[2]?.returnValue?.valueOf()\n    \n    console.log('- First nested call return (sender from first txnArg):', firstReturn)\n    console.log('- Second nested call return (sender from second txnArg):', secondReturn)\n    console.log('- Parent method return (app ID):', thirdReturn)\n  }\n  \n  console.log('\\nParallel nested method call example completed successfully!')\n  console.log('This demonstrates how to compose multiple nested calls in parallel within a single method.')\n}\n\n// Run the example\nparallelNestedCallsExample().catch(console.error)"
    },
    {
      "example_id": "143-replace-an-application-using-abi-methods",
      "title": "Replace an Application Using ABI Methods",
      "summary": "Shows how to replace an existing application using ABI methods for both delete and create operations, capturing return values from both operations",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "app deployment",
      "specific_use_case": "Replace an application using ABI methods for both delete and create operations",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.deploy",
        "onUpdate: 'replace'",
        "createArgs with ABI methods",
        "deleteArgs with ABI methods",
        "deleteReturn",
        "return value handling"
      ],
      "feature_tags": [
        "app-client",
        "deployment",
        "replace",
        "abi-methods",
        "delete-abi",
        "create-abi",
        "return-values"
      ],
      "folder": "143-replace-an-application-using-abi-methods",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          },
          {
            "name": "INDEXER_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "INDEXER_PORT",
            "required": false,
            "example": "8980"
          },
          {
            "name": "INDEXER_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have a compiled app spec JSON file with ABI methods (create_abi and delete_abi)"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "First deployment creates app with VALUE=1",
        "Second deployment replaces the app with VALUE=2 using ABI methods",
        "Delete ABI method is called with argument 'arg2_io' and returns that value",
        "Create ABI method is called with argument 'arg_io' and returns that value",
        "New app ID is greater than the original app ID",
        "Both return values are logged"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Deploy app - replace (abi)"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "contract.json",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample app spec with ABI methods (create_abi, delete_abi) and deploy-time parameters"
        },
        {
          "target_file": "package.json",
          "type": "config",
          "action": "generate",
          "source_path": null,
          "note": "Package configuration with dependencies"
        }
      ],
      "notes": "This advanced example demonstrates replacing an app while using custom ABI methods for creation and deletion. Useful when you need to pass specific arguments or capture return values during the replacement process.",
      "generated_code": "import algosdk from 'algosdk'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport appSpec from './contract.json'\n\n/**\n * This example demonstrates how to replace an existing Algorand application\n * using custom ABI methods for both the delete and create operations.\n * This allows you to pass specific arguments and capture return values\n * during the replacement process.\n */\n\nasync function replaceAppWithABI() {\n  // Setup clients for LocalNet\n  const algodClient = algokit.getAlgoClient(\n    algokit.getAlgoNodeConfig('algod', 'localnet')\n  )\n  const indexer = algokit.getAlgoClient(\n    algokit.getAlgoNodeConfig('indexer', 'localnet')\n  )\n\n  // Get a test account with funds\n  const account = await algokit.getLocalNetDispenserAccount(algodClient)\n\n  console.log('Account address:', account.addr)\n  console.log('\\n--- Step 1: Deploy initial app ---')\n\n  // Create an app client that can find existing apps by creator and name\n  const client = algokit.getAppClient(\n    {\n      resolveBy: 'creatorAndName',\n      app: appSpec,\n      sender: account,\n      creatorAddress: account.addr,\n      findExistingUsing: indexer,\n    },\n    algodClient\n  )\n\n  // Deploy the first version of the app with VALUE=1\n  // allowDelete: true is required for the app to be deletable later\n  const createdApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 1,\n    },\n    allowDelete: true,\n    sendParams: { populateAppCallResources: false },\n  })\n\n  console.log('Initial app created:')\n  console.log('  App ID:', createdApp.appId)\n  console.log('  App Address:', createdApp.appAddress)\n  console.log('  Operation:', createdApp.operationPerformed)\n\n  console.log('\\n--- Step 2: Replace the app using ABI methods ---')\n\n  // Deploy again with onUpdate: 'replace'\n  // Use custom ABI methods for both delete and create operations\n  const replacedApp = await client.deploy({\n    version: '1.0',\n    deployTimeParams: {\n      VALUE: 2,\n    },\n    onUpdate: 'replace',\n    // Custom ABI method for creating the new app\n    createArgs: {\n      method: 'create_abi',\n      methodArgs: ['arg_io'], // Arguments passed to the create method\n    },\n    // Custom ABI method for deleting the old app\n    deleteArgs: {\n      method: 'delete_abi',\n      methodArgs: ['arg2_io'], // Arguments passed to the delete method\n    },\n    sendParams: { populateAppCallResources: false },\n  })\n\n  console.log('App replaced with ABI methods:')\n  console.log('  New App ID:', replacedApp.appId)\n  console.log('  New App Address:', replacedApp.appAddress)\n  console.log('  Operation:', replacedApp.operationPerformed)\n  console.log('  Old App ID (deleted):', createdApp.appId)\n\n  // Verify the replacement\n  if (replacedApp.appId > createdApp.appId) {\n    console.log('\\n\u2713 Replacement successful: New app ID is greater than old app ID')\n  }\n\n  // Check return values from ABI methods\n  console.log('\\nABI Method Return Values:')\n  if (replacedApp.return?.returnValue) {\n    console.log('  Create method returned:', replacedApp.return.returnValue)\n  }\n  if (replacedApp.deleteReturn?.returnValue) {\n    console.log('  Delete method returned:', replacedApp.deleteReturn.returnValue)\n  }\n\n  // Check delete result\n  if (replacedApp.deleteResult) {\n    console.log('\\nDelete operation details:')\n    console.log('  Deleted app ID:', replacedApp.deleteResult.transaction.applicationCall?.appIndex?.toString())\n    console.log('  Transaction ID:', replacedApp.deleteResult.transaction.txID())\n    console.log('  On Complete:', algosdk.OnApplicationComplete[replacedApp.deleteResult.transaction.applicationCall?.onComplete || 0])\n  }\n\n  console.log('\\n--- Summary ---')\n  console.log('Using ABI methods during replacement allows you to:')\n  console.log('  \u2022 Pass custom arguments to create and delete operations')\n  console.log('  \u2022 Capture and use return values from both operations')\n  console.log('  \u2022 Execute custom cleanup logic during deletion')\n  console.log('  \u2022 Initialize the new app with specific data during creation')\n}\n\n// Run the example\nreplaceAppWithABI().catch(console.error)\n"
    },
    {
      "example_id": "144-retrieve-application-state-global-local-and-box-storage",
      "title": "Retrieve Application State (Global, Local, and Box Storage)",
      "summary": "Comprehensive example demonstrating how to retrieve and decode all types of application state: global state, local state, and box storage with various data types including ABI-encoded values",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "transaction management",
      "specific_use_case": "Retrieve and decode global state, local state, and box storage",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.getGlobalState",
        "client.getLocalState",
        "client.getBoxValues",
        "client.getBoxValue",
        "client.getBoxValuesFromABIType",
        "client.getBoxValueFromABIType"
      ],
      "feature_tags": [
        "state-retrieval",
        "global-state",
        "local-state",
        "box-storage",
        "abi-decoding",
        "state-management"
      ],
      "folder": "144-retrieve-application-state-global-local-and-box-storage",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "TEST_ACCOUNT",
            "required": true,
            "example": "Your test account mnemonic or private key"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet: algokit localnet start",
          "Deploy your smart contract with global state, local state, and box storage support"
        ],
        "install": [
          "npm install @algorandfoundation/algokit-utils algosdk"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Global state values displayed (integers and byte arrays)",
        "Local state values displayed after opt-in",
        "Box storage values retrieved and displayed (both raw and string representations)",
        "ABI-encoded box values decoded and displayed as numbers",
        "Success message confirming all state retrieval operations"
      ],
      "source_tests": [
        {
          "file": "src/types/app-factory-and-client.spec.ts",
          "test_name": "Retrieve state"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "TestApp.algo.ts",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Smart contract with methods: set_global, set_local, opt_in, set_box and appropriate state schema"
        }
      ],
      "notes": "This comprehensive example shows all state management patterns in Algorand smart contracts. Understanding these patterns is crucial for building data-driven applications.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport * as algokit from '@algorandfoundation/algokit-utils'\nimport { ABIUintType } from 'algosdk'\nimport { TestAppClient } from './artifacts/TestApp/client' // Adjust import based on your app\n\n/**\n * Example: Retrieve Application State\n * \n * This example demonstrates comprehensive state management including:\n * 1. Reading and decoding global state\n * 2. Reading and decoding local state (per-account)\n * 3. Working with box storage (raw and ABI-encoded values)\n */\nasync function retrieveAppState() {\n  // Initialize AlgorandClient for LocalNet\n  const algorand = AlgorandClient.fromEnvironment()\n  \n  // Get a test account\n  const testAccount = await algorand.account.fromEnvironment('TEST_ACCOUNT')\n  \n  console.log('\\n--- Retrieve Application State Example ---\\n')\n  \n  // Assume we have a deployed app client\n  const client = new TestAppClient(\n    {\n      sender: testAccount,\n      resolveBy: 'id',\n      id: 0, // Your app ID\n    },\n    algorand.client.algod\n  )\n  \n  // ========================================\n  // 1. GLOBAL STATE EXAMPLE\n  // ========================================\n  console.log('\\n1. Working with Global State:')\n  console.log('Setting global state values...')\n  \n  // Set global state with various data types\n  await client.send.call({ \n    method: 'set_global', \n    args: [1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])] \n  })\n  \n  // Retrieve global state\n  const globalState = await client.getGlobalState()\n  \n  console.log('\\nGlobal State Retrieved:')\n  console.log(`  int1: ${globalState.int1?.value}`)\n  console.log(`  int2: ${globalState.int2?.value}`)\n  console.log(`  bytes1 (string): ${globalState.bytes1?.value}`)\n  console.log(`  bytes2 (raw): [${globalState.bytes2?.valueRaw}]`)\n  console.log(`  Available keys: ${Object.keys(globalState).sort().join(', ')}`)\n  \n  // ========================================\n  // 2. LOCAL STATE EXAMPLE\n  // ========================================\n  console.log('\\n\\n2. Working with Local State:')\n  console.log('Opting in to the application...')\n  \n  // Opt-in is required before setting local state\n  await client.send.optIn({ method: 'opt_in' })\n  \n  console.log('Setting local state values...')\n  await client.send.call({ \n    method: 'set_local', \n    args: [1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])] \n  })\n  \n  // Retrieve local state for the test account\n  const localState = await client.getLocalState(testAccount.addr)\n  \n  console.log('\\nLocal State Retrieved:')\n  console.log(`  local_int1: ${localState.local_int1?.value}`)\n  console.log(`  local_int2: ${localState.local_int2?.value}`)\n  console.log(`  local_bytes1 (string): ${localState.local_bytes1?.value}`)\n  console.log(`  local_bytes2 (raw): [${localState.local_bytes2?.valueRaw}]`)\n  console.log(`  Available keys: ${Object.keys(localState).sort().join(', ')}`)\n  \n  // ========================================\n  // 3. BOX STORAGE EXAMPLE\n  // ========================================\n  console.log('\\n\\n3. Working with Box Storage:')\n  \n  // Define box names\n  const boxName1 = new Uint8Array([0, 0, 0, 1])\n  const boxName1Base64 = Buffer.from(boxName1).toString('base64')\n  const boxName2 = new Uint8Array([0, 0, 0, 2])\n  const boxName2Base64 = Buffer.from(boxName2).toString('base64')\n  \n  // Fund the app account to cover box storage minimum balance\n  console.log('Funding app account for box storage...')\n  await client.fundAppAccount({ amount: algokit.algo(1) })\n  \n  // Create boxes with string values\n  console.log('Creating boxes with string values...')\n  await client.send.call({\n    method: 'set_box',\n    args: [boxName1, 'value1'],\n    boxReferences: [boxName1],\n  })\n  await client.send.call({\n    method: 'set_box',\n    args: [boxName2, 'value2'],\n    boxReferences: [boxName2],\n  })\n  \n  // Retrieve all box values\n  const boxValues = await client.getBoxValues()\n  console.log(`\\nTotal boxes found: ${boxValues.length}`)\n  \n  // Retrieve a specific box value\n  const box1Value = await client.getBoxValue(boxName1)\n  console.log(`\\nBox 1 (${boxName1Base64}):`, Buffer.from(box1Value).toString())\n  \n  const box1 = boxValues.find((b) => b.name.nameBase64 === boxName1Base64)\n  const box2 = boxValues.find((b) => b.name.nameBase64 === boxName2Base64)\n  console.log(`Box 2 (${boxName2Base64}):`, Buffer.from(box2!.value).toString())\n  \n  // ========================================\n  // 4. BOX STORAGE WITH ABI TYPES\n  // ========================================\n  console.log('\\n\\n4. Working with ABI-Encoded Box Values:')\n  \n  const expectedValue = 1234524352\n  console.log(`Setting box with ABI-encoded uint32 value: ${expectedValue}`)\n  \n  // Set box with ABI-encoded value\n  await client.send.call({\n    method: 'set_box',\n    args: [boxName1, new ABIUintType(32).encode(expectedValue)],\n    boxReferences: [boxName1],\n  })\n  \n  // Retrieve and decode box value using ABI type\n  const boxes = await client.getBoxValuesFromABIType(\n    new ABIUintType(32), \n    (n) => n.nameBase64 === boxName1Base64\n  )\n  \n  const box1AbiValue = await client.getBoxValueFromABIType(boxName1, new ABIUintType(32))\n  \n  console.log(`\\nABI-Decoded box value: ${Number(box1AbiValue)}`)\n  console.log(`Filtered boxes count: ${boxes.length}`)\n  console.log(`First box decoded value: ${Number(boxes[0].value)}`)\n  \n  console.log('\\n\u2705 Successfully demonstrated all state retrieval methods!')\n}\n\n// Run the example\nretrieveAppState().catch(console.error)"
    },
    {
      "example_id": "145-retrieve-and-decode-application-state-global-local-and-box-storage",
      "title": "Retrieve and Decode Application State (Global, Local, and Box Storage)",
      "summary": "Demonstrates how to retrieve and decode all types of application state including global state, local state (account-specific), and box storage. Shows how to work with different data types (integers, strings, raw bytes) and decode box values using ABI types.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "state management",
      "specific_use_case": "Retrieve and decode global state, local state, and box storage values",
      "target_users": [
        "SDK developers",
        "Smart contract developers"
      ],
      "features_tested": [
        "client.getGlobalState",
        "client.getLocalState",
        "client.getBoxValues",
        "client.getBoxValue",
        "client.getBoxValuesFromABIType",
        "client.getBoxValueFromABIType"
      ],
      "feature_tags": [
        "state-management",
        "global-state",
        "local-state",
        "box-storage",
        "abi-decoding",
        "app-client",
        "typed-client"
      ],
      "folder": "145-retrieve-and-decode-application-state-global-local-and-box-storage",
      "prerequisites": {
        "tools": [
          "algokit",
          "docker"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils",
          "algosdk"
        ],
        "environment": [
          {
            "name": "ALGOD_SERVER",
            "required": false,
            "example": "http://localhost"
          },
          {
            "name": "ALGOD_PORT",
            "required": false,
            "example": "4001"
          },
          {
            "name": "ALGOD_TOKEN",
            "required": false,
            "example": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
          }
        ]
      },
      "run_instructions": {
        "setup": [
          "Start LocalNet using 'algokit localnet start'",
          "Ensure you have a deployed smart contract with state methods (set_global, set_local, set_box, opt_in)"
        ],
        "install": [
          "npm install"
        ],
        "execute": [
          "npm run start"
        ]
      },
      "expected_output": [
        "Global state values (int1, int2, bytes1, bytes2) displayed",
        "Local state values (local_int1, local_int2, local_bytes1, local_bytes2) displayed",
        "Box storage values retrieved and decoded",
        "ABI-typed box values decoded and displayed"
      ],
      "source_tests": [
        {
          "file": "src/types/app-client.spec.ts",
          "test_name": "Retrieve state"
        }
      ],
      "artifacts_plan": [
        {
          "target_file": "state_contract.py",
          "type": "contract",
          "action": "generate",
          "source_path": null,
          "note": "Sample smart contract with global, local, and box state methods"
        }
      ],
      "notes": "This example requires a smart contract with methods: set_global, set_local, set_box, and opt_in. The contract should support global state (int1, int2, bytes1, bytes2), local state (local_int1, local_int2, local_bytes1, local_bytes2), and box storage.",
      "generated_code": "import { AlgorandClient } from '@algorandfoundation/algokit-utils'\nimport { ABIUintType } from 'algosdk'\nimport * as algokit from '@algorandfoundation/algokit-utils'\n\n/**\n * This example demonstrates how to retrieve and decode different types of\n * application state: global state, local state, and box storage.\n * \n * Prerequisites:\n * - AlgoKit installed and LocalNet running\n * - A deployed smart contract with state management methods\n */\n\nasync function retrieveApplicationState() {\n  // Initialize AlgorandClient to connect to LocalNet\n  const algorand = AlgorandClient.defaultLocalNet()\n  const algod = algorand.client.algod\n  const indexer = algorand.client.indexer\n\n  // Get a test account with funds\n  const testAccount = await algorand.account.localNetDispenser()\n\n  console.log('Deploying smart contract...')\n  // Note: Replace this with your actual contract deployment\n  // const { client } = await deploy(testAccount, algod, indexer)\n  // For this example, assume 'client' is your typed application client\n  \n  // ==========================================\n  // GLOBAL STATE MANAGEMENT\n  // ==========================================\n  console.log('\\n=== Working with Global State ===')\n  \n  // Set global state values with different types\n  // int1=1, int2=2, bytes1='asdf', bytes2=[1,2,3,4]\n  await client.call({ \n    method: 'set_global', \n    methodArgs: [1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])] \n  })\n  \n  // Retrieve global state\n  const globalState = await client.getGlobalState()\n  \n  console.log('Global State Keys:', Object.keys(globalState).sort())\n  console.log('int1:', globalState.int1.value) // Expected: 1n\n  console.log('int2:', globalState.int2.value) // Expected: 2n\n  console.log('bytes1:', globalState.bytes1.value) // Expected: 'asdf'\n  console.log('bytes2 (raw):', globalState.bytes2.valueRaw) // Expected: Uint8Array([1, 2, 3, 4])\n  \n  // ==========================================\n  // LOCAL STATE MANAGEMENT\n  // ==========================================\n  console.log('\\n=== Working with Local State ===')\n  \n  // First, opt into the application to enable local state\n  await client.optIn({ method: 'opt_in', methodArgs: [] })\n  console.log('Account opted into application')\n  \n  // Set local state values\n  await client.call({ \n    method: 'set_local', \n    methodArgs: [1, 2, 'asdf', new Uint8Array([1, 2, 3, 4])] \n  })\n  \n  // Retrieve local state for the test account\n  const localState = await client.getLocalState(testAccount)\n  \n  console.log('Local State Keys:', Object.keys(localState).sort())\n  console.log('local_int1:', localState.local_int1.value) // Expected: 1n\n  console.log('local_int2:', localState.local_int2.value) // Expected: 2n\n  console.log('local_bytes1:', localState.local_bytes1.value) // Expected: 'asdf'\n  console.log('local_bytes2 (raw):', localState.local_bytes2.valueRaw) // Expected: Uint8Array([1, 2, 3, 4])\n  \n  // ==========================================\n  // BOX STORAGE MANAGEMENT\n  // ==========================================\n  console.log('\\n=== Working with Box Storage ===')\n  \n  // Define box names\n  const boxName1 = new Uint8Array([0, 0, 0, 1])\n  const boxName1Base64 = Buffer.from(boxName1).toString('base64')\n  const boxName2 = new Uint8Array([0, 0, 0, 2])\n  const boxName2Base64 = Buffer.from(boxName2).toString('base64')\n  \n  // Fund the app account to pay for box storage\n  await client.fundAppAccount(algokit.algo(1))\n  console.log('App account funded for box storage')\n  \n  // Create box 1 with string value\n  await client.call({\n    method: 'set_box',\n    methodArgs: [boxName1, 'value1'],\n    boxes: [boxName1],\n  })\n  console.log('Box 1 created with value: \"value1\"')\n  \n  // Create box 2 with string value\n  await client.call({\n    method: 'set_box',\n    methodArgs: [boxName2, 'value2'],\n    boxes: [boxName2],\n  })\n  console.log('Box 2 created with value: \"value2\"')\n  \n  // Retrieve all box values\n  const boxValues = await client.getBoxValues()\n  console.log('\\nAll boxes:', boxValues.map((b) => b.name.nameBase64))\n  \n  // Find and display box 1 value\n  const box1 = boxValues.find((b) => b.name.nameBase64 === boxName1Base64)\n  console.log('Box 1 value:', Buffer.from(box1!.value).toString()) // 'value1'\n  \n  // Retrieve a specific box value\n  const box1Value = await client.getBoxValue(boxName1)\n  console.log('Box 1 value (direct):', Buffer.from(box1Value).toString())\n  \n  // Find and display box 2 value\n  const box2 = boxValues.find((b) => b.name.nameBase64 === boxName2Base64)\n  console.log('Box 2 value:', Buffer.from(box2!.value).toString()) // 'value2'\n  \n  // ==========================================\n  // ABI-TYPED BOX VALUES\n  // ==========================================\n  console.log('\\n=== Working with ABI-Typed Box Values ===')\n  \n  // Store an ABI-encoded uint32 value in box 1\n  const expectedValue = 1234524352\n  await client.call({\n    method: 'set_box',\n    methodArgs: [boxName1, new ABIUintType(32).encode(expectedValue)],\n    boxes: [boxName1],\n  })\n  console.log(`Box 1 updated with ABI uint32 value: ${expectedValue}`)\n  \n  // Retrieve and decode box values using ABI type\n  const boxes = await client.getBoxValuesFromABIType(\n    new ABIUintType(32), \n    (n) => n.nameBase64 === boxName1Base64\n  )\n  console.log('Number of matching boxes:', boxes.length)\n  console.log('Decoded value:', Number(boxes[0].value)) // Expected: 1234524352\n  \n  // Retrieve a single box value and decode it using ABI type\n  const box1AbiValue = await client.getBoxValueFromABIType(boxName1, new ABIUintType(32))\n  console.log('Box 1 decoded uint32:', Number(box1AbiValue)) // Expected: 1234524352\n  \n  console.log('\\n\u2705 Successfully retrieved and decoded all application state types!')\n}\n\n// Run the example\nretrieveApplicationState().catch((error) => {\n  console.error('Error:', error)\n  process.exit(1)\n})\n"
    },
    {
      "example_id": "146-working-with-complex-multi-level-abi-structures",
      "title": "Working with Complex Multi-Level ABI Structures",
      "summary": "Master complex ABI type structures with multiple nesting levels. This example demonstrates handling of structures that combine dynamic arrays, static arrays, and nested tuples - representing real-world smart contract scenarios.",
      "language": "typescript",
      "complexity": "complex",
      "example_potential": "high",
      "use_case_category": "ABI type conversion",
      "specific_use_case": "Convert highly complex nested structures combining arrays and tuples (byte[2][],uint8,(bool,byte[3])) for real-world smart contract data",
      "target_users": [
        "Smart contract developers",
        "SDK developers"
      ],
      "features_tested": [
        "convertAbiByteArrays",
        "ABITupleType",
        "ABIArrayDynamicType",
        "ABIArrayStaticType",
        "ABIUintType",
        "ABIByteType",
        "ABIBoolType",
        "complex nested structures"
      ],
      "feature_tags": [
        "abi",
        "complex-structures",
        "nested-arrays",
        "tuples",
        "dynamic-arrays",
        "type-conversion",
        "smart-contracts",
        "advanced",
        "algosdk"
      ],
      "folder": "146-working-with-complex-multi-level-abi-structures",
      "prerequisites": {
        "tools": [
          "node",
          "npm"
        ],
        "libraries": [
          "@algorandfoundation/algokit-utils"
        ],
        "environment": []
      },
      "run_instructions": {
        "setup": [],
        "install": [
          "npm install @algorandfoundation/algokit-utils"
        ],
        "execute": [
          "npx tsx main.ts"
        ]
      },
      "expected_output": [
        "Complex structure created: (byte[2][],uint8,(bool,byte[3]))",
        "Successfully converted all nested elements",
        "First element: Dynamic array of byte[2] arrays",
        "Second element: uint8 value (123)",
        "Third element: Nested tuple with bool and byte[3]",
        "All byte arrays converted to Uint8Array instances",
        "Structure ready for smart contract interaction"
      ],
      "source_tests": [
        {
          "file": "src/util.spec.ts",
          "test_name": "should handle complex nested structures"
        }
      ],
      "artifacts_plan": [],
      "notes": "This example represents the most complex ABI type structures you'll encounter in production. It demonstrates multi-level conversion with mixed array types (dynamic and static) combined with nested tuples. Understanding this pattern is essential for working with advanced smart contracts that handle complex data structures.",
      "generated_code": "import {\n  ABIByteType,\n  ABIArrayStaticType,\n  ABIArrayDynamicType,\n  ABITupleType,\n  ABIBoolType,\n  ABIUintType,\n  convertAbiByteArrays,\n  type ABIValue,\n} from '@algorandfoundation/algokit-utils'\n\n/**\n * Demonstrates working with highly complex nested ABI structures.\n * \n * This example shows how to:\n * 1. Define complex multi-level type structures\n * 2. Combine dynamic arrays, static arrays, and tuples\n * 3. Convert complex JavaScript structures to ABI format\n * 4. Handle real-world smart contract data scenarios\n * \n * The structure being created is: (byte[2][],uint8,(bool,byte[3]))\n * - First element: Dynamic array of static byte[2] arrays\n * - Second element: 8-bit unsigned integer\n * - Third element: Tuple containing a boolean and byte[3] array\n */\n\nfunction main() {\n  console.log('=== Working with Complex Multi-Level ABI Structures ===\\n')\n\n  // Step 1: Define the basic types\n  console.log('Step 1: Defining basic ABI types...')\n  const byteType = new ABIByteType()\n  const boolType = new ABIBoolType()\n  const uintType = new ABIUintType(8) // 8-bit unsigned integer\n  console.log('\u2713 Created basic types: byte, bool, uint8\\n')\n\n  // Step 2: Define array types\n  console.log('Step 2: Defining array types...')\n  \n  // Static array of 2 bytes: byte[2]\n  const byteArray2Type = new ABIArrayStaticType(byteType, 2)\n  console.log('\u2713 Created byte[2] - static array of 2 bytes')\n  \n  // Dynamic array of byte[2]: byte[2][]\n  const byteArrayDynType = new ABIArrayDynamicType(byteArray2Type)\n  console.log('\u2713 Created byte[2][] - dynamic array of byte[2]')\n  \n  // Static array of 3 bytes: byte[3]\n  const byteArray3Type = new ABIArrayStaticType(byteType, 3)\n  console.log('\u2713 Created byte[3] - static array of 3 bytes\\n')\n\n  // Step 3: Define tuple types\n  console.log('Step 3: Defining tuple structures...')\n  \n  // Inner tuple: (bool, byte[3])\n  const innerTupleType = new ABITupleType([boolType, byteArray3Type])\n  console.log('\u2713 Created inner tuple: (bool, byte[3])')\n  \n  // Outer tuple: (byte[2][], uint8, (bool, byte[3]))\n  const outerTupleType = new ABITupleType([\n    byteArrayDynType,\n    uintType,\n    innerTupleType,\n  ])\n  console.log('\u2713 Created outer tuple: (byte[2][], uint8, (bool, byte[3]))\\n')\n\n  // Step 4: Prepare complex data structure\n  console.log('Step 4: Preparing complex data structure...')\n  const value = [\n    [\n      [1, 2],    // First byte[2]\n      [3, 4],    // Second byte[2]\n      [5, 6],    // Third byte[2]\n    ],           // Dynamic array of byte[2] arrays\n    123,         // uint8 value\n    [true, [7, 8, 9]], // Inner tuple: (bool, byte[3])\n  ]\n  console.log('Original structure:')\n  console.log('  byte[2][]: [[1,2], [3,4], [5,6]]')\n  console.log('  uint8: 123')\n  console.log('  (bool, byte[3]): [true, [7,8,9]]')\n  console.log()\n\n  // Step 5: Convert to ABI format\n  console.log('Step 5: Converting to ABI format...')\n  const result = convertAbiByteArrays(value, outerTupleType) as ABIValue[]\n  console.log('\u2713 Conversion complete\\n')\n\n  // Step 6: Inspect the results\n  console.log('Step 6: Inspecting converted results...\\n')\n\n  // Check first element (byte[2][])\n  console.log('First element (byte[2][] - dynamic array):')\n  const byteArrays = result[0] as ABIValue[]\n  console.log('  Is array:', Array.isArray(byteArrays))\n  console.log('  Length:', byteArrays.length)\n  console.log('  Elements:')\n  byteArrays.forEach((item, index) => {\n    console.log(`    [${index}]: ${item.constructor.name} - [${Array.from(item as Uint8Array).join(', ')}]`)\n  })\n  console.log('  \u2713 All elements are Uint8Array instances')\n  console.log()\n\n  // Check second element (uint8)\n  console.log('Second element (uint8):')\n  console.log('  Type:', typeof result[1])\n  console.log('  Value:', result[1])\n  console.log('  \u2713 Integer value preserved')\n  console.log()\n\n  // Check third element (nested tuple)\n  console.log('Third element (nested tuple: (bool, byte[3])):')\n  const tuple = result[2] as ABIValue[]\n  console.log('  Is array:', Array.isArray(tuple))\n  console.log('  Length:', tuple.length)\n  console.log()\n\n  console.log('  First element (bool):')\n  console.log('    Type:', typeof tuple[0])\n  console.log('    Value:', tuple[0])\n  console.log('    \u2713 Boolean value preserved')\n  console.log()\n\n  console.log('  Second element (byte[3]):')\n  console.log('    Type:', tuple[1].constructor.name)\n  console.log('    Values:', Array.from(tuple[1] as Uint8Array))\n  console.log('    \u2713 Converted to Uint8Array')\n  console.log()\n\n  // Summary\n  console.log('=== Summary ===')\n  console.log('\u2713 Successfully created complex multi-level structure')\n  console.log('\u2713 Dynamic array of static arrays handled correctly')\n  console.log('\u2713 Integer value passed through unchanged')\n  console.log('\u2713 Nested tuple with mixed types converted properly')\n  console.log('\u2713 All byte arrays converted to Uint8Array instances')\n  console.log('\u2713 Structure ready for smart contract interactions')\n  console.log()\n  console.log('This pattern represents real-world smart contract scenarios')\n  console.log('where complex data structures need to be encoded for ABI calls.')\n}\n\n// Run the example\nmain()"
    }
  ],
  "summary": {
    "total_examples": 146,
    "complexity_breakdown": {
      "simple": 81,
      "moderate": 55,
      "complex": 10
    }
  },
  "refinement_history": []
}